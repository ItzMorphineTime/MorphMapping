<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta author="Joe Loe">
    <title>Projection Studio v2.8</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0c;
            --bg-secondary: #111114;
            --bg-tertiary: #18181c;
            --bg-panel: #141418;
            --border-color: #2a2a32;
            --border-hover: #3a3a44;
            --text-primary: #e8e8ec;
            --text-secondary: #9898a4;
            --text-muted: #5c5c68;
            --accent-primary: #00d4aa;
            --accent-secondary: #00a888;
            --accent-glow: rgba(0, 212, 170, 0.15);
            --warning: #ffaa00;
            --danger: #ff4466;
            --projector-color: #00aaff;
            --surface-color: #8844ff;
        }
        
        body { font-family: 'Outfit', sans-serif; background: var(--bg-primary); color: var(--text-primary); height: 100vh; overflow: hidden; }
        .app-container { display: grid; grid-template-columns: 320px 1fr 360px; grid-template-rows: 56px 1fr 48px; height: 100vh; }
        
        .header { grid-column: 1 / -1; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent-primary), var(--projector-color)); border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .logo-icon svg { width: 18px; height: 18px; fill: var(--bg-primary); }
        .logo-text { font-weight: 600; font-size: 16px; letter-spacing: -0.02em; }
        .logo-text span { color: var(--text-secondary); font-weight: 400; }
        .header-actions { display: flex; gap: 8px; }
        
        .btn { font-family: 'Outfit', sans-serif; padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; align-items: center; gap: 6px; }
        .btn:hover { background: var(--bg-panel); border-color: var(--border-hover); }
        .btn-primary { background: var(--accent-primary); border-color: var(--accent-primary); color: var(--bg-primary); }
        .btn-primary:hover { background: var(--accent-secondary); border-color: var(--accent-secondary); }
        .btn svg { width: 14px; height: 14px; }
        
        .sidebar-left, .sidebar-right { background: var(--bg-secondary); overflow-y: auto; }
        .sidebar-left { border-right: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .sidebar-right { border-left: 1px solid var(--border-color); }
        
        .panel-section { border-bottom: 1px solid var(--border-color); }
        .panel-header { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; }
        .panel-header:hover { background: var(--bg-tertiary); }
        .panel-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-secondary); }
        .panel-content { padding: 0 16px 16px; }
        .panel-badge { background: var(--bg-tertiary); padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 500; color: var(--text-muted); }
        
        .object-list { display: flex; flex-direction: column; gap: 4px; }
        .object-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; cursor: pointer; transition: all 0.15s ease; border: 1px solid transparent; }
        .object-item:hover { background: var(--bg-panel); }
        .object-item.selected { border-color: var(--accent-primary); background: var(--accent-glow); }
        .object-icon { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .object-icon.projector { background: rgba(0, 170, 255, 0.15); }
        .object-icon.projector svg { fill: var(--projector-color); }
        .object-icon.surface { background: rgba(136, 68, 255, 0.15); }
        .object-icon.surface svg { fill: var(--surface-color); }
        .object-icon svg { width: 14px; height: 14px; }
        .object-info { flex: 1; min-width: 0; }
        .object-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .object-type { font-size: 11px; color: var(--text-muted); }
        .object-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s ease; }
        .object-item:hover .object-actions { opacity: 1; }
        
        .icon-btn { width: 24px; height: 24px; border-radius: 4px; border: none; background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .icon-btn:hover { background: var(--border-color); color: var(--text-primary); }
        .icon-btn.danger:hover { background: rgba(255, 68, 102, 0.2); color: var(--danger); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }
        
        .add-buttons { display: flex; gap: 8px; padding: 16px; border-top: 1px solid var(--border-color); margin-top: auto; }
        .add-btn { flex: 1; padding: 10px; border-radius: 6px; border: 1px dashed var(--border-color); background: transparent; color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .add-btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); background: var(--accent-glow); }
        .add-btn svg { width: 18px; height: 18px; fill: currentColor; }
        
        .property-group { margin-bottom: 16px; }
        .property-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 10px; }
        .property-row { display: flex; align-items: center; margin-bottom: 8px; }
        .property-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .property-inputs { display: flex; gap: 4px; flex: 1; }
        .input-group { flex: 1; position: relative; }
        .input-group label { position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-size: 10px; font-weight: 600; color: var(--text-muted); pointer-events: none; }
        .input-group input { width: 100%; padding: 8px 8px 8px 22px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .input-group input:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        .single-input { flex: 1; }
        .single-input input, .single-input select { width: 100%; padding: 8px 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .single-input select { font-family: 'Outfit', sans-serif; cursor: pointer; }
        .single-input input:focus, .single-input select:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        
        .slider-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .slider-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .slider-container { flex: 1; display: flex; align-items: center; gap: 10px; }
        .slider { flex: 1; -webkit-appearance: none; height: 4px; border-radius: 2px; background: var(--border-color); outline: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; }
        .slider-value { width: 50px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-secondary); text-align: right; }
        .slider-input { width: 55px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-primary); background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 3px; }
        .slider-input:focus { outline: none; border-color: var(--accent-color); }
        .slider-input::-webkit-inner-spin-button, .slider-input::-webkit-outer-spin-button { opacity: 0.5; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .toggle-label { font-size: 12px; color: var(--text-secondary); }
        .toggle { width: 36px; height: 20px; border-radius: 10px; background: var(--border-color); cursor: pointer; position: relative; transition: background 0.2s ease; }
        .toggle.active { background: var(--accent-primary); }
        .toggle::after { content: ''; position: absolute; width: 16px; height: 16px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: transform 0.2s ease; }
        .toggle.active::after { transform: translateX(16px); }
        
        .viewport { background: var(--bg-primary); position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; }
        #canvas-container canvas { display: block; }
        
        .viewport-overlay { position: absolute; top: 12px; left: 12px; display: flex; gap: 8px; }
        .view-btn { padding: 6px 12px; border-radius: 4px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 11px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; }
        .view-btn:hover, .view-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); }
        .view-btn.pilot-btn { margin-left: 8px; border-color: #e67e22; color: #e67e22; }
        .view-btn.pilot-btn.active { background: #e67e22; color: #111114; border-color: #e67e22; }
        .view-btn.pilot-btn:hover { background: rgba(230, 126, 34, 0.2); }
        
        .transform-tools { position: absolute; top: 12px; right: 12px; display: flex; gap: 4px; }
        .tool-btn { width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .tool-btn:hover:not(:disabled) { border-color: var(--border-hover); color: var(--text-primary); }
        .tool-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); background: rgba(0, 212, 170, 0.1); }
        .tool-btn svg { width: 18px; height: 18px; fill: currentColor; }
        .tool-btn.disabled, .tool-btn:disabled { opacity: 0.4; pointer-events: none; cursor: not-allowed; }
        .tool-divider { width: 1px; background: var(--border-color); margin: 4px 4px; }
        
        .gizmo-info { position: absolute; top: 60px; right: 12px; background: rgba(17, 17, 20, 0.95); backdrop-filter: blur(12px); padding: 12px 16px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 11px; display: none; min-width: 180px; box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
        .gizmo-info.visible { display: block; animation: gizmoInfoSlide 0.2s ease-out; }
        @keyframes gizmoInfoSlide { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }
        .gizmo-info-title { color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; font-size: 9px; letter-spacing: 0.08em; display: flex; align-items: center; gap: 6px; }
        .gizmo-info-title::before { content: ''; width: 8px; height: 8px; border-radius: 50%; background: var(--accent-primary); animation: gizmoPulse 1.5s ease-in-out infinite; }
        @keyframes gizmoPulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.2); } }
        .gizmo-info-value { font-family: 'JetBrains Mono', monospace; color: var(--text-primary); }
        .gizmo-info-row { display: flex; gap: 16px; margin-top: 6px; }
        .gizmo-info-axis { display: flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 4px; transition: all 0.15s ease; }
        .gizmo-info-axis.x { color: #ff5555; }
        .gizmo-info-axis.y { color: #55ff55; }
        .gizmo-info-axis.z { color: #55aaff; }
        .gizmo-info-axis.active { background: rgba(255,255,255,0.1); transform: scale(1.05); }
        .gizmo-info-axis.active.x { background: rgba(255,85,85,0.2); box-shadow: 0 0 8px rgba(255,85,85,0.3); }
        .gizmo-info-axis.active.y { background: rgba(85,255,85,0.2); box-shadow: 0 0 8px rgba(85,255,85,0.3); }
        .gizmo-info-axis.active.z { background: rgba(85,170,255,0.2); box-shadow: 0 0 8px rgba(85,170,255,0.3); }
        .gizmo-info-delta { font-size: 10px; color: var(--text-muted); margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color); }
        .gizmo-info-delta span { color: var(--accent-primary); font-weight: 600; }
        
        .distance-label { position: absolute; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px); color: #00ff00; padding: 6px 10px; border-radius: 4px; font-size: 11px; font-family: 'JetBrains Mono', monospace; pointer-events: none; white-space: nowrap; border: 1px solid rgba(0, 255, 0, 0.3); z-index: 100; transform: translate(-50%, -50%); }
        .distance-label strong { color: #fff; font-weight: 500; }
        
        .snap-controls { position: absolute; bottom: 60px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); display: flex; align-items: center; gap: 10px; }
        .snap-label { font-size: 10px; color: var(--text-muted); }
        .snap-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .snap-toggle input { display: none; }
        .snap-checkbox { width: 14px; height: 14px; border-radius: 3px; border: 1px solid var(--border-color); background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; }
        .snap-toggle input:checked + .snap-checkbox { background: var(--accent-primary); border-color: var(--accent-primary); }
        .snap-checkbox svg { width: 10px; height: 10px; fill: var(--bg-primary); opacity: 0; }
        .snap-toggle input:checked + .snap-checkbox svg { opacity: 1; }
        .snap-value { width: 50px; padding: 4px 6px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 10px; text-align: center; }
        .snap-value:focus { outline: none; border-color: var(--accent-primary); }
        
        .viewport-info { position: absolute; bottom: 12px; left: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 10px 14px; border-radius: 6px; border: 1px solid var(--border-color); }
        .viewport-info-row { display: flex; gap: 16px; font-size: 11px; }
        .viewport-info-item { display: flex; align-items: center; gap: 6px; }
        .viewport-info-item span:first-child { color: var(--text-muted); }
        .viewport-info-item span:last-child { font-family: 'JetBrains Mono', monospace; color: var(--text-secondary); }
        
        .controls-hint { position: absolute; bottom: 110px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 10px; color: var(--text-muted); }
        .controls-hint kbd { background: var(--bg-tertiary); padding: 2px 5px; border-radius: 3px; font-family: 'JetBrains Mono', monospace; margin: 0 2px; }
        
        .pattern-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .pattern-btn { aspect-ratio: 1; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); cursor: pointer; transition: all 0.15s ease; overflow: hidden; }
        .pattern-btn:hover { border-color: var(--border-hover); }
        .pattern-btn.active { border-color: var(--accent-primary); box-shadow: 0 0 0 1px var(--accent-primary); }
        .pattern-preview { width: 100%; height: 100%; }
        .pattern-grid-lines { background: linear-gradient(var(--text-muted) 1px, transparent 1px), linear-gradient(90deg, var(--text-muted) 1px, transparent 1px); background-size: 8px 8px; }
        .pattern-checker { background: repeating-conic-gradient(var(--text-muted) 0% 25%, var(--bg-tertiary) 0% 50%) 50% / 12px 12px; }
        .pattern-gradient { background: linear-gradient(90deg, #000, #fff); }
        .pattern-colorbars { background: linear-gradient(90deg, #fff 0% 14.28%, #ff0 14.28% 28.56%, #0ff 28.56% 42.84%, #0f0 42.84% 57.12%, #f0f 57.12% 71.4%, #f00 71.4% 85.68%, #00f 85.68% 100%); }
        .pattern-cross { background: var(--bg-tertiary); position: relative; }
        .pattern-cross::before, .pattern-cross::after { content: ''; position: absolute; background: var(--text-muted); }
        .pattern-cross::before { width: 1px; height: 100%; left: 50%; }
        .pattern-cross::after { height: 1px; width: 100%; top: 50%; }
        .pattern-white { background: #fff; }
        .pattern-none { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--text-muted); }
        .pattern-blend { background: linear-gradient(90deg, rgba(255,0,0,0.5) 0% 20%, transparent 20% 80%, rgba(0,255,0,0.5) 80% 100%); }
        
        .status-bar { grid-column: 1 / -1; background: var(--bg-tertiary); border-top: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; font-size: 11px; }
        .status-left, .status-right { display: flex; align-items: center; gap: 16px; }
        .status-item { display: flex; align-items: center; gap: 6px; color: var(--text-muted); }
        .status-item svg { width: 12px; height: 12px; fill: currentColor; }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent-primary); }
        
        .empty-state { padding: 24px 16px; text-align: center; }
        .empty-state p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        
        .no-selection { padding: 40px 20px; text-align: center; }
        .no-selection-icon { width: 48px; height: 48px; margin: 0 auto 16px; background: var(--bg-tertiary); border-radius: 12px; display: flex; align-items: center; justify-content: center; }
        .no-selection-icon svg { width: 24px; height: 24px; fill: var(--text-muted); }
        .no-selection h3 { font-size: 14px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary); }
        .no-selection p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        .coverage-display { margin-top: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; border: 1px solid var(--border-color); }
        .coverage-bar { height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; margin-top: 8px; }
        .coverage-fill { height: 100%; background: var(--accent-primary); border-radius: 3px; transition: width 0.3s ease; }
        .coverage-stats { display: flex; justify-content: space-between; font-size: 11px; margin-top: 8px; }
        .coverage-stat { color: var(--text-muted); }
        .coverage-stat span { color: var(--text-secondary); font-family: 'JetBrains Mono', monospace; }
        
        .texture-upload { margin-top: 8px; padding: 16px; border: 2px dashed var(--border-color); border-radius: 6px; text-align: center; cursor: pointer; transition: all 0.15s ease; }
        .texture-upload:hover { border-color: var(--accent-primary); background: var(--accent-glow); }
        .texture-upload input { display: none; }
        .texture-upload p { font-size: 11px; color: var(--text-muted); margin: 0; }
        .texture-preview { width: 100%; height: 80px; border-radius: 4px; background-size: contain; background-repeat: no-repeat; background-position: center; background-color: var(--bg-primary); margin-bottom: 8px; border: 1px solid var(--border-color); }
        
        /* Video controls */
        .video-preview { background: var(--bg-primary); border-radius: 6px; padding: 10px; border: 1px solid var(--border-color); margin-bottom: 8px; }
        .video-info { display: flex; align-items: center; gap: 6px; color: var(--accent-primary); font-size: 11px; margin-bottom: 8px; }
        .video-controls { display: flex; gap: 4px; margin-bottom: 8px; }
        .video-btn { width: 32px; height: 28px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .video-btn:hover { border-color: var(--accent-primary); color: var(--text-primary); }
        .video-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); background: rgba(0, 212, 170, 0.1); }
        .video-seek { margin-bottom: 4px; }
        .video-seek input[type="range"] { width: 100%; height: 4px; -webkit-appearance: none; background: var(--border-color); border-radius: 2px; outline: none; }
        .video-seek input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; }
        .video-time { font-size: 10px; color: var(--text-muted); text-align: center; margin-top: 4px; }
        
        /* Pattern scroll controls */
        .scroll-controls { background: var(--bg-primary); border-radius: 6px; padding: 10px; border: 1px solid var(--border-color); margin-top: 8px; }
        .scroll-controls-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .scroll-controls-title { font-size: 11px; color: var(--text-secondary); font-weight: 500; }
        .clear-texture-btn { margin-top: 8px; width: 100%; padding: 6px; font-size: 11px; }
        
        .luminance-legend { 
            margin-top: 12px; 
            padding: 12px; 
            background: var(--bg-primary); 
            border-radius: 6px; 
            border: 1px solid var(--border-color);
        }
        .legend-gradient { 
            height: 20px; 
            border-radius: 4px; 
            background: linear-gradient(90deg, 
                #000033 0%, 
                #0044aa 20%, 
                #00aa44 40%, 
                #aaaa00 60%, 
                #ff6600 80%, 
                #ff0000 95%,
                #ffffff 100%
            ); 
            margin-bottom: 6px;
        }
        .legend-labels { 
            display: flex; 
            justify-content: space-between; 
            font-size: 10px; 
            color: var(--text-secondary); 
            font-family: 'JetBrains Mono', monospace;
        }
        .legend-unit {
            text-align: center;
            font-size: 9px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 480px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.2s ease;
        }
        .modal-overlay.active .modal {
            transform: scale(1);
        }
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .modal-title {
            font-size: 16px;
            font-weight: 600;
        }
        .modal-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .modal-close svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 50vh;
        }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .export-option {
            display: flex;
            align-items: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }
        .export-option:hover {
            background: var(--bg-panel);
            border-color: var(--border-hover);
        }
        .export-option.selected {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
        }
        .export-option-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        .export-option-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--accent-primary);
        }
        .export-option-info h4 {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 2px;
        }
        .export-option-info p {
            font-size: 11px;
            color: var(--text-muted);
            margin: 0;
        }
        .export-checkbox {
            margin-left: auto;
        }
        .checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .checkbox.checked {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        .checkbox svg {
            width: 12px;
            height: 12px;
            fill: var(--bg-primary);
            opacity: 0;
        }
        .checkbox.checked svg {
            opacity: 1;
        }
        .import-preview {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .import-preview h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .import-stat {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        .import-stat:last-child {
            border-bottom: none;
        }
        .import-stat span:first-child {
            color: var(--text-muted);
        }
        .import-stat span:last-child {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        .import-warning {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 6px;
            margin-top: 12px;
        }
        .import-warning svg {
            width: 16px;
            height: 16px;
            fill: var(--warning);
            flex-shrink: 0;
            margin-top: 1px;
        }
        .import-warning p {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }
        .filename-input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            margin-bottom: 16px;
        }
        .filename-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-primary);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        .toast.success {
            border-color: var(--accent-primary);
        }
        .toast.error {
            border-color: var(--danger);
        }
        .toast svg {
            width: 18px;
            height: 18px;
        }
        .toast.success svg {
            fill: var(--accent-primary);
        }
        .toast.error svg {
            fill: var(--danger);
        }
        
        .password-modal .modal {
            width: 360px;
        }
        .password-input-wrapper {
            position: relative;
        }
        .password-input {
            width: 100%;
            padding: 12px 40px 12px 14px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        .password-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .password-input.error {
            border-color: var(--danger);
            animation: shake 0.4s ease;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px); }
            40%, 80% { transform: translateX(6px); }
        }
        .password-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }
        .password-toggle:hover {
            color: var(--text-secondary);
        }
        .password-toggle svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .password-error {
            color: var(--danger);
            font-size: 11px;
            margin-top: 8px;
            display: none;
        }
        .password-error.visible {
            display: block;
        }
        
        /* Contact Me Button & Panel */
        .contact-wrapper {
            position: relative;
            display: flex;
        }
        .contact-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(138, 43, 226, 0.1));
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .contact-btn:hover {
            border-color: #ff6b6b;
            color: #ff6b6b;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(138, 43, 226, 0.2));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.2);
        }
        .contact-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        .contact-btn .heart {
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .contact-panel {
            position: absolute;
            top: calc(100% + 12px);
            right: 0;
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.95);
            transform-origin: top right;
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        .contact-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }
        .contact-panel-gradient {
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #a55eea);
            animation: gradientSlide 3s linear infinite;
            background-size: 200% 100%;
        }
        @keyframes gradientSlide {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        .contact-panel-content {
            padding: 20px;
        }
        .contact-panel-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .contact-panel-title svg {
            width: 18px;
            height: 18px;
            fill: #feca57;
        }
        .contact-panel-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }
        .contact-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .contact-link {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-radius: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .contact-link:hover {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
            color: var(--text-primary);
            transform: translateX(4px);
        }
        .contact-link svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        .contact-link.github svg { fill: #f0f0f0; }
        .contact-link.discord svg { fill: #5865F2; }
        .contact-link.github:hover svg { fill: #fff; }
        .contact-link.discord:hover svg { fill: #7289da; }
        .contact-link-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .contact-link-label {
            font-size: 11px;
            color: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                <span class="logo-text">Projection Studio <span>v2.8</span></span>
            </div>
            <div class="header-actions">
                <button class="btn" onclick="confirmNewProject()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>New</button>
                <button class="btn" onclick="document.getElementById('import-file').click()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>Import</button>
                <input type="file" id="import-file" accept=".json,.csv" style="display:none" onchange="importConfig(this.files[0])">
                <button class="btn" onclick="showExportModal()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>Export</button>
                <button class="btn btn-primary" onclick="quickSave()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>Save</button>
                <div class="contact-wrapper">
                    <button class="contact-btn" onclick="toggleContactPanel()">
                        <svg class="heart" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        Support
                    </button>
                    <div class="contact-panel" id="contact-panel">
                        <div class="contact-panel-gradient"></div>
                        <div class="contact-panel-content">
                            <div class="contact-panel-title">
                                <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                                Hey there!
                            </div>
                            <div class="contact-panel-message">
                                Please consider buying me a Coffee if you want to export/import your projects! Your support helps keep this tool free and improving.
                            </div>
                            <div class="contact-links">
                                <a href="https://github.com/ItzMorphineTime/MorphMapping/issues" target="_blank" class="contact-link github">
                                    <svg viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
                                    <div class="contact-link-text">
                                        <span class="contact-link-label">ItzMorphineTime</span>
                                        GitHub
                                    </div>
                                </a>
                                <a href="https://discord.com/users/211604375380951050" target="_blank" class="contact-link discord">
                                    <svg viewBox="0 0 24 24"><path d="M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189z"/></svg>
                                    <div class="contact-link-text">
                                        <span class="contact-link-label">morph_remembers</span>
                                        Discord
                                    </div>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        
        <aside class="sidebar-left">
            <div class="panel-section">
                <div class="panel-header" title="Maximum 8 simultaneous projectors supported"><span class="panel-title">Projectors</span><span class="panel-badge" id="projector-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="projector-list"><div class="empty-state"><p>No projectors added yet.</p></div></div></div>
            </div>
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Surfaces</span><span class="panel-badge" id="surface-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="surface-list"><div class="empty-state"><p>No surfaces added yet.</p></div></div></div>
            </div>
            <div class="add-buttons">
                <button class="add-btn" onclick="addProjector()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Projector</button>
                <button class="add-btn" onclick="addSurface()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Surface</button>
                <button class="add-btn" onclick="document.getElementById('obj-import').click()"><svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>OBJ</button>
                <input type="file" id="obj-import" accept=".obj" style="display:none" onchange="importOBJSurface(this.files[0])">
            </div>
        </aside>
        
        <main class="viewport">
            <div id="canvas-container"></div>
            <div class="viewport-overlay">
                <button class="view-btn active" onclick="setView('perspective')">Perspective</button>
                <button class="view-btn" onclick="setView('top')">Top</button>
                <button class="view-btn" onclick="setView('front')">Front</button>
                <button class="view-btn" onclick="setView('side')">Side</button>
                <button class="view-btn" onclick="setView('projector')">Projector POV</button>
                <button class="view-btn pilot-btn" id="pilot-mode-btn" onclick="togglePilotMode()" style="display: none;" title="When enabled, camera movement controls projector position/rotation">ðŸŽ® Pilot</button>
            </div>
            
            <div class="transform-tools">
                <button class="tool-btn disabled" id="tool-select" onclick="setTransformMode('select')" title="Select (V)">
                    <svg viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-6.39 6.39-2.51L3 3zm10.57 10.57l-1.12 2.85-3.03-7.27 7.27 3.03-2.85 1.12l3.88 3.88-1.41 1.41-3.74-3.87z"/></svg>
                </button>
                <button class="tool-btn disabled" id="tool-translate" onclick="setTransformMode('translate')" title="Move (G)">
                    <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
                </button>
                <button class="tool-btn disabled" id="tool-rotate" onclick="setTransformMode('rotate')" title="Rotate (R)">
                    <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                </button>
                <div class="tool-divider"></div>
                <button class="tool-btn" id="undo-btn" onclick="undo()" title="Nothing to undo (Ctrl+Z)" disabled>
                    <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
                </button>
                <button class="tool-btn" id="tool-local" onclick="toggleCoordSpace()" title="World Space (click for Local)">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                </button>
            </div>
            
            <div class="gizmo-info" id="gizmo-info">
                <div class="gizmo-info-title" id="gizmo-info-title">Position</div>
                <div class="gizmo-info-row">
                    <span class="gizmo-info-axis x" id="gizmo-axis-x">X: <span id="gizmo-x">0.00</span></span>
                    <span class="gizmo-info-axis y" id="gizmo-axis-y">Y: <span id="gizmo-y">0.00</span></span>
                    <span class="gizmo-info-axis z" id="gizmo-axis-z">Z: <span id="gizmo-z">0.00</span></span>
                </div>
                <div class="gizmo-info-delta" id="gizmo-delta">Change: <span id="gizmo-delta-value">0.00</span></div>
            </div>
            
            <div class="snap-controls">
                <span class="snap-label">Snap:</span>
                <label class="snap-toggle">
                    <input type="checkbox" id="snap-enabled" onchange="updateSnapSettings()">
                    <div class="snap-checkbox"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg></div>
                </label>
                <input type="number" class="snap-value" id="snap-translate" value="0.5" step="0.1" min="0.1" title="Translation snap" onchange="updateSnapSettings()">
                <span class="snap-label">m</span>
                <input type="number" class="snap-value" id="snap-rotate" value="15" step="5" min="1" title="Rotation snap" onchange="updateSnapSettings()">
                <span class="snap-label">Â°</span>
            </div>
            <div class="viewport-info">
                <div class="viewport-info-row">
                    <div class="viewport-info-item"><span>Camera:</span><span id="camera-info">Perspective</span></div>
                    <div class="viewport-info-item"><span>Units:</span><span>Meters</span></div>
                </div>
            </div>
            <div class="controls-hint">
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;
                <kbd>Q</kbd><kbd>E</kbd> Up/Down &nbsp;
                <kbd>Drag</kbd> Look &nbsp;|&nbsp;
                <kbd>G</kbd> Translate &nbsp;
                <kbd>R</kbd> Rotate &nbsp;
                <kbd>Ctrl+Z</kbd> Undo &nbsp;
                <kbd>Esc</kbd> Deselect &nbsp;
                <kbd>Del</kbd> Delete
            </div>
        </main>
        
        <aside class="sidebar-right">
            <div id="properties-panel">
                <div class="no-selection">
                    <div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div>
                    <h3>No Selection</h3>
                    <p>Select an object to edit.</p>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Test Patterns</span></div>
                <div class="panel-content">
                    <div class="pattern-grid">
                        <button class="pattern-btn active" onclick="setPattern('none')" title="None"><div class="pattern-preview pattern-none">OFF</div></button>
                        <button class="pattern-btn" onclick="setPattern('grid')" title="Grid"><div class="pattern-preview pattern-grid-lines"></div></button>
                        <button class="pattern-btn" onclick="setPattern('checker')" title="Checkerboard"><div class="pattern-preview pattern-checker"></div></button>
                        <button class="pattern-btn" onclick="setPattern('gradient')" title="Gradient"><div class="pattern-preview pattern-gradient"></div></button>
                        <button class="pattern-btn" onclick="setPattern('colorbars')" title="Color Bars"><div class="pattern-preview pattern-colorbars"></div></button>
                        <button class="pattern-btn" onclick="setPattern('cross')" title="Focus Cross"><div class="pattern-preview pattern-cross"></div></button>
                        <button class="pattern-btn" onclick="setPattern('white')" title="White"><div class="pattern-preview pattern-white"></div></button>
                        <button class="pattern-btn" onclick="setPattern('blend')" title="Blend Zones"><div class="pattern-preview pattern-blend"></div></button>
                    </div>
                    <div class="scroll-controls" id="pattern-scroll-controls">
                        <div class="scroll-controls-header">
                            <span class="scroll-controls-title">Pattern Animation</span>
                            <div class="toggle" id="toggle-pattern-scroll" onclick="togglePatternScroll()"></div>
                        </div>
                        <div class="slider-row" style="margin-top: 8px;">
                            <span class="slider-label">Speed</span>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0.1" max="2" step="0.1" value="0.5" id="pattern-scroll-speed" oninput="updatePatternScrollSpeed(+this.value); this.nextElementSibling.value=Number(this.value).toFixed(1)">
                                <input type="number" class="slider-input" step="0.1" min="0.1" max="5" value="0.5" onchange="updatePatternScrollSpeed(+this.value); document.getElementById('pattern-scroll-speed').value=this.value">x
                            </div>
                        </div>
                        <div class="property-row" style="margin-top: 8px;">
                            <span class="property-label">Direction</span>
                            <div class="single-input">
                                <select id="pattern-scroll-direction" onchange="updatePatternScrollDirection(this.value)">
                                    <option value="horizontal">Horizontal â†’</option>
                                    <option value="vertical">Vertical â†‘</option>
                                    <option value="diagonal">Diagonal â†—</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Display Options</span></div>
                <div class="panel-content">
                    <div class="toggle-row"><span class="toggle-label">Show Frustums</span><div class="toggle active" id="toggle-frustums" onclick="toggleOption('frustums')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Grid</span><div class="toggle active" id="toggle-grid" onclick="toggleOption('grid')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Coverage</span><div class="toggle active" id="toggle-coverage" onclick="toggleOption('coverage')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Overlap</span><div class="toggle" id="toggle-overlap" onclick="toggleOption('overlap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Distance</span><div class="toggle" id="toggle-distance" onclick="toggleOption('distance')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Luminance Heatmap</span><div class="toggle" id="toggle-heatmap" onclick="toggleOption('heatmap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Wireframe</span><div class="toggle" id="toggle-wireframe" onclick="toggleOption('wireframe')"></div></div>
                </div>
            </div>
            
            <div class="panel-section" id="heatmap-panel" style="display: none;">
                <div class="panel-header"><span class="panel-title">Luminance Heatmap</span></div>
                <div class="panel-content">
                    <div class="property-group">
                        <div class="property-group-title">Scale (cd/mÂ²)</div>
                        <div class="slider-row">
                            <span class="slider-label">Max Value</span>
                            <div class="slider-container">
                                <input type="range" class="slider" min="100" max="10000" step="100" value="2000" id="heatmap-max-slider" oninput="updateHeatmapMax(+this.value); document.getElementById('heatmap-max-input').value=this.value">
                                <input type="number" class="slider-input" id="heatmap-max-input" step="100" min="100" max="20000" value="2000" onchange="updateHeatmapMax(+this.value); document.getElementById('heatmap-max-slider').value=this.value">
                            </div>
                        </div>
                    </div>
                    <div class="luminance-legend">
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>0</span>
                            <span id="legend-mid">1000</span>
                            <span id="legend-max">2000+</span>
                        </div>
                        <div class="legend-unit">cd/mÂ² (nits)</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Coverage Analysis</span></div>
                <div class="panel-content">
                    <div class="coverage-display">
                        <div class="property-group-title">Surface Coverage</div>
                        <div class="coverage-bar"><div class="coverage-fill" id="coverage-fill" style="width: 0%"></div></div>
                        <div class="coverage-stats">
                            <div class="coverage-stat">Covered: <span id="coverage-percent">0%</span></div>
                            <div class="coverage-stat">Avg: <span id="avg-cdm2">0</span> cd/mÂ²</div>
                        </div>
                        <div class="coverage-stats" style="margin-top: 4px;">
                            <div class="coverage-stat">Min: <span id="min-cdm2">0</span> cd/mÂ²</div>
                            <div class="coverage-stat">Max: <span id="max-cdm2">0</span> cd/mÂ²</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
        
        <footer class="status-bar">
            <div class="status-left">
                <div class="status-item"><div class="status-dot"></div>Ready</div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg><span id="projector-status">0 Projectors</span></div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg><span id="surface-status">0 Surfaces</span></div>
            </div>
            <div class="status-center" style="color: var(--text-muted); font-size: 10px;">
                <span>Left-drag: Look â€¢ Right-drag: Pan â€¢ Scroll: Zoom â€¢ WASD/QE: Move</span>
            </div>
            <div class="status-right"><div class="status-item"><span id="fps-counter">60 FPS</span></div></div>
        </footer>
    </div>
    
    <!-- Export Modal -->
    <div class="modal-overlay" id="export-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Export Project</span>
                <button class="modal-close" onclick="closeModal('export-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 6px;">Filename</label>
                <input type="text" class="filename-input" id="export-filename" value="projection-config" placeholder="Enter filename">
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 6px; margin-top: 12px;">Format</label>
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button class="btn btn-primary" id="export-format-json" onclick="setExportFormat('json')" style="flex: 1;">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>
                        JSON
                    </button>
                    <button class="btn" id="export-format-csv" onclick="setExportFormat('csv')" style="flex: 1;">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm-1 9h-2v1h2v2H9v-4h4v1zm-4 3v-4H7v4h2zm8 0h-2v-1h-1v-1h1v-1h-1V9h2v4h1v1z"/></svg>
                        CSV
                    </button>
                    <button class="btn" id="export-format-obj" onclick="setExportFormat('obj')" style="flex: 1;">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M21 16.5c0 .38-.21.71-.53.88l-7.9 4.44c-.16.12-.36.18-.57.18-.21 0-.41-.06-.57-.18l-7.9-4.44A.991.991 0 013 16.5v-9c0-.38.21-.71.53-.88l7.9-4.44c.16-.12.36-.18.57-.18.21 0 .41.06.57.18l7.9 4.44c.32.17.53.5.53.88v9z"/></svg>
                        OBJ
                    </button>
                </div>
                
                <div id="json-export-options">
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Include in export:</label>
                
                <div class="export-option" onclick="toggleExportOption('projectors')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Projectors</h4>
                        <p id="export-projector-count">0 projectors with settings</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-projectors">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('surfaces')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Surfaces</h4>
                        <p id="export-surface-count">0 surfaces with settings</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-surfaces">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('settings')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.49.49 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Display Settings</h4>
                        <p>Pattern, heatmap, view options</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-settings">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('textures')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Custom Textures</h4>
                        <p id="export-texture-count">Embed texture images (increases file size)</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="export-check-textures">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                </div>
                
                <div id="csv-export-options" style="display: none;">
                    <div class="import-preview" style="margin-bottom: 0;">
                        <h4>CSV Export (disguise Compatible)</h4>
                        <div class="import-stat">
                            <span>Projectors</span>
                            <span id="csv-export-projector-count">0</span>
                        </div>
                        <div class="import-stat">
                            <span>Format</span>
                            <span>disguise d3/gx</span>
                        </div>
                        <p style="font-size: 11px; color: var(--text-muted); margin-top: 8px;">
                            Exports projector positions, rotations, lens settings, and calculated metrics in disguise-compatible CSV format. Surfaces are not included in CSV export.
                        </p>
                    </div>
                </div>
                
                <div id="obj-export-options" style="display: none;">
                    <div class="import-preview" style="margin-bottom: 0;">
                        <h4>OBJ Export (3D Geometry)</h4>
                        <div class="import-stat">
                            <span>Surfaces</span>
                            <span id="obj-export-surface-count">0</span>
                        </div>
                        <div class="import-stat">
                            <span>Format</span>
                            <span>Wavefront OBJ</span>
                        </div>
                        <p style="font-size: 11px; color: var(--text-muted); margin-top: 8px;">
                            Exports all surfaces as a single OBJ file with UV coordinates. Each surface is exported as a separate named object. Compatible with most 3D software.
                        </p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('export-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doExport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Export
                </button>
            </div>
        </div>
    </div>
    
    <!-- Import Modal -->
    <div class="modal-overlay" id="import-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Import Project</span>
                <button class="modal-close" onclick="closeModal('import-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="import-preview">
                    <h4>File Contents</h4>
                    <div class="import-stat">
                        <span>Version</span>
                        <span id="import-version">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Projectors</span>
                        <span id="import-projectors">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Surfaces</span>
                        <span id="import-surfaces">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Custom Textures</span>
                        <span id="import-textures">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Settings</span>
                        <span id="import-settings">-</span>
                    </div>
                </div>
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Import options:</label>
                
                <div class="export-option" onclick="toggleImportOption('replace')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Replace Current Scene</h4>
                        <p>Clear existing objects before importing</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="import-check-replace">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleImportOption('merge')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Merge with Current</h4>
                        <p>Add imported objects to existing scene</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="import-check-merge">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="import-warning">
                    <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    <p>This will modify your current scene. Make sure to export your work first if you want to keep it.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('import-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doImport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
                    Import
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
        <span id="toast-message">Success!</span>
    </div>
    
    <!-- Password Modal -->
    <div class="modal-overlay password-modal" id="password-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Authentication Required</span>
                <button class="modal-close" onclick="closeModal('password-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 16px;">Enter the project password to export or save.</p>
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 6px;">Password</label>
                <div class="password-input-wrapper">
                    <input type="password" class="password-input" id="export-password" placeholder="Enter password" onkeydown="if(event.key==='Enter')verifyAndProceed()">
                    <button class="password-toggle" onclick="togglePasswordVisibility()" type="button">
                        <svg viewBox="0 0 24 24" id="password-eye"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                </div>
                <p class="password-error" id="password-error">Incorrect password. Please try again.</p>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('password-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="verifyAndProceed()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>
                    Verify
                </button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // OBJLoader for Three.js r128
    THREE.OBJLoader = function(manager) {
        this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        this.materials = null;
    };
    
    THREE.OBJLoader.prototype = {
        constructor: THREE.OBJLoader,
        
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
                onLoad(scope.parse(text));
            }, onProgress, onError);
        },
        
        setPath: function(value) {
            this.path = value;
            return this;
        },
        
        setMaterials: function(materials) {
            this.materials = materials;
            return this;
        },
        
        parse: function(text) {
            var state = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materialLibraries: [],
                startObject: function(name, fromDeclaration) {
                    if (this.object && this.object.fromDeclaration === false) {
                        this.object.name = name;
                        this.object.fromDeclaration = (fromDeclaration !== false);
                        return;
                    }
                    var previousMaterial = (this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined);
                    if (this.object && typeof this.object._finalize === 'function') {
                        this.object._finalize(true);
                    }
                    this.object = {
                        name: name || '',
                        fromDeclaration: (fromDeclaration !== false),
                        geometry: { vertices: [], normals: [], colors: [], uvs: [] },
                        materials: [],
                        smooth: true,
                        startMaterial: function(name, libraries) {
                            var previous = this._finalize(false);
                            if (previous && (previous.inherited || previous.groupCount <= 0)) {
                                this.materials.splice(previous.index, 1);
                            }
                            var material = { index: this.materials.length, name: name || '', mtllib: (Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : ''), smooth: (previous !== undefined ? previous.smooth : this.smooth), groupStart: (previous !== undefined ? previous.groupEnd : 0), groupEnd: -1, groupCount: -1, inherited: false };
                            this.materials.push(material);
                            return material;
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0) return this.materials[this.materials.length - 1];
                            return undefined;
                        },
                        _finalize: function(end) {
                            var lastMultiMaterial = this.currentMaterial();
                            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                                lastMultiMaterial.inherited = false;
                            }
                            if (end && this.materials.length > 1) {
                                for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                                    if (this.materials[mi].groupCount <= 0) {
                                        this.materials.splice(mi, 1);
                                    }
                                }
                            }
                            if (end && this.materials.length === 0) {
                                this.materials.push({ name: '', smooth: this.smooth });
                            }
                            return lastMultiMaterial;
                        }
                    };
                    if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
                        var declared = previousMaterial.clone(0);
                        declared.inherited = true;
                        this.object.materials.push(declared);
                    }
                    this.objects.push(this.object);
                },
                finalize: function() {
                    if (this.object && typeof this.object._finalize === 'function') {
                        this.object._finalize(true);
                    }
                },
                parseVertexIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseNormalIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseUVIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 2) * 2;
                },
                addVertex: function(a, b, c) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                    dst.push(src[b + 0], src[b + 1], src[b + 2]);
                    dst.push(src[c + 0], src[c + 1], src[c + 2]);
                },
                addVertexPoint: function(a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                },
                addVertexLine: function(a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                },
                addNormal: function(a, b, c) {
                    var src = this.normals;
                    var dst = this.object.geometry.normals;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                    dst.push(src[b + 0], src[b + 1], src[b + 2]);
                    dst.push(src[c + 0], src[c + 1], src[c + 2]);
                },
                addUV: function(a, b, c) {
                    var src = this.uvs;
                    var dst = this.object.geometry.uvs;
                    dst.push(src[a + 0], src[a + 1]);
                    dst.push(src[b + 0], src[b + 1]);
                    dst.push(src[c + 0], src[c + 1]);
                },
                addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
                    var vLen = this.vertices.length;
                    var ia = this.parseVertexIndex(a, vLen);
                    var ib = this.parseVertexIndex(b, vLen);
                    var ic = this.parseVertexIndex(c, vLen);
                    this.addVertex(ia, ib, ic);
                    if (na !== undefined && na !== '') {
                        var nLen = this.normals.length;
                        ia = this.parseNormalIndex(na, nLen);
                        ib = this.parseNormalIndex(nb, nLen);
                        ic = this.parseNormalIndex(nc, nLen);
                        this.addNormal(ia, ib, ic);
                    }
                    if (ua !== undefined && ua !== '') {
                        var uvLen = this.uvs.length;
                        ia = this.parseUVIndex(ua, uvLen);
                        ib = this.parseUVIndex(ub, uvLen);
                        ic = this.parseUVIndex(uc, uvLen);
                        this.addUV(ia, ib, ic);
                    }
                }
            };
            
            state.startObject('', false);
            var lines = text.split('\n');
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line.length === 0 || line.charAt(0) === '#') continue;
                var lineFirstChar = line.charAt(0);
                var data = line.split(/\s+/);
                var keyword = data[0];
                
                if (lineFirstChar === 'v') {
                    if (keyword === 'v') {
                        state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                    } else if (keyword === 'vn') {
                        state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                    } else if (keyword === 'vt') {
                        state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                    }
                } else if (lineFirstChar === 'f') {
                    var vertices = [];
                    for (var j = 1; j < data.length; j++) {
                        var vertex = data[j].split('/');
                        vertices.push(vertex);
                    }
                    for (var j = 1; j < vertices.length - 1; j++) {
                        var v1 = vertices[0], v2 = vertices[j], v3 = vertices[j + 1];
                        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                } else if (keyword === 'o' || keyword === 'g') {
                    state.startObject(data[1]);
                } else if (keyword === 'usemtl') {
                    state.object.startMaterial(data[1], state.materialLibraries);
                } else if (keyword === 's') {
                    if (data[1] === 'off' || data[1] === '0') {
                        state.object.smooth = false;
                    } else {
                        state.object.smooth = true;
                    }
                    var material = state.object.currentMaterial();
                    if (material) material.smooth = state.object.smooth;
                }
            }
            
            state.finalize();
            
            var container = new THREE.Group();
            for (var i = 0; i < state.objects.length; i++) {
                var object = state.objects[i];
                var geometry = object.geometry;
                if (geometry.vertices.length === 0) continue;
                
                var buffergeometry = new THREE.BufferGeometry();
                buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));
                if (geometry.normals.length > 0) {
                    buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
                } else {
                    buffergeometry.computeVertexNormals();
                }
                if (geometry.uvs.length > 0) {
                    buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
                }
                
                var material = new THREE.MeshBasicMaterial({ color: 0x888888 });
                var mesh = new THREE.Mesh(buffergeometry, material);
                mesh.name = object.name;
                container.add(mesh);
            }
            
            return container;
        }
    };
    </script>
    <script>
        // ==========================================
        // PROJECTION STUDIO v2.3
        // Fixed coverage, frustum zoom, presets, luminance heatmap
        // ==========================================
        
        const state = {
            projectors: [],
            surfaces: [],
            selectedObject: null,
            selectedType: null,
            currentPattern: 'none',
            displayOptions: { frustums: true, grid: true, coverage: true, overlap: false, distance: false, heatmap: false, wireframe: false },
            currentView: 'perspective',
            heatmapMax: 2000 // cd/mÂ² maximum for heatmap scale
        };
        
        // Undo history system
        const undoHistory = [];
        const MAX_UNDO_HISTORY = 50;
        
        function saveStateForUndo(description = 'Change') {
            // Deep clone current projector and surface transforms
            const snapshot = {
                description,
                timestamp: Date.now(),
                projectors: state.projectors.map(p => ({
                    id: p.id,
                    position: { ...p.position },
                    rotation: { ...p.rotation }
                })),
                surfaces: state.surfaces.map(s => ({
                    id: s.id,
                    position: { ...s.position },
                    rotation: { ...s.rotation },
                    dimensions: { ...s.dimensions },
                    scale: s.scale
                }))
            };
            
            undoHistory.push(snapshot);
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        function undo() {
            if (undoHistory.length === 0) {
                showToast('Nothing to undo', 'error');
                return;
            }
            
            const snapshot = undoHistory.pop();
            
            // Restore projector transforms
            snapshot.projectors.forEach(snapProj => {
                const proj = state.projectors.find(p => p.id === snapProj.id);
                if (proj) {
                    proj.position = { ...snapProj.position };
                    proj.rotation = { ...snapProj.rotation };
                    updateProjectorMesh(proj);
                }
            });
            
            // Restore surface transforms
            snapshot.surfaces.forEach(snapSurf => {
                const surf = state.surfaces.find(s => s.id === snapSurf.id);
                if (surf) {
                    surf.position = { ...snapSurf.position };
                    surf.rotation = { ...snapSurf.rotation };
                    surf.dimensions = { ...snapSurf.dimensions };
                    if (snapSurf.scale !== undefined) surf.scale = snapSurf.scale;
                    updateSurfaceMesh(surf);
                }
            });
            
            // Update UI
            updatePropertiesPanel();
            updateGizmoPosition();
            updateUndoButton();
            showToast(`Undid: ${snapshot.description}`);
        }
        
        function updateUndoButton() {
            const btn = document.getElementById('undo-btn');
            if (btn) {
                btn.disabled = undoHistory.length === 0;
                btn.title = undoHistory.length > 0 
                    ? `Undo: ${undoHistory[undoHistory.length - 1].description} (Ctrl+Z)`
                    : 'Nothing to undo (Ctrl+Z)';
            }
        }
        
        // ==========================================
        // SECURITY MODULE - DO NOT MODIFY
        // ==========================================
        
        // Session validation and integrity check routines
        let _0x7f3a = null; // pending action callback
        const _0x4e2d = [0x42,0x75,0x79,0x4a,0x6f,0x65,0x4c,0x6f,0x65,0x43,0x6f,0x66,0x66,0x65,0x65];
        const _0x9c1b = { v: null, t: Date.now() };
        
        // Integrity verification matrix
        const _0x3f8e = [
            [0x1a, 0x2b, 0x3c], [0x4d, 0x5e, 0x6f], // decoy
            [0x28, 0x33, 0x0d, 0x17], // offset markers
        ];
        
        // Session token generator (obfuscated validation)
        function _0x2a4f(input) {
            const _0x8b7c = _0x4e2d.map((c, i) => c ^ (_0x3f8e[2][i % 4]));
            const _0x6d9e = String.fromCharCode(..._0x4e2d);
            
            // Additional entropy mixing
            const _0x1f5a = input.split('').reduce((a, c, i) => {
                return a + (c.charCodeAt(0) * (i + 1));
            }, 0);
            
            const _0x7e3b = _0x6d9e.split('').reduce((a, c, i) => {
                return a + (c.charCodeAt(0) * (i + 1));
            }, 0);
            
            return _0x1f5a === _0x7e3b && input.length === _0x4e2d.length;
        }
        
        // Async hash verification with timing attack mitigation
        async function _0xa3c7(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            const hash = await crypto.subtle.digest('SHA-256', data);
            const arr = Array.from(new Uint8Array(hash));
            return arr.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        // Multi-layer verification
        async function _0x5b2e(input) {
            // Layer 1: Length and character validation
            if (!input || typeof input !== 'string') return false;
            
            // Layer 2: Quick rejection for obvious mismatches
            const quickCheck = _0x2a4f(input);
            if (!quickCheck) return false;
            
            // Layer 3: Cryptographic verification
            const inputHash = await _0xa3c7(input);
            const _0xd4f1 = await _0xa3c7(String.fromCharCode(..._0x4e2d));
            
            // Constant-time comparison to prevent timing attacks
            let match = inputHash.length === _0xd4f1.length;
            for (let i = 0; i < inputHash.length; i++) {
                match = match && (inputHash[i] === _0xd4f1[i]);
            }
            
            return match;
        }
        
        function requestAuthentication(callback) {
            _0x7f3a = callback;
            document.getElementById('export-password').value = '';
            document.getElementById('password-error').classList.remove('visible');
            document.getElementById('export-password').classList.remove('error');
            document.getElementById('password-modal').classList.add('active');
            setTimeout(() => document.getElementById('export-password').focus(), 100);
        }
        
        async function verifyAndProceed() {
            const input = document.getElementById('export-password').value;
            const isValid = await _0x5b2e(input);
            
            if (isValid) {
                _0x9c1b.v = true;
                _0x9c1b.t = Date.now();
                closeModal('password-modal');
                if (_0x7f3a) {
                    _0x7f3a();
                    _0x7f3a = null;
                }
            } else {
                document.getElementById('export-password').classList.add('error');
                document.getElementById('password-error').classList.add('visible');
                setTimeout(() => {
                    document.getElementById('export-password').classList.remove('error');
                }, 400);
            }
        }
        
        function togglePasswordVisibility() {
            const input = document.getElementById('export-password');
            const eye = document.getElementById('password-eye');
            if (input.type === 'password') {
                input.type = 'text';
                eye.innerHTML = '<path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>';
            } else {
                input.type = 'password';
                eye.innerHTML = '<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>';
            }
        }
        
        // Check if session is still valid (5 minute window)
        function isSessionValid() {
            return _0x9c1b.v === true && (Date.now() - _0x9c1b.t) < 300000;
        }
        
        // ==========================================
        // END SECURITY MODULE
        // ==========================================
        
        let scene, camera, renderer, gridHelper, projectorGroup, surfaceGroup, distanceHelperGroup, raycaster, mouse;
        const projectionTextures = new Map();
        const projectorMatrixData = new Map();
        const customTextureData = new Map();
        const videoTextureData = new Map(); // projector ID -> { video, texture, playing, loop, resolution }
        
        // Pattern scroll animation state
        const patternScrollState = {
            enabled: false,
            speed: 0.5,
            direction: 'horizontal', // 'horizontal', 'vertical', 'diagonal'
            offset: { x: 0, y: 0 }
        };
        
        // Shadow map system for occlusion
        const shadowMaps = new Map(); // projector ID -> { renderTarget, camera }
        const SHADOW_MAP_SIZE = 1024;
        let depthMaterial = null;
        
        // Keyboard state for WASD controls
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false };
        
        // Pilot mode - when true, camera movement controls the projector
        let pilotMode = {
            enabled: false,
            projectorId: null
        };
        
        // ==========================================
        // TRANSFORM GIZMO SYSTEM
        // ==========================================
        
        const gizmoState = {
            mode: 'select', // 'select', 'translate', 'rotate'
            activeAxis: null, // 'x', 'y', 'z', 'xy', 'xz', 'yz'
            isDragging: false,
            startPoint: new THREE.Vector3(),
            startValue: null,
            localSpace: false,
            snap: {
                enabled: false,
                translate: 0.5,
                rotate: 15
            }
        };
        
        let gizmoGroup = null;
        let translateGizmo = null;
        let rotateGizmo = null;
        let dragGuideLine = null;
        let rotationArcLine = null;
        const gizmoRaycaster = new THREE.Raycaster();
        gizmoRaycaster.params.Line.threshold = 0.15;
        
        function createGizmos() {
            gizmoGroup = new THREE.Group();
            gizmoGroup.visible = false;
            gizmoGroup.renderOrder = 999;
            scene.add(gizmoGroup);
            
            createTranslateGizmo();
            createRotateGizmo();
            createDragGuides();
        }
        
        function createDragGuides() {
            // Create drag guide line for translation
            const lineGeom = new THREE.BufferGeometry();
            lineGeom.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            const lineMat = new THREE.LineDashedMaterial({
                color: 0xffff00,
                dashSize: 0.1,
                gapSize: 0.05,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });
            dragGuideLine = new THREE.Line(lineGeom, lineMat);
            dragGuideLine.visible = false;
            dragGuideLine.computeLineDistances();
            dragGuideLine.renderOrder = 998;
            scene.add(dragGuideLine);
            
            // Create rotation arc indicator
            const arcGeom = new THREE.BufferGeometry();
            const arcPoints = [];
            for (let i = 0; i <= 32; i++) {
                arcPoints.push(new THREE.Vector3());
            }
            arcGeom.setFromPoints(arcPoints);
            const arcMat = new THREE.LineBasicMaterial({
                color: 0xffff00,
                depthTest: false,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            rotationArcLine = new THREE.Line(arcGeom, arcMat);
            rotationArcLine.visible = false;
            rotationArcLine.renderOrder = 998;
            scene.add(rotationArcLine);
        }
        
        function updateDragGuide(startPos, endPos, axis) {
            if (!dragGuideLine) return;
            
            const positions = dragGuideLine.geometry.attributes.position;
            positions.setXYZ(0, startPos.x, startPos.y, startPos.z);
            positions.setXYZ(1, endPos.x, endPos.y, endPos.z);
            positions.needsUpdate = true;
            
            // Update color based on axis
            const axisColors = {
                x: 0xff5555, y: 0x55ff55, z: 0x55aaff,
                xy: 0xffff55, xz: 0xff55ff, yz: 0x55ffff
            };
            dragGuideLine.material.color.setHex(axisColors[axis] || 0xffff00);
            
            dragGuideLine.computeLineDistances();
            dragGuideLine.visible = true;
        }
        
        function updateRotationArc(center, axis, startAngle, endAngle, radius) {
            if (!rotationArcLine) return;
            
            const positions = rotationArcLine.geometry.attributes.position;
            const segments = 32;
            const angleRange = endAngle - startAngle;
            
            for (let i = 0; i <= segments; i++) {
                const angle = startAngle + (angleRange * i / segments);
                let x, y, z;
                
                if (axis === 'y') {
                    x = center.x + Math.cos(angle) * radius;
                    y = center.y;
                    z = center.z + Math.sin(angle) * radius;
                } else if (axis === 'x') {
                    x = center.x;
                    y = center.y + Math.cos(angle) * radius;
                    z = center.z + Math.sin(angle) * radius;
                } else { // z
                    x = center.x + Math.cos(angle) * radius;
                    y = center.y + Math.sin(angle) * radius;
                    z = center.z;
                }
                
                positions.setXYZ(i, x, y, z);
            }
            positions.needsUpdate = true;
            
            // Update color based on axis
            const axisColors = { x: 0xff5555, y: 0x55ff55, z: 0x55aaff };
            rotationArcLine.material.color.setHex(axisColors[axis] || 0xffff00);
            rotationArcLine.visible = true;
        }
        
        function hideDragGuides() {
            if (dragGuideLine) dragGuideLine.visible = false;
            if (rotationArcLine) rotationArcLine.visible = false;
        }
        
        function createTranslateGizmo() {
            translateGizmo = new THREE.Group();
            translateGizmo.name = 'translateGizmo';
            
            const axisLength = 1.5;
            const coneHeight = 0.3;
            const coneRadius = 0.1;
            const lineRadius = 0.025;
            
            // More vibrant, distinct colors
            const colors = {
                x: 0xff3333, // Red
                y: 0x33ff33, // Green  
                z: 0x3399ff  // Blue
            };
            
            const hoverColors = {
                x: 0xff6666,
                y: 0x66ff66,
                z: 0x66bbff
            };
            
            // Center sphere for reference
            const centerGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                depthTest: false,
                transparent: true,
                opacity: 0.5
            });
            const centerSphere = new THREE.Mesh(centerGeom, centerMat);
            centerSphere.userData.isCenter = true;
            translateGizmo.add(centerSphere);
            
            // Create axes with cylinder bodies (thicker than lines)
            ['x', 'y', 'z'].forEach(axis => {
                const group = new THREE.Group();
                group.userData.axis = axis;
                group.userData.gizmoType = 'translate';
                
                // Cylinder body (instead of thin line)
                const bodyGeom = new THREE.CylinderGeometry(lineRadius, lineRadius, axisLength - coneHeight * 0.5, 8);
                const bodyMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true,
                    opacity: 0.5
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.userData.axis = axis;
                body.userData.gizmoType = 'translate';
                body.userData.originalColor = colors[axis];
                body.userData.hoverColor = hoverColors[axis];
                body.userData.originalOpacity = 0.5;
                
                // Position body
                const halfLength = (axisLength - coneHeight * 0.5) / 2;
                if (axis === 'x') {
                    body.rotation.z = -Math.PI / 2;
                    body.position.x = halfLength;
                } else if (axis === 'y') {
                    body.position.y = halfLength;
                } else if (axis === 'z') {
                    body.rotation.x = Math.PI / 2;
                    body.position.z = halfLength;
                }
                group.add(body);
                
                // Cone (arrow head) - larger and more visible
                const coneGeom = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                const coneMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true,
                    opacity: 0.6
                });
                const cone = new THREE.Mesh(coneGeom, coneMat);
                cone.userData.axis = axis;
                cone.userData.gizmoType = 'translate';
                cone.userData.originalColor = colors[axis];
                cone.userData.hoverColor = hoverColors[axis];
                cone.userData.originalOpacity = 0.6;
                
                // Position and rotate cone
                if (axis === 'x') {
                    cone.position.x = axisLength - coneHeight / 2;
                    cone.rotation.z = -Math.PI / 2;
                } else if (axis === 'y') {
                    cone.position.y = axisLength - coneHeight / 2;
                } else if (axis === 'z') {
                    cone.position.z = axisLength - coneHeight / 2;
                    cone.rotation.x = Math.PI / 2;
                }
                group.add(cone);
                
                // Invisible cylinder for easier picking (larger hit area)
                const pickGeom = new THREE.CylinderGeometry(0.12, 0.12, axisLength + 0.2, 8);
                const pickMat = new THREE.MeshBasicMaterial({ visible: false });
                const picker = new THREE.Mesh(pickGeom, pickMat);
                picker.userData.axis = axis;
                picker.userData.gizmoType = 'translate';
                picker.userData.isPicker = true;
                
                if (axis === 'x') {
                    picker.rotation.z = -Math.PI / 2;
                    picker.position.x = axisLength / 2;
                } else if (axis === 'y') {
                    picker.position.y = axisLength / 2;
                } else if (axis === 'z') {
                    picker.rotation.x = Math.PI / 2;
                    picker.position.z = axisLength / 2;
                }
                group.add(picker);
                
                translateGizmo.add(group);
            });
            
            // Plane handles for 2-axis movement (improved with border)
            const planeSize = 0.4;
            const planeOffset = 0.55;
            
            [['xy', 'z'], ['xz', 'y'], ['yz', 'x']].forEach(([plane, normal]) => {
                const planeGroup = new THREE.Group();
                planeGroup.userData.axis = plane;
                planeGroup.userData.gizmoType = 'translate';
                
                // Filled plane
                const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
                const planeColor = plane === 'xy' ? 0x3399ff : plane === 'xz' ? 0x33ff33 : 0xff3333;
                const planeMat = new THREE.MeshBasicMaterial({ 
                    color: planeColor,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    depthTest: false
                });
                const planeMesh = new THREE.Mesh(planeGeom, planeMat);
                planeMesh.userData.axis = plane;
                planeMesh.userData.gizmoType = 'translate';
                planeMesh.userData.originalOpacity = 0.15;
                planeMesh.userData.hoverOpacity = 0.45;
                planeMesh.userData.originalColor = planeColor;
                planeGroup.add(planeMesh);
                
                // Border lines for the plane
                const borderGeom = new THREE.BufferGeometry();
                const s = planeSize / 2;
                borderGeom.setFromPoints([
                    new THREE.Vector3(-s, -s, 0),
                    new THREE.Vector3(s, -s, 0),
                    new THREE.Vector3(s, s, 0),
                    new THREE.Vector3(-s, s, 0),
                    new THREE.Vector3(-s, -s, 0)
                ]);
                const borderMat = new THREE.LineBasicMaterial({
                    color: planeColor,
                    depthTest: false,
                    transparent: true,
                    opacity: 0.3
                });
                const border = new THREE.Line(borderGeom, borderMat);
                border.userData.axis = plane;
                border.userData.gizmoType = 'translate';
                border.userData.originalOpacity = 0.3;
                border.userData.originalColor = planeColor;
                planeGroup.add(border);
                
                if (plane === 'xy') {
                    planeGroup.position.set(planeOffset, planeOffset, 0);
                } else if (plane === 'xz') {
                    planeGroup.position.set(planeOffset, 0, planeOffset);
                    planeGroup.rotation.x = Math.PI / 2;
                } else if (plane === 'yz') {
                    planeGroup.position.set(0, planeOffset, planeOffset);
                    planeGroup.rotation.y = Math.PI / 2;
                }
                
                translateGizmo.add(planeGroup);
            });
            
            // Add axis text labels
            const labelOffset = axisLength + 0.35;
            const labelColors = { x: '#ff5555', y: '#55ff55', z: '#55aaff' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const label = createAxisLabel(axis.toUpperCase(), labelColors[axis]);
                label.userData.axis = axis;
                label.userData.gizmoType = 'translate';
                label.userData.isLabel = true;
                
                if (axis === 'x') label.position.set(labelOffset, 0, 0);
                else if (axis === 'y') label.position.set(0, labelOffset, 0);
                else label.position.set(0, 0, labelOffset);
                
                translateGizmo.add(label);
            });
            
            gizmoGroup.add(translateGizmo);
        }
        
        // Helper function to create axis text label sprites
        function createAxisLabel(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Draw circle background
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(17, 17, 20, 0.85)';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw text
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = color;
            ctx.fillText(text, 32, 34);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({
                map: texture,
                depthTest: false,
                transparent: true,
                opacity: 0.5
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.35, 0.35, 1);
            sprite.renderOrder = 1000;
            sprite.userData.originalOpacity = 0.5;
            
            return sprite;
        }
        
        function createRotateGizmo() {
            rotateGizmo = new THREE.Group();
            rotateGizmo.name = 'rotateGizmo';
            rotateGizmo.visible = false;
            
            const ringRadius = 1.3;
            const tubeRadius = 0.035;
            const segments = 64;
            
            // More vibrant colors matching translate gizmo
            const colors = {
                x: 0xff3333,
                y: 0x33ff33,
                z: 0x3399ff
            };
            
            const hoverColors = {
                x: 0xff6666,
                y: 0x66ff66,
                z: 0x66bbff
            };
            
            // Center sphere for reference
            const centerGeom = new THREE.SphereGeometry(0.06, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                depthTest: false,
                transparent: true,
                opacity: 0.4
            });
            const centerSphere = new THREE.Mesh(centerGeom, centerMat);
            centerSphere.userData.isCenter = true;
            rotateGizmo.add(centerSphere);
            
            ['x', 'y', 'z'].forEach(axis => {
                const axisGroup = new THREE.Group();
                axisGroup.userData.axis = axis;
                axisGroup.userData.gizmoType = 'rotate';
                
                // Main torus ring - thicker tube for better visibility
                const torusGeom = new THREE.TorusGeometry(ringRadius, tubeRadius, 12, segments);
                const torusMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true,
                    opacity: 0.5
                });
                const torus = new THREE.Mesh(torusGeom, torusMat);
                torus.userData.axis = axis;
                torus.userData.gizmoType = 'rotate';
                torus.userData.originalColor = colors[axis];
                torus.userData.hoverColor = hoverColors[axis];
                torus.userData.originalOpacity = 0.5;
                
                // Add small spheres at cardinal points for visual reference
                const markerRadius = 0.06;
                const markerPositions = [0, Math.PI/2, Math.PI, Math.PI * 1.5];
                markerPositions.forEach(angle => {
                    const markerGeom = new THREE.SphereGeometry(markerRadius, 8, 8);
                    const markerMat = new THREE.MeshBasicMaterial({
                        color: colors[axis],
                        depthTest: false,
                        transparent: true,
                        opacity: 0.5
                    });
                    const marker = new THREE.Mesh(markerGeom, markerMat);
                    marker.position.x = Math.cos(angle) * ringRadius;
                    marker.position.y = Math.sin(angle) * ringRadius;
                    marker.userData.axis = axis;
                    marker.userData.gizmoType = 'rotate';
                    marker.userData.originalColor = colors[axis];
                    marker.userData.hoverColor = hoverColors[axis];
                    marker.userData.originalOpacity = 0.5;
                    torus.add(marker);
                });
                
                axisGroup.add(torus);
                
                // Invisible torus for easier picking (wider hit area)
                const pickGeom = new THREE.TorusGeometry(ringRadius, 0.1, 8, segments);
                const pickMat = new THREE.MeshBasicMaterial({ visible: false });
                const picker = new THREE.Mesh(pickGeom, pickMat);
                picker.userData.axis = axis;
                picker.userData.gizmoType = 'rotate';
                picker.userData.isPicker = true;
                axisGroup.add(picker);
                
                // Rotate the group to align with the correct axis
                if (axis === 'x') {
                    axisGroup.rotation.y = Math.PI / 2;
                } else if (axis === 'y') {
                    axisGroup.rotation.x = Math.PI / 2;
                }
                // z axis is default orientation
                
                rotateGizmo.add(axisGroup);
            });
            
            // Add axis text labels for rotate gizmo
            const labelOffset = ringRadius + 0.35;
            const labelColors = { x: '#ff5555', y: '#55ff55', z: '#55aaff' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const label = createAxisLabel(axis.toUpperCase(), labelColors[axis]);
                label.userData.axis = axis;
                label.userData.gizmoType = 'rotate';
                label.userData.isLabel = true;
                
                if (axis === 'x') label.position.set(labelOffset, 0, 0);
                else if (axis === 'y') label.position.set(0, labelOffset, 0);
                else label.position.set(0, 0, labelOffset);
                
                rotateGizmo.add(label);
            });
            
            gizmoGroup.add(rotateGizmo);
        }
        
        function updateGizmoPosition() {
            if (!gizmoGroup || !state.selectedObject) {
                if (gizmoGroup) gizmoGroup.visible = false;
                return;
            }
            
            let targetObject = null;
            let objectData = null;
            
            if (state.selectedType === 'projector') {
                targetObject = projectorGroup.children.find(c => c.userData.projectorId === state.selectedObject);
                objectData = state.projectors.find(p => p.id === state.selectedObject);
            } else if (state.selectedType === 'surface') {
                targetObject = surfaceGroup.children.find(c => c.userData.surfaceId === state.selectedObject);
                objectData = state.surfaces.find(s => s.id === state.selectedObject);
            }
            
            if (!targetObject || !objectData) {
                gizmoGroup.visible = false;
                return;
            }
            
            gizmoGroup.visible = gizmoState.mode !== 'select';
            gizmoGroup.position.copy(targetObject.position);
            
            // Apply rotation in local space mode
            if (gizmoState.localSpace) {
                gizmoGroup.rotation.copy(targetObject.rotation);
            } else {
                gizmoGroup.rotation.set(0, 0, 0);
            }
            
            // Scale gizmo based on camera distance
            const dist = camera.position.distanceTo(gizmoGroup.position);
            const scale = dist * 0.15;
            gizmoGroup.scale.setScalar(Math.max(0.5, Math.min(scale, 2)));
            
            // Show appropriate gizmo
            translateGizmo.visible = gizmoState.mode === 'translate';
            rotateGizmo.visible = gizmoState.mode === 'rotate';
        }
        
        function setTransformMode(mode) {
            gizmoState.mode = mode;
            
            // Update transform mode buttons only (not undo or local space)
            const transformBtns = ['tool-select', 'tool-translate', 'tool-rotate'];
            transformBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('active');
                    btn.classList.toggle('disabled', !state.selectedObject);
                }
            });
            
            // Also update local space button disabled state
            const localBtn = document.getElementById('tool-local');
            if (localBtn) {
                localBtn.classList.toggle('disabled', !state.selectedObject);
            }
            
            const activeBtn = document.getElementById(`tool-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            updateGizmoPosition();
        }
        
        function toggleCoordSpace() {
            gizmoState.localSpace = !gizmoState.localSpace;
            const btn = document.getElementById('tool-local');
            btn.classList.toggle('active', gizmoState.localSpace);
            btn.title = gizmoState.localSpace ? 'Local Space (click for World)' : 'World Space (click for Local)';
            updateGizmoPosition();
        }
        
        function updateSnapSettings() {
            gizmoState.snap.enabled = document.getElementById('snap-enabled').checked;
            gizmoState.snap.translate = parseFloat(document.getElementById('snap-translate').value) || 0.5;
            gizmoState.snap.rotate = parseFloat(document.getElementById('snap-rotate').value) || 15;
        }
        
        function enableTransformTools(enabled) {
            const tools = ['tool-select', 'tool-translate', 'tool-rotate', 'tool-local'];
            tools.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.toggle('disabled', !enabled);
                }
            });
            // Undo button uses disabled attribute, not class - don't disable it based on selection
            // It should only be disabled when there's nothing to undo
            updateUndoButton();
        }
        
        function handleGizmoInteraction(event, phase) {
            if (!gizmoGroup || !gizmoGroup.visible || gizmoState.mode === 'select') return false;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            gizmoRaycaster.setFromCamera(mouse, camera);
            
            if (phase === 'down') {
                // Only allow grabbing if we're already hovering over an axis
                // This ensures you can only grab handles you can visually see highlighted
                if (!hoveredAxis) {
                    return false;
                }
                
                const gizmoObjects = [];
                const currentGizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
                currentGizmo.traverse(child => {
                    if (child.isMesh && (child.userData.gizmoType === gizmoState.mode || child.userData.isPicker)) {
                        gizmoObjects.push(child);
                    }
                });
                
                const intersects = gizmoRaycaster.intersectObjects(gizmoObjects);
                
                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    
                    // Only grab if the hit axis matches what we're hovering over
                    if (hit.userData.axis !== hoveredAxis) {
                        return false;
                    }
                    
                    // Clear hover state before starting drag
                    highlightAxis(hoveredAxis, false);
                    hideAxisLabel();
                    
                    gizmoState.activeAxis = hit.userData.axis;
                    gizmoState.isDragging = true;
                    gizmoState.startPoint.copy(intersects[0].point);
                    hoveredAxis = null;
                    
                    // Save state for undo before making changes
                    const actionType = gizmoState.mode === 'translate' ? 'Move' : 'Rotate';
                    const objectName = state.selectedType === 'projector' 
                        ? state.projectors.find(x => x.id === state.selectedObject)?.name 
                        : state.surfaces.find(x => x.id === state.selectedObject)?.name;
                    saveStateForUndo(`${actionType} ${objectName || 'object'}`);
                    
                    // Store starting value
                    if (state.selectedType === 'projector') {
                        const p = state.projectors.find(x => x.id === state.selectedObject);
                        gizmoState.startValue = gizmoState.mode === 'translate' 
                            ? { ...p.position } 
                            : { ...p.rotation };
                    } else if (state.selectedType === 'surface') {
                        const s = state.surfaces.find(x => x.id === state.selectedObject);
                        gizmoState.startValue = gizmoState.mode === 'translate' 
                            ? { ...s.position } 
                            : { ...s.rotation };
                    }
                    
                    // Highlight active axis (not hover, but drag state)
                    highlightAxis(gizmoState.activeAxis, true, false);
                    renderer.domElement.style.cursor = 'grabbing';
                    showGizmoInfo(true);
                    
                    return true;
                }
            } else if (phase === 'move' && gizmoState.isDragging) {
                updateGizmoDrag(event);
                return true;
            } else if (phase === 'up') {
                if (gizmoState.isDragging) {
                    gizmoState.isDragging = false;
                    highlightAxis(gizmoState.activeAxis, false);
                    gizmoState.activeAxis = null;
                    gizmoState.startAngle = null; // Clear rotation start angle
                    renderer.domElement.style.cursor = 'default';
                    showGizmoInfo(false);
                    hideAxisLabel();
                    hideDragGuides();
                    calculateCoverage();
                    return true;
                }
            }
            
            return false;
        }
        
        function updateGizmoDrag(event) {
            if (!gizmoState.isDragging || !gizmoState.activeAxis) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            // Get object being transformed
            let obj, data;
            if (state.selectedType === 'projector') {
                obj = projectorGroup.children.find(c => c.userData.projectorId === state.selectedObject);
                data = state.projectors.find(p => p.id === state.selectedObject);
            } else {
                obj = surfaceGroup.children.find(c => c.userData.surfaceId === state.selectedObject);
                data = state.surfaces.find(s => s.id === state.selectedObject);
            }
            
            if (!obj || !data) return;
            
            if (gizmoState.mode === 'translate') {
                updateTranslation(mouse, obj, data);
            } else if (gizmoState.mode === 'rotate') {
                updateRotation(event, mouse, obj, data);
            }
            
            // Update gizmo position
            updateGizmoPosition();
            
            // Update info display
            updateGizmoInfo(data);
            
            // Update properties panel in real-time
            updatePropertiesPanel();
        }
        
        function updateTranslation(mouse, obj, data) {
            const axis = gizmoState.activeAxis;
            
            // Get the object's world matrix for local space transformations
            const objectQuaternion = obj.quaternion.clone();
            
            // Define axis directions (will be transformed if in local space)
            let axisX = new THREE.Vector3(1, 0, 0);
            let axisY = new THREE.Vector3(0, 1, 0);
            let axisZ = new THREE.Vector3(0, 0, 1);
            
            if (gizmoState.localSpace) {
                axisX.applyQuaternion(objectQuaternion);
                axisY.applyQuaternion(objectQuaternion);
                axisZ.applyQuaternion(objectQuaternion);
            }
            
            // Create a plane for intersection based on camera view and axis
            const planeNormal = new THREE.Vector3();
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            // Get the primary axis direction for this drag
            let primaryAxis;
            if (axis === 'x') primaryAxis = axisX;
            else if (axis === 'y') primaryAxis = axisY;
            else if (axis === 'z') primaryAxis = axisZ;
            
            if (axis === 'x' || axis === 'y' || axis === 'z') {
                // For single-axis movement, create a plane that contains the axis
                // Choose the plane normal to be perpendicular to both the axis and camera direction
                planeNormal.crossVectors(primaryAxis, cameraDir);
                if (planeNormal.lengthSq() < 0.001) {
                    // Axis is parallel to camera, use alternative
                    planeNormal.crossVectors(primaryAxis, camera.up);
                }
                planeNormal.crossVectors(planeNormal, primaryAxis).normalize();
            } else if (axis === 'xy') {
                planeNormal.copy(axisZ);
            } else if (axis === 'xz') {
                planeNormal.copy(axisY);
            } else if (axis === 'yz') {
                planeNormal.copy(axisX);
            }
            
            const plane = new THREE.Plane();
            plane.setFromNormalAndCoplanarPoint(planeNormal, gizmoGroup.position);
            
            const ray = new THREE.Ray();
            gizmoRaycaster.setFromCamera(mouse, camera);
            ray.copy(gizmoRaycaster.ray);
            
            const intersection = new THREE.Vector3();
            ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                let delta = intersection.clone().sub(gizmoState.startPoint);
                
                // Project delta onto the allowed axes
                if (axis === 'x') {
                    const proj = delta.dot(axisX);
                    delta.copy(axisX).multiplyScalar(proj);
                } else if (axis === 'y') {
                    const proj = delta.dot(axisY);
                    delta.copy(axisY).multiplyScalar(proj);
                } else if (axis === 'z') {
                    const proj = delta.dot(axisZ);
                    delta.copy(axisZ).multiplyScalar(proj);
                } else if (axis === 'xy') {
                    // Remove Z component in local space
                    const projZ = delta.dot(axisZ);
                    delta.sub(axisZ.clone().multiplyScalar(projZ));
                } else if (axis === 'xz') {
                    // Remove Y component in local space
                    const projY = delta.dot(axisY);
                    delta.sub(axisY.clone().multiplyScalar(projY));
                } else if (axis === 'yz') {
                    // Remove X component in local space
                    const projX = delta.dot(axisX);
                    delta.sub(axisX.clone().multiplyScalar(projX));
                }
                
                // Apply to position (delta is now in world space)
                let newX = gizmoState.startValue.x + delta.x;
                let newY = gizmoState.startValue.y + delta.y;
                let newZ = gizmoState.startValue.z + delta.z;
                
                // Snap
                if (gizmoState.snap.enabled) {
                    const snap = gizmoState.snap.translate;
                    newX = Math.round(newX / snap) * snap;
                    newY = Math.round(newY / snap) * snap;
                    newZ = Math.round(newZ / snap) * snap;
                }
                
                data.position.x = newX;
                data.position.y = newY;
                data.position.z = newZ;
                
                obj.position.set(newX, newY, newZ);
                
                // Update drag guide line
                const startPos = new THREE.Vector3(gizmoState.startValue.x, gizmoState.startValue.y, gizmoState.startValue.z);
                const endPos = new THREE.Vector3(newX, newY, newZ);
                updateDragGuide(startPos, endPos, axis);
                
                // Update shadow maps when any object moves
                if (state.selectedType === 'projector') {
                    updateProjectorMatrix(data);
                }
                updateAllSurfaceMaterials();
            }
        }
        
        function updateRotation(event, mouse, obj, data) {
            const axis = gizmoState.activeAxis;
            
            // Calculate rotation based on mouse movement around the gizmo center
            const gizmoScreenPos = gizmoGroup.position.clone().project(camera);
            const centerX = (gizmoScreenPos.x + 1) / 2 * renderer.domElement.clientWidth;
            const centerY = (-gizmoScreenPos.y + 1) / 2 * renderer.domElement.clientHeight;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const currentAngle = Math.atan2(
                event.clientY - rect.top - centerY,
                event.clientX - rect.left - centerX
            );
            
            // Store initial angle on first move
            if (!gizmoState.startAngle) {
                gizmoState.startAngle = currentAngle;
            }
            
            let deltaAngle = (currentAngle - gizmoState.startAngle) * (180 / Math.PI);
            
            // Get the actual axis direction (local or world)
            let axisDir = new THREE.Vector3();
            if (axis === 'x') axisDir.set(1, 0, 0);
            else if (axis === 'y') axisDir.set(0, 1, 0);
            else if (axis === 'z') axisDir.set(0, 0, 1);
            
            // Transform axis to world space for camera comparison (in local mode)
            let worldAxisDir = axisDir.clone();
            if (gizmoState.localSpace) {
                worldAxisDir.applyQuaternion(obj.quaternion);
            }
            
            // Invert based on camera orientation for intuitive rotation
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const dotProduct = camDir.dot(worldAxisDir);
            if (dotProduct < 0) deltaAngle = -deltaAngle;
            
            // Snap
            if (gizmoState.snap.enabled) {
                const snap = gizmoState.snap.rotate;
                deltaAngle = Math.round(deltaAngle / snap) * snap;
            }
            
            const deltaRad = THREE.MathUtils.degToRad(deltaAngle);
            
            // Create start quaternion from initial rotation values
            const startQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(
                THREE.MathUtils.degToRad(gizmoState.startValue.x),
                THREE.MathUtils.degToRad(gizmoState.startValue.y),
                THREE.MathUtils.degToRad(gizmoState.startValue.z),
                'YXZ'
            ));
            
            let resultQuat;
            
            if (gizmoState.localSpace) {
                // Local space: post-multiply (result = startQuat * deltaQuat)
                // This applies rotation in the object's local coordinate system
                const deltaQuat = new THREE.Quaternion().setFromAxisAngle(axisDir, deltaRad);
                resultQuat = startQuat.clone().multiply(deltaQuat);
            } else {
                // World space: pre-multiply (result = deltaQuat * startQuat)
                // This applies rotation in the world coordinate system
                const deltaQuat = new THREE.Quaternion().setFromAxisAngle(axisDir, deltaRad);
                resultQuat = deltaQuat.clone().multiply(startQuat);
            }
            
            // Convert back to Euler angles
            const resultEuler = new THREE.Euler().setFromQuaternion(resultQuat, 'YXZ');
            
            data.rotation.x = THREE.MathUtils.radToDeg(resultEuler.x);
            data.rotation.y = THREE.MathUtils.radToDeg(resultEuler.y);
            data.rotation.z = THREE.MathUtils.radToDeg(resultEuler.z);
            
            // Set rotation with consistent YXZ order to avoid gimbal lock
            obj.rotation.order = 'YXZ';
            obj.rotation.set(
                THREE.MathUtils.degToRad(data.rotation.x),
                THREE.MathUtils.degToRad(data.rotation.y),
                THREE.MathUtils.degToRad(data.rotation.z)
            );
            
            // Update shadow maps when any object rotates
            if (state.selectedType === 'projector') {
                updateProjectorMatrix(data);
            }
            updateAllSurfaceMaterials();
        }
        
        function highlightAxis(axis, highlight, isHover = false) {
            const gizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
            const highlightColor = 0xffff00; // Yellow for active drag
            
            gizmo.traverse(child => {
                if (child.userData.axis === axis && !child.userData.isPicker && !child.userData.isCenter) {
                    // Handle labels (sprites) - only change opacity, no scale
                    if (child.userData.isLabel && child.material) {
                        child.material.opacity = highlight ? 1.0 : (child.userData.originalOpacity || 0.5);
                        return;
                    }
                    
                    if (highlight) {
                        // Store original values if not already stored
                        if (child.userData.originalColor === undefined && child.material) {
                            child.userData.originalColor = child.material.color.getHex();
                        }
                        if (child.userData.originalOpacity === undefined && child.material && child.material.opacity !== undefined) {
                            child.userData.originalOpacity = child.material.opacity;
                        }
                        
                        // Apply highlight - brightness only, no scale
                        if (child.material) {
                            if (isHover && child.userData.hoverColor) {
                                // Hover: use brighter version of axis color
                                child.material.color.setHex(child.userData.hoverColor);
                            } else {
                                // Active drag: yellow highlight
                                child.material.color.setHex(highlightColor);
                            }
                            
                            // Use hoverOpacity if defined (for planes), otherwise full opacity
                            if (isHover && child.userData.hoverOpacity !== undefined) {
                                child.material.opacity = child.userData.hoverOpacity;
                            } else {
                                child.material.opacity = 1.0;
                            }
                        }
                    } else {
                        // Restore original values
                        if (child.material && child.userData.originalColor !== undefined) {
                            child.material.color.setHex(child.userData.originalColor);
                        }
                        if (child.material && child.userData.originalOpacity !== undefined) {
                            child.material.opacity = child.userData.originalOpacity;
                        }
                    }
                }
            });
            
            // Update cursor
            if (highlight) {
                renderer.domElement.style.cursor = 'grab';
            }
        }
        
        // Track currently hovered axis for hover effects
        let hoveredAxis = null;
        
        function updateGizmoHover(mouse) {
            if (!gizmoGroup || !gizmoGroup.visible || gizmoState.isDragging) return;
            
            gizmoRaycaster.setFromCamera(mouse, camera);
            
            const gizmoObjects = [];
            const currentGizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
            currentGizmo.traverse(child => {
                if (child.isMesh && (child.userData.gizmoType === gizmoState.mode || child.userData.isPicker)) {
                    gizmoObjects.push(child);
                }
            });
            
            const intersects = gizmoRaycaster.intersectObjects(gizmoObjects);
            
            let newHoveredAxis = null;
            if (intersects.length > 0) {
                newHoveredAxis = intersects[0].object.userData.axis;
            }
            
            // Update hover state if changed
            if (newHoveredAxis !== hoveredAxis) {
                // Remove old hover
                if (hoveredAxis) {
                    highlightAxis(hoveredAxis, false);
                }
                
                // Apply new hover
                if (newHoveredAxis) {
                    highlightAxis(newHoveredAxis, true, true);
                    renderer.domElement.style.cursor = 'grab';
                    showAxisLabel(newHoveredAxis);
                } else {
                    renderer.domElement.style.cursor = 'default';
                    hideAxisLabel();
                }
                
                hoveredAxis = newHoveredAxis;
            }
        }
        
        function showAxisLabel(axis) {
            let label = document.getElementById('gizmo-axis-label');
            if (!label) {
                label = document.createElement('div');
                label.id = 'gizmo-axis-label';
                label.style.cssText = `
                    position: absolute;
                    padding: 4px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: 600;
                    pointer-events: none;
                    z-index: 1000;
                    transition: opacity 0.15s ease;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                `;
                document.querySelector('.viewport').appendChild(label);
            }
            
            // Set label text and color based on axis
            const axisNames = {
                'x': 'X Axis',
                'y': 'Y Axis', 
                'z': 'Z Axis',
                'xy': 'XY Plane',
                'xz': 'XZ Plane',
                'yz': 'YZ Plane'
            };
            
            const axisColors = {
                'x': { bg: '#ff3333', text: '#fff' },
                'y': { bg: '#33ff33', text: '#000' },
                'z': { bg: '#3399ff', text: '#fff' },
                'xy': { bg: '#3399ff', text: '#fff' },
                'xz': { bg: '#33ff33', text: '#000' },
                'yz': { bg: '#ff3333', text: '#fff' }
            };
            
            const colors = axisColors[axis] || { bg: '#666', text: '#fff' };
            label.textContent = axisNames[axis] || axis.toUpperCase();
            label.style.backgroundColor = colors.bg;
            label.style.color = colors.text;
            label.style.opacity = '1';
            
            // Position near the gizmo
            const gizmoScreenPos = gizmoGroup.position.clone().project(camera);
            const container = document.querySelector('.viewport');
            const rect = container.getBoundingClientRect();
            const x = (gizmoScreenPos.x * 0.5 + 0.5) * rect.width + 30;
            const y = (-gizmoScreenPos.y * 0.5 + 0.5) * rect.height - 20;
            
            label.style.left = x + 'px';
            label.style.top = y + 'px';
        }
        
        function hideAxisLabel() {
            const label = document.getElementById('gizmo-axis-label');
            if (label) {
                label.style.opacity = '0';
            }
        }
        
        function showGizmoInfo(visible) {
            const info = document.getElementById('gizmo-info');
            info.classList.toggle('visible', visible);
            
            if (visible) {
                document.getElementById('gizmo-info-title').textContent = 
                    gizmoState.mode === 'translate' ? 'Position' : 'Rotation';
                
                // Highlight active axis
                ['x', 'y', 'z'].forEach(axis => {
                    const el = document.getElementById(`gizmo-axis-${axis}`);
                    if (el) {
                        const isActive = gizmoState.activeAxis && 
                            (gizmoState.activeAxis === axis || gizmoState.activeAxis.includes(axis));
                        el.classList.toggle('active', isActive);
                    }
                });
            }
        }
        
        function updateGizmoInfo(data) {
            if (gizmoState.mode === 'translate') {
                document.getElementById('gizmo-x').textContent = data.position.x.toFixed(2);
                document.getElementById('gizmo-y').textContent = data.position.y.toFixed(2);
                document.getElementById('gizmo-z').textContent = data.position.z.toFixed(2);
                
                // Calculate and display delta
                if (gizmoState.startValue) {
                    const dx = data.position.x - gizmoState.startValue.x;
                    const dy = data.position.y - gizmoState.startValue.y;
                    const dz = data.position.z - gizmoState.startValue.z;
                    const delta = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    document.getElementById('gizmo-delta-value').textContent = 
                        (delta >= 0 ? '+' : '') + delta.toFixed(2) + 'm';
                }
            } else {
                document.getElementById('gizmo-x').textContent = data.rotation.x.toFixed(1) + 'Â°';
                document.getElementById('gizmo-y').textContent = data.rotation.y.toFixed(1) + 'Â°';
                document.getElementById('gizmo-z').textContent = data.rotation.z.toFixed(1) + 'Â°';
                
                // Calculate and display delta for rotation
                if (gizmoState.startValue) {
                    const dx = data.rotation.x - gizmoState.startValue.x;
                    const dy = data.rotation.y - gizmoState.startValue.y;
                    const dz = data.rotation.z - gizmoState.startValue.z;
                    const maxDelta = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));
                    document.getElementById('gizmo-delta-value').textContent = 
                        (maxDelta >= 0 ? '+' : '') + maxDelta.toFixed(1) + 'Â°';
                }
            }
            
            // Update active axis highlighting during drag
            ['x', 'y', 'z'].forEach(axis => {
                const el = document.getElementById(`gizmo-axis-${axis}`);
                if (el) {
                    const isActive = gizmoState.activeAxis && 
                        (gizmoState.activeAxis === axis || gizmoState.activeAxis.includes(axis));
                    el.classList.toggle('active', isActive);
                }
            });
        }
        
        // ==========================================
        // END TRANSFORM GIZMO SYSTEM
        // ==========================================
        
        // Projector presets with real-world specifications
        const projectorPresets = {
            'custom': { name: 'Custom', lumens: 10000, throwRatio: 1.5, aspectRatio: 16/9, resolution: '1920Ã—1080' },
            'barco-udx-4k40': { name: 'Barco UDX-4K40', lumens: 40000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840Ã—2160' },
            'barco-udx-4k26': { name: 'Barco UDX-4K26', lumens: 26000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840Ã—2160' },
            'christie-griffyn-4k35': { name: 'Christie Griffyn 4K35', lumens: 36500, throwRatio: 1.38, aspectRatio: 16/9, resolution: '4096Ã—2160' },
            'christie-d4k40': { name: 'Christie D4K40-RGB', lumens: 45000, throwRatio: 1.8, aspectRatio: 1.9, resolution: '4096Ã—2160' },
            'panasonic-pt-rq35k': { name: 'Panasonic PT-RQ35K', lumens: 30500, throwRatio: 1.7, aspectRatio: 16/9, resolution: '5120Ã—3200' },
            'panasonic-pt-rz120': { name: 'Panasonic PT-RZ120', lumens: 12000, throwRatio: 1.7, aspectRatio: 16/10, resolution: '1920Ã—1200' },
            'epson-pro-l30000': { name: 'Epson Pro L30000U', lumens: 30000, throwRatio: 1.57, aspectRatio: 16/10, resolution: '1920Ã—1200' },
            'sony-vpl-gtz380': { name: 'Sony VPL-GTZ380', lumens: 10000, throwRatio: 1.4, aspectRatio: 17/9, resolution: '4096Ã—2160' },
            'digital-projection-titan': { name: 'DP TITAN Laser 37000', lumens: 37000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840Ã—2160' }
        };
        
        // ==========================================
        // SHADERS - With luminance calculation
        // ==========================================
        
        const projectionVertexShader = `
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            void main() {
                vWorldPosition = modelMatrix * vec4(position, 1.0);
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // Fragment shader with shadow mapping for occlusion
        const projectionFragmentShader = `
            // Projector textures (supports up to 8 projectors)
            uniform sampler2D projTex0, projTex1, projTex2, projTex3;
            uniform sampler2D projTex4, projTex5, projTex6, projTex7;
            uniform sampler2D shadowMap0, shadowMap1, shadowMap2, shadowMap3;
            uniform sampler2D shadowMap4, shadowMap5, shadowMap6, shadowMap7;
            
            // Projector matrices
            uniform mat4 projMat0, projMat1, projMat2, projMat3;
            uniform mat4 projMat4, projMat5, projMat6, projMat7;
            // Shadow camera matrices (may differ from projMat for fisheye)
            uniform mat4 shadowMat0, shadowMat1, shadowMat2, shadowMat3;
            uniform mat4 shadowMat4, shadowMat5, shadowMat6, shadowMat7;
            
            // Projector positions
            uniform vec3 projPos0, projPos1, projPos2, projPos3;
            uniform vec3 projPos4, projPos5, projPos6, projPos7;
            
            // Projector rotation matrices (inverse) for fisheye calculation
            uniform mat3 projRotInv0, projRotInv1, projRotInv2, projRotInv3;
            uniform mat3 projRotInv4, projRotInv5, projRotInv6, projRotInv7;
            
            // Projector properties
            uniform float projLumens0, projLumens1, projLumens2, projLumens3;
            uniform float projLumens4, projLumens5, projLumens6, projLumens7;
            uniform float projThrow0, projThrow1, projThrow2, projThrow3;
            uniform float projThrow4, projThrow5, projThrow6, projThrow7;
            uniform float projNear0, projNear1, projNear2, projNear3;
            uniform float projNear4, projNear5, projNear6, projNear7;
            uniform float projFar0, projFar1, projFar2, projFar3;
            uniform float projFar4, projFar5, projFar6, projFar7;
            uniform vec2 texOffset0, texOffset1, texOffset2, texOffset3;
            uniform vec2 texOffset4, texOffset5, texOffset6, texOffset7;
            
            // Lens uniforms: x=type, y=k1, z=k2, w=k3
            uniform vec4 lensParams0, lensParams1, lensParams2, lensParams3;
            uniform vec4 lensParams4, lensParams5, lensParams6, lensParams7;
            // Lens uniforms: x=p1, y=p2, z=cx, w=cy
            uniform vec4 lensParams2_0, lensParams2_1, lensParams2_2, lensParams2_3;
            uniform vec4 lensParams2_4, lensParams2_5, lensParams2_6, lensParams2_7;
            
            // Fisheye FOV in degrees (half-angle, so 90 = 180Â° total FOV)
            uniform float fisheyeFov0, fisheyeFov1, fisheyeFov2, fisheyeFov3;
            uniform float fisheyeFov4, fisheyeFov5, fisheyeFov6, fisheyeFov7;
            
            uniform int numProjectors;
            uniform bool showCoverage;
            uniform bool showOverlap;
            uniform bool showHeatmap;
            uniform bool debugLensType;  // Debug: show lens type as color
            uniform float surfaceGain;
            uniform vec3 baseColor;
            uniform float heatmapMax;
            
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            #define LENS_RECTILINEAR 0
            #define LENS_FISHEYE_EQUIDISTANT 1
            #define LENS_FISHEYE_EQUISOLID 2
            #define LENS_FISHEYE_STEREOGRAPHIC 3
            #define LENS_FISHEYE_ORTHOGRAPHIC 4
            
            // Apply lens distortion (Brown-Conrady model)
            vec2 applyDistortion(vec2 uv, float k1, float k2, float k3, float p1, float p2, float cx, float cy) {
                // Center UV around principal point
                vec2 centered = uv - vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                float r2 = dot(centered, centered);
                float r4 = r2 * r2;
                float r6 = r4 * r2;
                
                // Radial distortion
                float radialFactor = 1.0 + k1 * r2 + k2 * r4 + k3 * r6;
                
                // Tangential distortion
                vec2 tangential = vec2(
                    2.0 * p1 * centered.x * centered.y + p2 * (r2 + 2.0 * centered.x * centered.x),
                    p1 * (r2 + 2.0 * centered.y * centered.y) + 2.0 * p2 * centered.x * centered.y
                );
                
                vec2 distorted = centered * radialFactor + tangential;
                return distorted + vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
            }
            
            // Calculate fisheye UV from 3D direction in projector-local space
            // localDir: normalized direction from projector to surface point in projector's coordinate system
            // In projector-local space, +Z is the forward/optical axis direction
            vec2 calculateFisheyeUV(vec3 localDir, int lensType, float cx, float cy) {
                // Calculate angle from optical axis (+Z in local space)
                // theta is the angle between the direction and the forward axis
                float cosTheta = localDir.z;  // dot(localDir, vec3(0,0,1))
                float theta = acos(clamp(cosTheta, -1.0, 1.0));
                
                // Calculate the direction in the XY plane (perpendicular to optical axis)
                vec2 xyDir = localDir.xy;
                float xyLen = length(xyDir);
                
                // Handle case when looking straight down the optical axis
                if (xyLen < 0.0001) {
                    return vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                }
                
                // Normalize the XY direction
                vec2 xyNorm = xyDir / xyLen;
                
                // Calculate fisheye radius based on projection type
                // All formulas: r = f(Î¸), normalized so that Î¸=90Â° (Ï€/2) gives r=1
                float halfPi = 1.5707963;
                float radius;
                
                if (lensType == LENS_FISHEYE_EQUIDISTANT) {
                    // r = Î¸, linear mapping (most common for planetarium)
                    radius = theta / halfPi;
                } else if (lensType == LENS_FISHEYE_EQUISOLID) {
                    // r = 2Â·sin(Î¸/2), preserves solid angle (area)
                    // At Î¸=90Â°: r = 2Â·sin(45Â°) = 2Â·0.707 = 1.414
                    radius = 2.0 * sin(theta * 0.5) / 1.4142;
                } else if (lensType == LENS_FISHEYE_STEREOGRAPHIC) {
                    // r = 2Â·tan(Î¸/2), preserves angles (conformal)
                    // At Î¸=90Â°: r = 2Â·tan(45Â°) = 2Â·1 = 2
                    radius = tan(theta * 0.5);
                } else if (lensType == LENS_FISHEYE_ORTHOGRAPHIC) {
                    // r = sin(Î¸), hemispheric projection
                    // At Î¸=90Â°: r = sin(90Â°) = 1
                    radius = sin(theta);
                } else {
                    // Rectilinear fallback: r = tan(Î¸)
                    radius = tan(theta);
                }
                
                // Clamp radius to valid range (0 to 1 for 180Â° FOV)
                radius = clamp(radius, 0.0, 1.5);
                
                // Convert to UV coordinates
                // Radius of 1 should map to edge of circular image (0.5 in UV space from center)
                vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                vec2 uv = principalPoint + xyNorm * radius * 0.5;
                
                return uv;
            }
            
            // Unpack linear depth from RGBA
            float unpackLinearDepth(vec4 rgbaDepth) {
                const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
                return dot(rgbaDepth, bitShift);
            }
            
            // Linear heatmap color function with white for overflow
            vec3 heatmapColor(float t) {
                if (t > 1.0) {
                    float overflow = min((t - 1.0) * 2.0, 1.0);
                    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), overflow);
                }
                
                t = clamp(t, 0.0, 1.0);
                
                if (t < 0.167) {
                    return mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.27, 0.67), t / 0.167);
                } else if (t < 0.333) {
                    return mix(vec3(0.0, 0.27, 0.67), vec3(0.0, 0.67, 0.27), (t - 0.167) / 0.167);
                } else if (t < 0.5) {
                    return mix(vec3(0.0, 0.67, 0.27), vec3(0.67, 0.67, 0.0), (t - 0.333) / 0.167);
                } else if (t < 0.667) {
                    return mix(vec3(0.67, 0.67, 0.0), vec3(1.0, 0.67, 0.0), (t - 0.5) / 0.167);
                } else if (t < 0.833) {
                    return mix(vec3(1.0, 0.67, 0.0), vec3(1.0, 0.4, 0.0), (t - 0.667) / 0.167);
                } else {
                    return mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.833) / 0.167);
                }
            }
            
            // Sample projector with physically accurate occlusion and lens distortion
            // - Back-face rejection: surfaces facing away from projector receive no light
            // - Shadow occlusion: surfaces behind other geometry receive no light  
            // - Lens distortion: applies radial/tangential distortion and fisheye projection
            vec4 sampleProjectorWithLens(mat4 projMat, mat4 shadowMat, sampler2D projTex, sampler2D shadowMap, vec3 projPos, mat3 projRotInv, float lumens, float throwRatio, float nearPlane, float farPlane, vec2 texOffset, vec4 lensParams, vec4 lensParams2, float fisheyeFov) {
                // Extract lens parameters
                int lensType = int(lensParams.x + 0.5); // Round to int
                float k1 = lensParams.y;
                float k2 = lensParams.z;
                float k3 = lensParams.w;
                float p1 = lensParams2.x;
                float p2 = lensParams2.y;
                float cx = lensParams2.z;
                float cy = lensParams2.w;
                
                // Calculate distance and direction to surface point
                vec3 worldDir = vWorldPosition.xyz - projPos;
                float dist = length(worldDir);
                vec3 worldDirNorm = worldDir / dist;
                
                // Check distance bounds
                if (dist < nearPlane || dist > farPlane) {
                    if (debugLensType) return vec4(0.1, 0.0, 0.0, 0.01); // Dark red = distance reject
                    return vec4(0.0);
                }
                
                // Back-face rejection - surface must face the projector
                vec3 toProj = -worldDirNorm;
                float facing = dot(vWorldNormal, toProj);
                if (facing <= 0.0) {
                    if (debugLensType) return vec4(0.1, 0.1, 0.0, 0.01); // Dark yellow = backface reject
                    return vec4(0.0);
                }
                
                // Calculate UV based on lens type
                vec2 lensUV;
                vec2 shadowUV;
                
                // === RECTILINEAR LENS (type 0) ===
                if (lensType == LENS_RECTILINEAR) {
                    // Use perspective projection matrix
                    vec4 projCoord = projMat * vWorldPosition;
                    if (projCoord.w <= 0.0) {
                        if (debugLensType) return vec4(0.1, 0.0, 0.1, 0.01); // Dark magenta = behind camera
                        return vec4(0.0);
                    }
                    
                    vec3 ndc = projCoord.xyz / projCoord.w;
                    lensUV = ndc.xy * 0.5 + 0.5;
                    
                    // RECTANGULAR bounds check for rectilinear
                    if (lensUV.x < 0.0 || lensUV.x > 1.0 || lensUV.y < 0.0 || lensUV.y > 1.0) {
                        if (debugLensType) return vec4(0.0, 0.1, 0.0, 0.01); // Dark green = UV bounds reject
                        return vec4(0.0);
                    }
                    if (ndc.z < -1.0 || ndc.z > 1.0) {
                        if (debugLensType) return vec4(0.0, 0.1, 0.1, 0.01); // Dark cyan = NDC Z reject
                        return vec4(0.0);
                    }
                    
                    // Shadow UV is same as lens UV for rectilinear (same projection)
                    shadowUV = lensUV;
                }
                // === FISHEYE LENSES (types 1-4) ===
                else {
                    // Transform direction to projector-local space
                    vec3 localDir = projRotInv * worldDirNorm;
                    
                    // Check if point is behind the projector (localDir.z should be positive for forward)
                    if (localDir.z <= 0.0) {
                        if (debugLensType) return vec4(0.1, 0.0, 0.1, 0.01); // Dark magenta = behind projector
                        return vec4(0.0);
                    }
                    
                    // Calculate fisheye UV from 3D angle
                    lensUV = calculateFisheyeUV(localDir, lensType, cx, cy);
                    
                    // CIRCULAR bounds check for fisheye based on FOV
                    // calculateFisheyeUV maps: 90Â° from axis -> radius 1.0 -> UV distance 0.5 from center
                    // So for 180Â° FOV (Â±90Â°), maxRadius in UV space = 0.5
                    vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                    float distFromCenter = length(lensUV - principalPoint);
                    float maxRadius = fisheyeFov / 360.0;
                    
                    if (distFromCenter > maxRadius) {
                        if (debugLensType) return vec4(0.0, 0.0, 0.1, 0.01); // Dark blue = FOV bounds reject
                        return vec4(0.0);
                    }
                    
                    // Calculate shadow UV from shadow camera matrix (has wider FOV for fisheye)
                    vec4 shadowCoord = shadowMat * vWorldPosition;
                    if (shadowCoord.w > 0.0) {
                        vec3 shadowNdc = shadowCoord.xyz / shadowCoord.w;
                        shadowUV = shadowNdc.xy * 0.5 + 0.5;
                    } else {
                        shadowUV = vec2(-1.0); // Outside shadow frustum
                    }
                }
                
                // Apply lens distortion (Brown-Conrady model) if any coefficients are non-zero
                if (abs(k1) > 0.0001 || abs(k2) > 0.0001 || abs(k3) > 0.0001 || abs(p1) > 0.0001 || abs(p2) > 0.0001) {
                    lensUV = applyDistortion(lensUV, k1, k2, k3, p1, p2, cx, cy);
                }
                
                // Shadow occlusion check
                // CRITICAL: Shadow map stores VIEW-SPACE Z depth (along optical axis), not 3D Euclidean distance
                // We must use the shadow camera's view-space depth for comparison
                bool inShadow = false;
                if (shadowUV.x >= 0.0 && shadowUV.x <= 1.0 && shadowUV.y >= 0.0 && shadowUV.y <= 1.0) {
                    // Get the view-space depth from the shadow projection
                    // shadowCoord.w contains the view-space Z (for perspective cameras)
                    // For rectilinear, we calculated projCoord earlier; for fisheye, we have shadowCoord
                    vec4 shadowProjCoord = shadowMat * vWorldPosition;
                    float viewSpaceZ = shadowProjCoord.w; // Distance along shadow camera's optical axis
                    
                    // Normalize to 0-1 range using near/far planes
                    float fragDepthNormalized = (viewSpaceZ - nearPlane) / (farPlane - nearPlane);
                    
                    vec4 shadowSample = texture2D(shadowMap, shadowUV);
                    float shadowDepth = unpackLinearDepth(shadowSample);
                    
                    // Bias to prevent shadow acne
                    float distanceBias = 0.001 + (viewSpaceZ * 0.0005);
                    float angleBias = 0.002 * (1.0 - facing);
                    float bias = distanceBias + angleBias;
                    
                    if (fragDepthNormalized > shadowDepth + bias) {
                        inShadow = true;
                    }
                }
                
                if (inShadow) {
                    if (debugLensType) return vec4(0.2, 0.0, 0.2, 0.01); // Purple = shadow reject
                    return vec4(0.0);
                }
                
                // Debug mode: show lens type as bright color
                if (debugLensType) {
                    if (lensType == LENS_RECTILINEAR) {
                        return vec4(0.0, 1.0, 0.0, 1.0); // Bright green = rectilinear
                    } else {
                        return vec4(0.0, 0.5, 1.0, 1.0); // Bright blue = fisheye
                    }
                }
                
                // Calculate illumination
                float projWidth = dist / throwRatio;
                float projHeight = projWidth / (16.0/9.0);
                float projArea = projWidth * projHeight;
                
                float lux = lumens / projArea;
                float cdm2 = (lux * surfaceGain / 3.14159) * facing;
                
                // Edge falloff for soft blending
                float edgeFalloff;
                if (lensType == LENS_RECTILINEAR) {
                    // Rectangular falloff for rectilinear
                    float edgeDist = max(abs(lensUV.x - 0.5), abs(lensUV.y - 0.5)) * 2.0;
                    edgeFalloff = 1.0 - smoothstep(0.85, 1.0, edgeDist);
                } else {
                    // Circular falloff for fisheye
                    vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                    float maxRadius = fisheyeFov / 360.0;
                    float radialDist = length(lensUV - principalPoint) / maxRadius;
                    edgeFalloff = 1.0 - smoothstep(0.85, 1.0, radialDist);
                }
                cdm2 *= edgeFalloff;
                
                // Sample texture
                vec2 scrolledUV = fract(lensUV + texOffset);
                vec4 texColor = texture2D(projTex, scrolledUV);
                float displayIntensity = cdm2 / 1500.0;
                
                return vec4(texColor.rgb * displayIntensity * facing, cdm2);
            }
            
            void main() {
                vec3 color = baseColor * 0.02;
                float totalCdm2 = 0.0;
                int hitCount = 0;
                
                if (numProjectors > 0) {
                    vec4 result = sampleProjectorWithLens(projMat0, shadowMat0, projTex0, shadowMap0, projPos0, projRotInv0, projLumens0, projThrow0, projNear0, projFar0, texOffset0, lensParams0, lensParams2_0, fisheyeFov0);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 1) {
                    vec4 result = sampleProjectorWithLens(projMat1, shadowMat1, projTex1, shadowMap1, projPos1, projRotInv1, projLumens1, projThrow1, projNear1, projFar1, texOffset1, lensParams1, lensParams2_1, fisheyeFov1);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 2) {
                    vec4 result = sampleProjectorWithLens(projMat2, shadowMat2, projTex2, shadowMap2, projPos2, projRotInv2, projLumens2, projThrow2, projNear2, projFar2, texOffset2, lensParams2, lensParams2_2, fisheyeFov2);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 3) {
                    vec4 result = sampleProjectorWithLens(projMat3, shadowMat3, projTex3, shadowMap3, projPos3, projRotInv3, projLumens3, projThrow3, projNear3, projFar3, texOffset3, lensParams3, lensParams2_3, fisheyeFov3);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 4) {
                    vec4 result = sampleProjectorWithLens(projMat4, shadowMat4, projTex4, shadowMap4, projPos4, projRotInv4, projLumens4, projThrow4, projNear4, projFar4, texOffset4, lensParams4, lensParams2_4, fisheyeFov4);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 5) {
                    vec4 result = sampleProjectorWithLens(projMat5, shadowMat5, projTex5, shadowMap5, projPos5, projRotInv5, projLumens5, projThrow5, projNear5, projFar5, texOffset5, lensParams5, lensParams2_5, fisheyeFov5);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 6) {
                    vec4 result = sampleProjectorWithLens(projMat6, shadowMat6, projTex6, shadowMap6, projPos6, projRotInv6, projLumens6, projThrow6, projNear6, projFar6, texOffset6, lensParams6, lensParams2_6, fisheyeFov6);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 7) {
                    vec4 result = sampleProjectorWithLens(projMat7, shadowMat7, projTex7, shadowMap7, projPos7, projRotInv7, projLumens7, projThrow7, projNear7, projFar7, texOffset7, lensParams7, lensParams2_7, fisheyeFov7);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                
                if (showHeatmap) {
                    if (hitCount == 0) {
                        color = vec3(0.0, 0.0, 0.1);
                    } else {
                        float normalizedLuminance = totalCdm2 / heatmapMax;
                        color = heatmapColor(normalizedLuminance);
                    }
                } else {
                    if (showCoverage && hitCount == 0) {
                        color = vec3(0.25, 0.02, 0.02);
                    }
                    
                    if (showOverlap && hitCount > 1) {
                        float overlapIntensity = float(hitCount - 1) / 3.0;
                        color = mix(color, vec3(1.0, 0.5, 0.0), min(overlapIntensity, 0.7));
                    }
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // ==========================================
        // INITIALIZATION
        // ==========================================
        
        function init() {
            initThreeJS();
            initControls();
            initKeyboardControls();
            animate();
            updateStatus();
        }
        
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0c);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, -18);
            camera.rotation.order = 'YXZ';
            camera.rotation.set(0, Math.PI, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            
            gridHelper = new THREE.GridHelper(50, 50, 0x2a2a32, 0x1a1a20);
            scene.add(gridHelper);
            
            projectorGroup = new THREE.Group();
            surfaceGroup = new THREE.Group();
            distanceHelperGroup = new THREE.Group();
            scene.add(projectorGroup);
            scene.add(surfaceGroup);
            scene.add(distanceHelperGroup);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Custom linear depth material for better precision at distance
            // Standard depth buffers have poor precision at large distances
            const linearDepthVertexShader = `
                varying float vLinearDepth;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vLinearDepth = -mvPosition.z; // Linear view-space depth
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            const linearDepthFragmentShader = `
                varying float vLinearDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                
                // Pack float to RGBA for precision
                vec4 packDepth(float depth) {
                    float normalized = (depth - cameraNear) / (cameraFar - cameraNear);
                    normalized = clamp(normalized, 0.0, 1.0);
                    
                    const vec4 bitShift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
                    const vec4 bitMask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
                    vec4 res = fract(normalized * bitShift);
                    res -= res.xxyz * bitMask;
                    return res;
                }
                
                void main() {
                    gl_FragColor = packDepth(vLinearDepth);
                }
            `;
            
            depthMaterial = new THREE.ShaderMaterial({
                vertexShader: linearDepthVertexShader,
                fragmentShader: linearDepthFragmentShader,
                uniforms: {
                    cameraNear: { value: 0.1 },
                    cameraFar: { value: 100 }
                }
            });
            
            // Create transform gizmos
            createGizmos();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        // Create or update shadow map for a projector
        function updateShadowMap(projector) {
            // Determine FOV based on lens type
            // Fisheye lenses need a much wider shadow map to cover their FOV
            const lens = projector.lens || { type: 'rectilinear' };
            const isFisheye = lens.type && lens.type.startsWith('fisheye');
            
            let verticalFov, aspectRatio;
            if (isFisheye) {
                // Use the projector's fisheye FOV for shadow map (clamped to practical limit)
                // Perspective cameras can't truly do 180Â°, so clamp to 170Â° max
                const fisheyeFov = lens.fisheyeFov || 180;
                verticalFov = Math.min(fisheyeFov, 170);
                aspectRatio = 1.0; // Square shadow map for omnidirectional coverage
            } else {
                // Use same vertical FOV calculation as projection matrix for rectilinear
                verticalFov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom * projector.aspectRatio)) * (180 / Math.PI);
                aspectRatio = projector.aspectRatio;
            }
            
            const nearPlane = projector.nearPlane || 0.1;
            const farPlane = projector.farPlane || 100;
            
            let shadowData = shadowMaps.get(projector.id);
            
            if (!shadowData) {
                // Create new render target and camera
                const renderTarget = new THREE.WebGLRenderTarget(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat
                });
                
                const shadowCamera = new THREE.PerspectiveCamera(verticalFov, aspectRatio, nearPlane, farPlane);
                
                shadowData = { renderTarget, camera: shadowCamera, isFisheye };
                shadowMaps.set(projector.id, shadowData);
            }
            
            // Update shadow camera
            const shadowCamera = shadowData.camera;
            shadowCamera.fov = verticalFov;
            shadowCamera.aspect = aspectRatio;
            shadowCamera.near = nearPlane;
            shadowCamera.far = farPlane;
            shadowData.isFisheye = isFisheye;
            shadowCamera.position.set(projector.position.x, projector.position.y, projector.position.z);
            
            // Use same quaternion composition as projection matrix
            const flipQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            const userEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z),
                'YXZ'
            );
            const userQuat = new THREE.Quaternion().setFromEuler(userEuler);
            const finalQuat = new THREE.Quaternion().multiplyQuaternions(userQuat, flipQuat);
            shadowCamera.quaternion.copy(finalQuat);
            
            shadowCamera.updateMatrixWorld(true);
            shadowCamera.updateProjectionMatrix();
            
            // Render shadow map
            renderShadowMap(projector.id);
            
            return shadowData;
        }
        
        function renderShadowMap(projectorId) {
            const shadowData = shadowMaps.get(projectorId);
            if (!shadowData || !depthMaterial) return;
            
            // Update depth material uniforms to match this projector's shadow camera
            depthMaterial.uniforms.cameraNear.value = shadowData.camera.near;
            depthMaterial.uniforms.cameraFar.value = shadowData.camera.far;
            
            const currentBackground = scene.background;
            const currentOverrideMaterial = scene.overrideMaterial;
            
            scene.background = null;
            scene.overrideMaterial = depthMaterial;
            
            // Hide gizmos, projectors, and distance helpers during shadow render
            const gizmoVisible = gizmoGroup ? gizmoGroup.visible : false;
            const projectorVisible = projectorGroup.visible;
            const distanceVisible = distanceHelperGroup ? distanceHelperGroup.visible : false;
            if (gizmoGroup) gizmoGroup.visible = false;
            if (distanceHelperGroup) distanceHelperGroup.visible = false;
            projectorGroup.visible = false;
            gridHelper.visible = false;
            
            renderer.setRenderTarget(shadowData.renderTarget);
            renderer.setClearColor(0xffffff, 1); // White = max depth (nothing there)
            renderer.clear();
            renderer.render(scene, shadowData.camera);
            renderer.setRenderTarget(null);
            renderer.setClearColor(0x0d0d12, 1); // Restore scene clear color
            
            // Restore
            scene.background = currentBackground;
            scene.overrideMaterial = currentOverrideMaterial;
            if (gizmoGroup) gizmoGroup.visible = gizmoVisible;
            if (distanceHelperGroup) distanceHelperGroup.visible = distanceVisible;
            projectorGroup.visible = projectorVisible;
            gridHelper.visible = state.displayOptions.grid;
        }
        
        function renderAllShadowMaps() {
            state.projectors.filter(p => p.enabled).forEach(p => {
                updateShadowMap(p);
            });
        }
        
        function initControls() {
            let isMouseDown = false;
            let mouseButton = -1;  // Track which button is pressed
            let prevMouseX = 0, prevMouseY = 0;
            let mouseDownX = 0, mouseDownY = 0;
            let isDragging = false;
            let isGizmoActive = false;
            
            renderer.domElement.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    // Check if clicking on gizmo first
                    if (handleGizmoInteraction(e, 'down')) {
                        isGizmoActive = true;
                        return;
                    }
                }
                
                if (e.button === 0 || e.button === 2) {
                    isMouseDown = true;
                    mouseButton = e.button;
                    isDragging = false;
                    prevMouseX = e.clientX;
                    prevMouseY = e.clientY;
                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('mouseup', e => {
                if (isGizmoActive) {
                    handleGizmoInteraction(e, 'up');
                    isGizmoActive = false;
                    gizmoState.startAngle = null;
                    return;
                }
                
                if (!isDragging && e.button === 0) {
                    handleCanvasClick(e);
                }
                isMouseDown = false;
                mouseButton = -1;
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => { 
                isMouseDown = false; 
                mouseButton = -1;
                isDragging = false;
                if (isGizmoActive) {
                    handleGizmoInteraction(null, 'up');
                    isGizmoActive = false;
                    gizmoState.startAngle = null;
                }
            });
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            renderer.domElement.addEventListener('mousemove', e => {
                // Handle gizmo dragging
                if (isGizmoActive) {
                    handleGizmoInteraction(e, 'move');
                    return;
                }
                
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                
                const totalMovement = Math.abs(e.clientX - mouseDownX) + Math.abs(e.clientY - mouseDownY);
                if (totalMovement > 5) isDragging = true;
                
                if (mouseButton === 0) {
                    // Left-click drag: Rotate camera (look around)
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y -= deltaX * 0.003;
                    camera.rotation.x -= deltaY * 0.003;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    
                    // Sync projector if in pilot mode
                    if (pilotMode.enabled) {
                        syncProjectorToCamera();
                    }
                } else if (mouseButton === 2) {
                    // Right-click drag: Pan camera (move in view plane)
                    const panSpeed = 0.01;
                    
                    // Get camera's right and up vectors in world space
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.getWorldDirection(new THREE.Vector3());
                    right.setFromMatrixColumn(camera.matrix, 0);  // First column = right
                    up.setFromMatrixColumn(camera.matrix, 1);     // Second column = up
                    
                    // Move camera: right for horizontal, up for vertical
                    camera.position.addScaledVector(right, -deltaX * panSpeed);
                    camera.position.addScaledVector(up, deltaY * panSpeed);
                    
                    // Sync projector if in pilot mode
                    if (pilotMode.enabled) {
                        syncProjectorToCamera();
                    }
                }
                
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
            
            // Scroll wheel: Move forward/backward
            renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                
                const scrollSpeed = 0.5;
                const delta = e.deltaY > 0 ? -scrollSpeed : scrollSpeed;
                
                // Get camera's forward direction
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                
                // Move camera along forward direction
                camera.position.addScaledVector(forward, delta);
                
                // Sync projector if in pilot mode
                if (pilotMode.enabled) {
                    syncProjectorToCamera();
                }
            }, { passive: false });
            
            // Gizmo hover effect
            renderer.domElement.addEventListener('mousemove', e => {
                if (isGizmoActive || !gizmoGroup || !gizmoGroup.visible) {
                    // Clear hover state when dragging
                    if (hoveredAxis && !gizmoState.isDragging) {
                        highlightAxis(hoveredAxis, false);
                        hoveredAxis = null;
                        hideAxisLabel();
                    }
                    return;
                }
                
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );
                
                updateGizmoHover(mouse);
            });
        }
        
        function initKeyboardControls() {
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                const tag = document.activeElement.tagName;
                const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement.isContentEditable;
                
                // Ctrl+Z for undo - works even when typing
                if ((e.ctrlKey || e.metaKey) && key === 'z') {
                    e.preventDefault();
                    undo();
                    return;
                }
                
                // Ctrl+D for debug lens type visualization
                if ((e.ctrlKey || e.metaKey) && key === 'd') {
                    e.preventDefault();
                    toggleDebugLensType();
                    return;
                }
                
                // Skip all hotkeys if user is typing in an input field
                if (isTyping) {
                    // Only allow Escape to blur the input
                    if (key === 'escape') {
                        document.activeElement.blur();
                        e.preventDefault();
                    }
                    return; // Don't capture any other keys while typing
                }
                
                // WASD movement keys (only when not typing)
                if (keys.hasOwnProperty(key)) { 
                    keys[key] = true; 
                    e.preventDefault(); 
                }
                
                // Transform mode shortcuts
                if (key === 'g' && state.selectedObject) {
                    setTransformMode('translate');
                    e.preventDefault();
                } else if (key === 'r' && state.selectedObject) {
                    setTransformMode('rotate');
                    e.preventDefault();
                } else if (key === 'v') {
                    setTransformMode('select');
                    e.preventDefault();
                } else if (key === 'escape') {
                    // Cancel current operation or deselect
                    if (gizmoState.isDragging) {
                        gizmoState.isDragging = false;
                        gizmoState.activeAxis = null;
                        showGizmoInfo(false);
                    } else {
                        state.selectedObject = null;
                        state.selectedType = null;
                        updateProjectorList();
                        updateSurfaceList();
                        updatePropertiesPanel();
                        enableTransformTools(false);
                        updateGizmoPosition();
                    }
                    e.preventDefault();
                } else if (key === 'delete' || key === 'backspace') {
                    // Delete selected object
                    if (state.selectedObject) {
                        if (state.selectedType === 'projector') {
                            removeProjector(state.selectedObject);
                        } else if (state.selectedType === 'surface') {
                            removeSurface(state.selectedObject);
                        }
                        e.preventDefault();
                    }
                }
            });
            window.addEventListener('keyup', e => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
            });
        }
        
        function updateCameraMovement() {
            const speed = 0.15;
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            const right = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();
            
            const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
            const rightHoriz = new THREE.Vector3(right.x, 0, right.z).normalize();
            
            let moved = false;
            if (keys.w) { camera.position.addScaledVector(forward, speed); moved = true; }
            if (keys.s) { camera.position.addScaledVector(forward, -speed); moved = true; }
            if (keys.a) { camera.position.addScaledVector(rightHoriz, -speed); moved = true; }
            if (keys.d) { camera.position.addScaledVector(rightHoriz, speed); moved = true; }
            if (keys.e) { camera.position.y += speed; moved = true; }
            if (keys.q) { camera.position.y -= speed; moved = true; }
            
            // Sync projector if in pilot mode
            if (moved && pilotMode.enabled) {
                syncProjectorToCamera();
            }
        }
        
        function handleCanvasClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const projMeshes = [];
            projectorGroup.traverse(c => { if (c.isMesh && c.userData.isProjector) projMeshes.push(c); });
            let hits = raycaster.intersectObjects(projMeshes);
            if (hits.length > 0) { selectObject('projector', hits[0].object.userData.projectorId); return; }
            
            hits = raycaster.intersectObjects(surfaceGroup.children);
            if (hits.length > 0 && hits[0].object.userData.surfaceId) {
                selectObject('surface', hits[0].object.userData.surfaceId);
            }
        }
        
        // ==========================================
        // TEXTURE GENERATION
        // ==========================================
        
        function createPatternTexture(pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            switch(pattern) {
                case 'none':
                    ctx.fillStyle = '#999';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'grid':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 512; i += 32) {
                        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
                    }
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(4, 4, 504, 504);
                    break;
                case 'checker':
                    for (let y = 0; y < 512; y += 32)
                        for (let x = 0; x < 512; x += 32) {
                            ctx.fillStyle = ((x + y) / 32) % 2 === 0 ? '#fff' : '#000';
                            ctx.fillRect(x, y, 32, 32);
                        }
                    break;
                case 'gradient':
                    const grad = ctx.createLinearGradient(0, 0, 512, 0);
                    grad.addColorStop(0, '#000'); grad.addColorStop(1, '#fff');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'colorbars':
                    ['#fff','#ff0','#0ff','#0f0','#f0f','#f00','#00f'].forEach((c, i) => {
                        ctx.fillStyle = c;
                        ctx.fillRect(i * 512/7, 0, 512/7 + 1, 512);
                    });
                    break;
                case 'cross':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(256, 0); ctx.lineTo(256, 512);
                    ctx.moveTo(0, 256); ctx.lineTo(512, 256);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(256, 256, 100, 0, Math.PI * 2);
                    ctx.arc(256, 256, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 3;
                    [[10,10],[452,10],[10,452],[452,452]].forEach(([x,y]) => ctx.strokeRect(x, y, 50, 50));
                    break;
                case 'white':
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'blend':
                    ctx.fillStyle = '#888';
                    ctx.fillRect(0, 0, 512, 512);
                    const lg = ctx.createLinearGradient(0, 0, 120, 0);
                    lg.addColorStop(0, 'rgba(255,0,0,1)'); lg.addColorStop(1, 'transparent');
                    ctx.fillStyle = lg; ctx.fillRect(0, 0, 120, 512);
                    const rg = ctx.createLinearGradient(392, 0, 512, 0);
                    rg.addColorStop(0, 'transparent'); rg.addColorStop(1, 'rgba(0,255,0,1)');
                    ctx.fillStyle = rg; ctx.fillRect(392, 0, 120, 512);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // ==========================================
        // PROJECTOR
        // ==========================================
        
        function addProjector(presetKey = 'custom') {
            const preset = projectorPresets[presetKey] || projectorPresets['custom'];
            const id = Date.now();
            const projector = {
                id,
                uuid: generateUUID(),  // Unique identifier for disguise compatibility
                name: `Projector ${state.projectors.length + 1}`,
                preset: presetKey,
                position: { x: 0, y: 4, z: -8 },
                rotation: { x: -10, y: 0, z: 0 },  // pitch, yaw, roll
                lumens: preset.lumens,
                brightness: 100,       // Brightness percentage (0-100)
                stack: 1,              // Quantity for stacked projectors
                throwRatio: preset.throwRatio,
                aspectRatio: preset.aspectRatio,
                resolution: preset.resolution,
                zoom: 1.0,
                enabled: true,
                customTextureUrl: null,
                nearPlane: 0.1,
                farPlane: 100,
                frustumDistance: 20,
                // Body mesh properties
                body: {
                    width: 0.4,        // Body width in meters
                    height: 0.2,       // Body height in meters
                    depth: 0.5,        // Body depth in meters
                    offsetX: 0,        // Position offset X
                    offsetY: 0,        // Position offset Y
                    offsetZ: 0         // Position offset Z
                },
                // Lens/Optics properties
                lens: {
                    type: 'rectilinear',  // rectilinear, fisheye_equidistant, fisheye_equisolid, fisheye_stereographic, fisheye_orthographic
                    fisheyeFov: 180,      // FOV in degrees for fisheye lenses (90-220, typical 180)
                    shiftH: 0,            // Horizontal lens shift in % (-100 to 100)
                    shiftV: 0,            // Vertical lens shift in % (-100 to 100)
                    // Distortion coefficients (Brown-Conrady model)
                    k1: 0,                // Radial distortion coefficient 1
                    k2: 0,                // Radial distortion coefficient 2
                    k3: 0,                // Radial distortion coefficient 3
                    p1: 0,                // Tangential distortion coefficient 1
                    p2: 0,                // Tangential distortion coefficient 2
                    // Principal point offset (normalized -1 to 1) - derived from shift
                    cx: 0,                // Horizontal principal point offset
                    cy: 0                 // Vertical principal point offset
                },
                // Target point (optional - for look-at calculations)
                target: null  // { x, y, z } or null
            };
            
            state.projectors.push(projector);
            createProjectorMesh(projector);
            updateProjectorMatrix(projector);
            updateShadowMap(projector);  // Create shadow map for new projector
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', id);
            calculateCoverage();
        }
        
        // Generate UUID v4
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16).toUpperCase();
            });
        }
        
        // Calculate projector metrics at target distance
        function calculateProjectorMetrics(projector, targetDistance = null) {
            const dist = targetDistance || projector.frustumDistance || 20;
            const effectiveLumens = projector.lumens * (projector.brightness / 100) * (projector.stack || 1);
            
            // Calculate projection dimensions at target distance
            const width = dist / projector.throwRatio / (projector.zoom || 1);
            const height = width / projector.aspectRatio;
            const area = width * height;
            
            // Illuminance in lux at target
            const illuminance = effectiveLumens / area;
            
            // Parse resolution
            const resParts = projector.resolution.split('Ã—');
            const resX = parseInt(resParts[0]) || 1920;
            const resY = parseInt(resParts[1]) || 1080;
            
            // DPI at target (pixels per inch, with meters to inches conversion)
            const widthInches = width * 39.3701;
            const dpi = resX / widthInches;
            
            return {
                distance: dist,
                width: width,
                height: height,
                area: area,
                illuminance: illuminance,
                effectiveLumens: effectiveLumens,
                dpi: dpi,
                resX: resX,
                resY: resY
            };
        }
        
        function createProjectorMesh(projector) {
            const group = new THREE.Group();
            group.userData.projectorId = projector.id;
            
            // Get body dimensions with defaults
            const bodyW = projector.body?.width || 0.4;
            const bodyH = projector.body?.height || 0.2;
            const bodyD = projector.body?.depth || 0.5;
            const offsetX = projector.body?.offsetX || 0;
            const offsetY = projector.body?.offsetY || 0;
            const offsetZ = projector.body?.offsetZ || 0;
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(bodyW, bodyH, bodyD),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            body.userData.isProjector = true;
            body.userData.projectorId = projector.id;
            body.position.set(offsetX, offsetY, offsetZ);
            group.add(body);
            
            // Direction indicator above projector
            const indicatorSize = Math.min(bodyW, bodyH) * 0.4;
            const indicator = new THREE.Mesh(
                new THREE.ConeGeometry(indicatorSize, indicatorSize * 2.5, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            indicator.rotation.x = Math.PI / 2;
            indicator.position.y = offsetY + bodyH / 2 + indicatorSize;
            indicator.position.z = offsetZ + bodyD * 0.3;
            group.add(indicator);
            
            group.add(createFrustum(projector));
            
            group.position.set(projector.position.x, projector.position.y, projector.position.z);
            // Use YXZ order to match updateProjectorMatrix
            group.rotation.order = 'YXZ';
            group.rotation.set(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z)
            );
            
            projectorGroup.add(group);
        }
        
        function createFrustum(projector) {
            const group = new THREE.Group();
            group.userData.isFrustum = true;
            
            const dist = projector.frustumDistance || 20;
            // Calculate frustum dimensions at the target distance
            const w = (dist / projector.throwRatio) / projector.zoom;
            const h = w / projector.aspectRatio;
            
            const mat = new THREE.LineBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.5 });
            
            // Frustum edge lines from projector to far plane
            const pts = [
                [0,0,0], [-w/2,-h/2,dist], [0,0,0], [w/2,-h/2,dist],
                [0,0,0], [w/2,h/2,dist], [0,0,0], [-w/2,h/2,dist]
            ].map(p => new THREE.Vector3(...p));
            group.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), mat));
            
            // Rectangle at frustum end
            const rect = [[-w/2,-h/2,dist], [w/2,-h/2,dist], [w/2,h/2,dist], [-w/2,h/2,dist], [-w/2,-h/2,dist]]
                .map(p => new THREE.Vector3(...p));
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rect), mat));
            
            group.visible = state.displayOptions.frustums;
            return group;
        }
        
        function updateProjectorMatrix(projector) {
            // Calculate VERTICAL FOV from throw ratio
            // Throw ratio = distance / width, so horizontal half-angle = atan(1 / (2 * throwRatio * zoom))
            // Vertical half-angle = horizontal half-angle / aspectRatio
            // PerspectiveCamera expects vertical FOV
            const verticalFov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom * projector.aspectRatio)) * (180 / Math.PI);
            
            const nearPlane = projector.nearPlane || 0.1;
            const farPlane = projector.farPlane || 100;
            
            const projCam = new THREE.PerspectiveCamera(verticalFov, projector.aspectRatio, nearPlane, farPlane);
            projCam.position.set(projector.position.x, projector.position.y, projector.position.z);
            
            // User rotation euler (this is what the mesh uses, +Z is forward)
            const userEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z),
                'YXZ'
            );
            const userQuat = new THREE.Quaternion().setFromEuler(userEuler);
            
            // For the projection camera, we need to flip since cameras look at -Z by default
            // Create flip quaternion (180Â° around Y) to make camera face +Z instead of -Z
            const flipQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            
            // Compose: first flip to face +Z, then apply user rotation
            const finalQuat = new THREE.Quaternion().multiplyQuaternions(userQuat, flipQuat);
            projCam.quaternion.copy(finalQuat);
            
            projCam.updateMatrixWorld(true);
            projCam.updateProjectionMatrix();
            
            const vpMatrix = new THREE.Matrix4();
            vpMatrix.multiplyMatrices(projCam.projectionMatrix, projCam.matrixWorldInverse);
            
            // For fisheye calculation, use the USER rotation only (no flip)
            // This matches the projector mesh orientation where +Z is forward
            // The rotation matrix transforms from local to world space
            const rotMatrix = new THREE.Matrix4().makeRotationFromQuaternion(userQuat);
            const rotMatrix3 = new THREE.Matrix3().setFromMatrix4(rotMatrix);
            // Inverse (transpose) transforms from world to local space
            const rotMatrixInverse = rotMatrix3.clone().transpose();
            
            // Calculate effective lumens (base * brightness% * stack)
            const effectiveLumens = projector.lumens * ((projector.brightness || 100) / 100) * (projector.stack || 1);
            
            projectorMatrixData.set(projector.id, {
                matrix: vpMatrix,
                position: new THREE.Vector3(projector.position.x, projector.position.y, projector.position.z),
                rotationMatrixInverse: rotMatrixInverse,
                lumens: effectiveLumens,
                throwRatio: projector.throwRatio * projector.zoom,
                nearPlane: nearPlane,
                farPlane: farPlane
            });
            
            if (projector.customTextureUrl && customTextureData.has(projector.id)) {
                projectionTextures.set(projector.id, customTextureData.get(projector.id));
            } else {
                projectionTextures.set(projector.id, createPatternTexture(state.currentPattern));
            }
        }
        
        function updateProjectorMesh(projector) {
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === projector.id);
            if (mesh) {
                mesh.position.set(projector.position.x, projector.position.y, projector.position.z);
                // Use YXZ order to match updateProjectorMatrix
                mesh.rotation.order = 'YXZ';
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(projector.rotation.x),
                    THREE.MathUtils.degToRad(projector.rotation.y),
                    THREE.MathUtils.degToRad(projector.rotation.z)
                );
                
                const oldF = mesh.children.find(c => c.userData.isFrustum);
                if (oldF) {
                    // Dispose old frustum geometry and materials
                    oldF.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    mesh.remove(oldF);
                }
                mesh.add(createFrustum(projector));
            }
            
            updateProjectorMatrix(projector);
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function applyPreset(projectorId, presetKey) {
            const projector = state.projectors.find(p => p.id === projectorId);
            const preset = projectorPresets[presetKey];
            if (!projector || !preset) return;
            
            projector.preset = presetKey;
            projector.lumens = preset.lumens;
            projector.throwRatio = preset.throwRatio;
            projector.aspectRatio = preset.aspectRatio;
            projector.resolution = preset.resolution;
            
            updateProjectorMesh(projector);
            updateProjectorList();
            updatePropertiesPanel();
        }
        
        function removeProjector(id) {
            state.projectors = state.projectors.filter(p => p.id !== id);
            
            // Clean up mesh and all its children
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
            if (mesh) {
                mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                projectorGroup.remove(mesh);
            }
            
            // Clean up shadow map render target
            const shadowData = shadowMaps.get(id);
            if (shadowData) {
                shadowData.renderTarget.dispose();
                shadowMaps.delete(id);
            }
            
            // Clean up video data
            const videoData = videoTextureData.get(id);
            if (videoData) {
                if (videoData.updateInterval) {
                    clearInterval(videoData.updateInterval);
                }
                videoData.video.pause();
                videoData.video.src = '';
                if (videoData.texture) videoData.texture.dispose();
                videoTextureData.delete(id);
            }
            
            // Clean up textures
            const tex = projectionTextures.get(id);
            if (tex && !customTextureData.has(id)) {
                tex.dispose(); // Only dispose if not a custom texture
            }
            projectorMatrixData.delete(id);
            projectionTextures.delete(id);
            customTextureData.delete(id);
            
            if (state.selectedType === 'projector' && state.selectedObject === id) {
                state.selectedObject = null;
                state.selectedType = null;
                updatePropertiesPanel();
            }
            
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            calculateCoverage();
        }
        
        function loadCustomTexture(projectorId, file) {
            if (!file) return;
            
            const projector = state.projectors.find(p => p.id === projectorId);
            if (!projector) return;
            
            const isVideo = file.type.startsWith('video/');
            
            if (isVideo) {
                // Handle video file
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.loop = true;
                video.muted = true; // Muted to allow autoplay
                video.playsInline = true;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    video.src = e.target.result;
                    
                    video.onloadedmetadata = function() {
                        // Store video data
                        const resolution = projector.videoResolution || 'native';
                        const texture = createVideoTexture(video, resolution);
                        
                        videoTextureData.set(projectorId, {
                            video: video,
                            texture: texture,
                            playing: false,
                            loop: true,
                            resolution: resolution,
                            nativeWidth: video.videoWidth,
                            nativeHeight: video.videoHeight
                        });
                        
                        projector.customTextureUrl = 'video';
                        projector.customTextureType = 'video';
                        projector.videoResolution = resolution;
                        customTextureData.set(projectorId, texture);
                        projectionTextures.set(projectorId, texture);
                        updateAllSurfaceMaterials();
                        updatePropertiesPanel();
                    };
                };
                reader.readAsDataURL(file);
            } else {
                // Handle image file (original behavior)
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        
                        projector.customTextureUrl = e.target.result;
                        projector.customTextureType = 'image';
                        customTextureData.set(projectorId, texture);
                        projectionTextures.set(projectorId, texture);
                        updateAllSurfaceMaterials();
                        updatePropertiesPanel();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function createVideoTexture(video, resolution) {
            // Get target resolution
            const resolutions = {
                'native': { w: video.videoWidth, h: video.videoHeight },
                '1080p': { w: 1920, h: 1080 },
                '720p': { w: 1280, h: 720 },
                '480p': { w: 854, h: 480 },
                '360p': { w: 640, h: 360 }
            };
            
            const target = resolutions[resolution] || resolutions['native'];
            
            // Create a canvas for downsampling if needed
            if (resolution !== 'native' && (video.videoWidth > target.w || video.videoHeight > target.h)) {
                const canvas = document.createElement('canvas');
                canvas.width = target.w;
                canvas.height = target.h;
                
                // Create canvas texture that we'll update from video
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.userData = { 
                    canvas: canvas, 
                    ctx: canvas.getContext('2d'),
                    video: video,
                    isDownsampled: true
                };
                return texture;
            } else {
                // Use native video texture
                const texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                return texture;
            }
        }
        
        function updateVideoResolution(projectorId, resolution) {
            const videoData = videoTextureData.get(projectorId);
            const projector = state.projectors.find(p => p.id === projectorId);
            if (!videoData || !projector) return;
            
            const wasPlaying = videoData.playing;
            
            // Create new texture with new resolution
            const newTexture = createVideoTexture(videoData.video, resolution);
            
            // Clean up old texture
            if (videoData.texture) {
                videoData.texture.dispose();
            }
            
            videoData.texture = newTexture;
            videoData.resolution = resolution;
            projector.videoResolution = resolution;
            
            customTextureData.set(projectorId, newTexture);
            projectionTextures.set(projectorId, newTexture);
            updateAllSurfaceMaterials();
            
            if (wasPlaying) {
                playVideo(projectorId);
            }
        }
        
        function playVideo(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.play();
            videoData.playing = true;
            
            // Start interval to update seek bar
            if (!videoData.updateInterval) {
                videoData.updateInterval = setInterval(() => {
                    // Only update if this projector is selected
                    if (state.selectedType === 'projector' && state.selectedObject === projectorId) {
                        const seekInput = document.querySelector('.video-seek input[type="range"]');
                        const timeDisplay = document.querySelector('.video-time');
                        if (seekInput && timeDisplay) {
                            seekInput.value = videoData.video.currentTime;
                            seekInput.max = videoData.video.duration;
                            timeDisplay.textContent = `${formatTime(videoData.video.currentTime)} / ${formatTime(videoData.video.duration)}`;
                        }
                    }
                }, 250);
            }
            
            updatePropertiesPanel();
        }
        
        function pauseVideo(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.pause();
            videoData.playing = false;
            
            // Clear update interval
            if (videoData.updateInterval) {
                clearInterval(videoData.updateInterval);
                videoData.updateInterval = null;
            }
            
            updatePropertiesPanel();
        }
        
        function toggleVideoLoop(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.loop = !videoData.loop;
            videoData.video.loop = videoData.loop;
            updatePropertiesPanel();
        }
        
        function seekVideo(projectorId, time) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.currentTime = time;
        }
        
        function restartVideo(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.currentTime = 0;
            if (!videoData.playing) {
                playVideo(projectorId);
            }
        }
        
        function clearCustomTexture(projectorId) {
            const projector = state.projectors.find(p => p.id === projectorId);
            if (projector) {
                projector.customTextureUrl = null;
                projector.customTextureType = null;
                projector.videoResolution = null;
                
                // Clean up video if present
                const videoData = videoTextureData.get(projectorId);
                if (videoData) {
                    if (videoData.updateInterval) {
                        clearInterval(videoData.updateInterval);
                    }
                    videoData.video.pause();
                    videoData.video.src = '';
                    if (videoData.texture) videoData.texture.dispose();
                    videoTextureData.delete(projectorId);
                }
                
                customTextureData.delete(projectorId);
                projectionTextures.set(projectorId, createPatternTexture(state.currentPattern));
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
            }
        }
        
        function updateProjectorList() {
            const list = document.getElementById('projector-list');
            document.getElementById('projector-count').textContent = state.projectors.length;
            
            if (state.projectors.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No projectors yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.projectors.map(p => {
                let textureInfo = '';
                if (p.customTextureType === 'video') {
                    textureInfo = ' â€¢ Video';
                } else if (p.customTextureUrl) {
                    textureInfo = ' â€¢ Image';
                }
                const effectiveLm = p.lumens * ((p.brightness || 100) / 100) * (p.stack || 1);
                const stackInfo = (p.stack || 1) > 1 ? ` (Ã—${p.stack})` : '';
                return `
                <div class="object-item ${state.selectedType === 'projector' && state.selectedObject === p.id ? 'selected' : ''}" onclick="selectObject('projector', ${p.id})">
                    <div class="object-icon projector"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                    <div class="object-info">
                        <div class="object-name">${p.name}${stackInfo}</div>
                        <div class="object-type">${(effectiveLm/1000).toFixed(0)}K lm${textureInfo}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn" onclick="event.stopPropagation(); duplicateProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>
            `}).join('');
        }
        
        function duplicateProjector(id) {
            const orig = state.projectors.find(p => p.id === id);
            if (!orig) return;
            const dup = { 
                ...JSON.parse(JSON.stringify(orig)), 
                id: Date.now(), 
                uuid: generateUUID(),  // Generate new unique ID
                name: orig.name + ' (Copy)', 
                position: { ...orig.position, x: orig.position.x + 2 }, 
                customTextureUrl: null,
                customTextureType: null,
                videoResolution: null
            };
            state.projectors.push(dup);
            createProjectorMesh(dup);
            updateProjectorMatrix(dup);
            updateShadowMap(dup);  // Create shadow map for duplicated projector
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', dup.id);
            calculateCoverage();
        }
        
        // ==========================================
        // SURFACE
        // ==========================================
        
        function addSurface() {
            const id = Date.now();
            const surface = {
                id,
                name: `Surface ${state.surfaces.length + 1}`,
                type: 'flat',
                position: { x: 0, y: 3, z: 5 },
                rotation: { x: 0, y: 180, z: 0 },
                dimensions: { width: 8, height: 4.5 },
                curvature: 30,
                color: '#555555',
                gain: 1.0
            };
            
            state.surfaces.push(surface);
            createSurfaceMesh(surface);
            // Re-render shadow maps to include new surface, then update all materials
            updateAllSurfaceMaterials();
            updateSurfaceList();
            updateStatus();
            selectObject('surface', id);
            calculateCoverage();
        }
        
        function importOBJSurface(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(e.target.result);
                    
                    // Calculate bounding box to determine size and center
                    const box = new THREE.Box3().setFromObject(obj);
                    const size = new THREE.Vector3();
                    const center = new THREE.Vector3();
                    box.getSize(size);
                    box.getCenter(center);
                    
                    const id = Date.now();
                    const surface = {
                        id,
                        name: file.name.replace('.obj', ''),
                        type: 'custom',
                        position: { x: 0, y: size.y / 2, z: 5 },
                        rotation: { x: 0, y: 0, z: 0 },
                        dimensions: { width: size.x, height: size.y },
                        curvature: 0,
                        color: '#555555',
                        gain: 1.0,
                        scale: 1.0,
                        objData: e.target.result // Store OBJ data for export
                    };
                    
                    state.surfaces.push(surface);
                    
                    // Create mesh from OBJ with projection material
                    createOBJSurfaceMesh(surface, obj, center);
                    
                    // Re-render shadow maps to include new surface, then update all materials
                    updateAllSurfaceMaterials();
                    updateSurfaceList();
                    updateStatus();
                    selectObject('surface', id);
                    calculateCoverage();
                    
                    showToast(`Imported "${surface.name}" successfully`);
                } catch (err) {
                    console.error('OBJ import error:', err);
                    showToast('Failed to import OBJ file', 'error');
                }
            };
            
            reader.onerror = function() {
                showToast('Failed to read OBJ file', 'error');
            };
            
            reader.readAsText(file);
            
            // Reset file input
            document.getElementById('obj-import').value = '';
        }
        
        function createOBJSurfaceMesh(surface, obj, center) {
            // Merge all geometries from the OBJ
            const geometries = [];
            obj.traverse(child => {
                if (child.isMesh && child.geometry) {
                    // Clone and transform geometry
                    const geom = child.geometry.clone();
                    
                    // Center the geometry
                    geom.translate(-center.x, -center.y, -center.z);
                    
                    // Ensure normals exist
                    if (!geom.attributes.normal) {
                        geom.computeVertexNormals();
                    }
                    
                    geometries.push(geom);
                }
            });
            
            if (geometries.length === 0) {
                showToast('No valid geometry found in OBJ', 'error');
                return;
            }
            
            // Merge geometries if multiple
            let finalGeom;
            if (geometries.length === 1) {
                finalGeom = geometries[0];
            } else {
                // Simple merge - combine all buffer attributes
                const positions = [];
                const normals = [];
                const uvs = [];
                
                geometries.forEach(geom => {
                    const pos = geom.attributes.position;
                    const norm = geom.attributes.normal;
                    const uv = geom.attributes.uv;
                    
                    for (let i = 0; i < pos.count; i++) {
                        positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        if (norm) normals.push(norm.getX(i), norm.getY(i), norm.getZ(i));
                        if (uv) uvs.push(uv.getX(i), uv.getY(i));
                    }
                });
                
                finalGeom = new THREE.BufferGeometry();
                finalGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                if (normals.length > 0) {
                    finalGeom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                } else {
                    finalGeom.computeVertexNormals();
                }
                if (uvs.length > 0) {
                    finalGeom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                }
            }
            
            const mesh = new THREE.Mesh(finalGeom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface;
            mesh.userData.isCustomOBJ = true;
            
            mesh.position.set(surface.position.x, surface.position.y, surface.position.z);
            // Use YXZ order consistently to avoid gimbal lock
            mesh.rotation.order = 'YXZ';
            mesh.rotation.set(
                THREE.MathUtils.degToRad(surface.rotation.x),
                THREE.MathUtils.degToRad(surface.rotation.y),
                THREE.MathUtils.degToRad(surface.rotation.z)
            );
            
            // Apply scale
            const scale = surface.scale || 1.0;
            mesh.scale.setScalar(scale);
            
            surfaceGroup.add(mesh);
        }
        
        function createSurfaceMaterial(surface) {
            const defaultTex = createPatternTexture('none');
            const defaultShadowTex = new THREE.DataTexture(new Uint8Array([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat);
            defaultShadowTex.needsUpdate = true;
            
            const uniforms = {
                // Projector textures (supports up to 8 projectors)
                projTex0: { value: defaultTex }, projTex1: { value: defaultTex },
                projTex2: { value: defaultTex }, projTex3: { value: defaultTex },
                projTex4: { value: defaultTex }, projTex5: { value: defaultTex },
                projTex6: { value: defaultTex }, projTex7: { value: defaultTex },
                shadowMap0: { value: defaultShadowTex }, shadowMap1: { value: defaultShadowTex },
                shadowMap2: { value: defaultShadowTex }, shadowMap3: { value: defaultShadowTex },
                shadowMap4: { value: defaultShadowTex }, shadowMap5: { value: defaultShadowTex },
                shadowMap6: { value: defaultShadowTex }, shadowMap7: { value: defaultShadowTex },
                projMat0: { value: new THREE.Matrix4() }, projMat1: { value: new THREE.Matrix4() },
                projMat2: { value: new THREE.Matrix4() }, projMat3: { value: new THREE.Matrix4() },
                projMat4: { value: new THREE.Matrix4() }, projMat5: { value: new THREE.Matrix4() },
                projMat6: { value: new THREE.Matrix4() }, projMat7: { value: new THREE.Matrix4() },
                // Shadow camera matrices (may differ from projMat for fisheye)
                shadowMat0: { value: new THREE.Matrix4() }, shadowMat1: { value: new THREE.Matrix4() },
                shadowMat2: { value: new THREE.Matrix4() }, shadowMat3: { value: new THREE.Matrix4() },
                shadowMat4: { value: new THREE.Matrix4() }, shadowMat5: { value: new THREE.Matrix4() },
                shadowMat6: { value: new THREE.Matrix4() }, shadowMat7: { value: new THREE.Matrix4() },
                projPos0: { value: new THREE.Vector3() }, projPos1: { value: new THREE.Vector3() },
                projPos2: { value: new THREE.Vector3() }, projPos3: { value: new THREE.Vector3() },
                projPos4: { value: new THREE.Vector3() }, projPos5: { value: new THREE.Vector3() },
                projPos6: { value: new THREE.Vector3() }, projPos7: { value: new THREE.Vector3() },
                // Projector rotation matrices (inverse) for fisheye calculation
                projRotInv0: { value: new THREE.Matrix3() }, projRotInv1: { value: new THREE.Matrix3() },
                projRotInv2: { value: new THREE.Matrix3() }, projRotInv3: { value: new THREE.Matrix3() },
                projRotInv4: { value: new THREE.Matrix3() }, projRotInv5: { value: new THREE.Matrix3() },
                projRotInv6: { value: new THREE.Matrix3() }, projRotInv7: { value: new THREE.Matrix3() },
                projLumens0: { value: 0 }, projLumens1: { value: 0 },
                projLumens2: { value: 0 }, projLumens3: { value: 0 },
                projLumens4: { value: 0 }, projLumens5: { value: 0 },
                projLumens6: { value: 0 }, projLumens7: { value: 0 },
                projThrow0: { value: 1.5 }, projThrow1: { value: 1.5 },
                projThrow2: { value: 1.5 }, projThrow3: { value: 1.5 },
                projThrow4: { value: 1.5 }, projThrow5: { value: 1.5 },
                projThrow6: { value: 1.5 }, projThrow7: { value: 1.5 },
                projNear0: { value: 0.1 }, projNear1: { value: 0.1 },
                projNear2: { value: 0.1 }, projNear3: { value: 0.1 },
                projNear4: { value: 0.1 }, projNear5: { value: 0.1 },
                projNear6: { value: 0.1 }, projNear7: { value: 0.1 },
                projFar0: { value: 100 }, projFar1: { value: 100 },
                projFar2: { value: 100 }, projFar3: { value: 100 },
                projFar4: { value: 100 }, projFar5: { value: 100 },
                projFar6: { value: 100 }, projFar7: { value: 100 },
                texOffset0: { value: new THREE.Vector2(0, 0) }, texOffset1: { value: new THREE.Vector2(0, 0) },
                texOffset2: { value: new THREE.Vector2(0, 0) }, texOffset3: { value: new THREE.Vector2(0, 0) },
                texOffset4: { value: new THREE.Vector2(0, 0) }, texOffset5: { value: new THREE.Vector2(0, 0) },
                texOffset6: { value: new THREE.Vector2(0, 0) }, texOffset7: { value: new THREE.Vector2(0, 0) },
                // Lens uniforms: x=type, y=k1, z=k2, w=k3
                lensParams0: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams1: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams3: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams4: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams5: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams6: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams7: { value: new THREE.Vector4(0, 0, 0, 0) },
                // Lens uniforms: x=p1, y=p2, z=cx, w=cy
                lensParams2_0: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_1: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_2: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_3: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_4: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_5: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_6: { value: new THREE.Vector4(0, 0, 0, 0) },
                lensParams2_7: { value: new THREE.Vector4(0, 0, 0, 0) },
                // Fisheye FOV in degrees (180 = full hemisphere)
                fisheyeFov0: { value: 180 }, fisheyeFov1: { value: 180 },
                fisheyeFov2: { value: 180 }, fisheyeFov3: { value: 180 },
                fisheyeFov4: { value: 180 }, fisheyeFov5: { value: 180 },
                fisheyeFov6: { value: 180 }, fisheyeFov7: { value: 180 },
                numProjectors: { value: 0 },
                showCoverage: { value: state.displayOptions.coverage },
                showOverlap: { value: state.displayOptions.overlap },
                showHeatmap: { value: state.displayOptions.heatmap },
                debugLensType: { value: false },  // Debug mode
                surfaceGain: { value: surface.gain },
                baseColor: { value: new THREE.Color(surface.color) },
                heatmapMax: { value: state.heatmapMax }
            };
            
            const enabled = state.projectors.filter(p => p.enabled);
            uniforms.numProjectors.value = Math.min(enabled.length, 8);
            
            enabled.slice(0, 8).forEach((proj, i) => {
                const data = projectorMatrixData.get(proj.id);
                const tex = projectionTextures.get(proj.id);
                const shadow = shadowMaps.get(proj.id);
                if (data) {
                    uniforms[`projMat${i}`].value.copy(data.matrix);
                    uniforms[`projPos${i}`].value.copy(data.position);
                    uniforms[`projLumens${i}`].value = data.lumens;
                    uniforms[`projThrow${i}`].value = data.throwRatio;
                    uniforms[`projNear${i}`].value = data.nearPlane || 0.1;
                    uniforms[`projFar${i}`].value = data.farPlane || 100;
                    // Copy rotation matrix inverse for fisheye calculation
                    if (data.rotationMatrixInverse) {
                        uniforms[`projRotInv${i}`].value.copy(data.rotationMatrixInverse);
                    }
                }
                if (tex) uniforms[`projTex${i}`].value = tex;
                if (shadow) {
                    uniforms[`shadowMap${i}`].value = shadow.renderTarget.texture;
                    // Compute and set shadow camera's view-projection matrix
                    if (shadow.camera) {
                        const shadowVPMatrix = new THREE.Matrix4();
                        shadowVPMatrix.multiplyMatrices(shadow.camera.projectionMatrix, shadow.camera.matrixWorldInverse);
                        uniforms[`shadowMat${i}`].value.copy(shadowVPMatrix);
                    }
                }
                
                // Set lens parameters
                const lens = proj.lens || { type: 'rectilinear', k1: 0, k2: 0, k3: 0, p1: 0, p2: 0, cx: 0, cy: 0 };
                const lensTypeMap = {
                    'rectilinear': 0,
                    'fisheye_equidistant': 1,
                    'fisheye_equisolid': 2,
                    'fisheye_stereographic': 3,
                    'fisheye_orthographic': 4
                };
                const lensTypeValue = lensTypeMap[lens.type] !== undefined ? lensTypeMap[lens.type] : 0;
                uniforms[`lensParams${i}`].value.set(
                    lensTypeValue,
                    lens.k1 || 0,
                    lens.k2 || 0,
                    lens.k3 || 0
                );
                uniforms[`lensParams2_${i}`].value.set(
                    lens.p1 || 0,
                    lens.p2 || 0,
                    lens.cx || 0,
                    lens.cy || 0
                );
                
                // Set fisheye FOV (default 180Â°)
                uniforms[`fisheyeFov${i}`].value = lens.fisheyeFov || 180;
                
                // Apply pattern scroll offset only for projectors without custom textures
                if (!proj.customTextureUrl && patternScrollState.enabled) {
                    uniforms[`texOffset${i}`].value.set(patternScrollState.offset.x, patternScrollState.offset.y);
                } else {
                    uniforms[`texOffset${i}`].value.set(0, 0);
                }
            });
            
            return new THREE.ShaderMaterial({
                uniforms,
                vertexShader: projectionVertexShader,
                fragmentShader: projectionFragmentShader,
                side: THREE.DoubleSide
            });
        }
        
        function createSurfaceMesh(surface) {
            // Skip custom OBJ surfaces - they're handled by createOBJSurfaceMesh
            if (surface.type === 'custom') {
                // Re-parse OBJ data if available
                if (surface.objData) {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(surface.objData);
                    const box = new THREE.Box3().setFromObject(obj);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    createOBJSurfaceMesh(surface, obj, center);
                }
                return;
            }
            
            let geom;
            if (surface.type === 'sphere') {
                // Sphere geometry
                const radius = surface.dimensions.radius || surface.dimensions.width / 2 || 2;
                const segments = surface.segments || 32;
                geom = new THREE.SphereGeometry(radius, segments, segments);
            } else if (surface.type === 'cube') {
                // Cube/Box geometry
                const width = surface.dimensions.width || 2;
                const height = surface.dimensions.height || 2;
                const depth = surface.dimensions.depth || width;
                geom = new THREE.BoxGeometry(width, height, depth, 8, 8, 8);
            } else if (surface.type === 'curved' && surface.curvature > 0) {
                const angle = surface.curvature * Math.PI / 180;
                const radius = surface.dimensions.width / Math.max(angle, 0.01);
                geom = new THREE.CylinderGeometry(radius, radius, surface.dimensions.height, 64, 1, true, Math.PI - angle/2, angle);
            } else {
                geom = new THREE.PlaneGeometry(surface.dimensions.width, surface.dimensions.height, 32, 32);
            }
            
            const mesh = new THREE.Mesh(geom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface; // Store reference for coverage calculation
            mesh.position.set(surface.position.x, surface.position.y, surface.position.z);
            // Use YXZ order consistently to avoid gimbal lock
            mesh.rotation.order = 'YXZ';
            mesh.rotation.set(
                THREE.MathUtils.degToRad(surface.rotation.x),
                THREE.MathUtils.degToRad(surface.rotation.y),
                THREE.MathUtils.degToRad(surface.rotation.z)
            );
            surfaceGroup.add(mesh);
        }
        
        function updateSurfaceMesh(surface) {
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
            if (mesh) {
                mesh.material.dispose();
                mesh.geometry.dispose();
                surfaceGroup.remove(mesh);
                createSurfaceMesh(surface);
            }
            // Re-render shadow maps since surface geometry/position changed
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function updateAllSurfaceMaterials() {
            state.projectors.forEach(p => {
                if (!p.customTextureUrl) {
                    projectionTextures.set(p.id, createPatternTexture(state.currentPattern));
                }
            });
            
            // Always render shadow maps for physically accurate occlusion
            renderAllShadowMaps();
            
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (mesh) {
                    mesh.material.dispose();
                    mesh.material = createSurfaceMaterial(surface);
                }
            });
            
            // Update distance helpers if enabled
            if (state.displayOptions.distance) {
                updateDistanceHelpers();
            }
        }
        
        function removeSurface(id) {
            state.surfaces = state.surfaces.filter(s => s.id !== id);
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
            if (mesh) { mesh.material.dispose(); mesh.geometry.dispose(); surfaceGroup.remove(mesh); }
            if (state.selectedType === 'surface' && state.selectedObject === id) {
                state.selectedObject = null; state.selectedType = null; updatePropertiesPanel();
            }
            // Re-render shadow maps since surface no longer blocks light
            updateAllSurfaceMaterials();
            updateSurfaceList(); updateStatus(); calculateCoverage();
        }
        
        function updateSurfaceList() {
            const list = document.getElementById('surface-list');
            document.getElementById('surface-count').textContent = state.surfaces.length;
            
            if (state.surfaces.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No surfaces yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.surfaces.map(s => {
                let typeInfo;
                if (s.type === 'custom') {
                    typeInfo = `Custom OBJ â€¢ Scale ${(s.scale || 1.0).toFixed(1)}Ã—`;
                } else if (s.type === 'sphere') {
                    const radius = s.dimensions.radius || s.dimensions.width / 2 || 2;
                    typeInfo = `Sphere â€¢ r=${radius.toFixed(1)}m â€¢ Gain ${s.gain}`;
                } else if (s.type === 'cube') {
                    const depth = s.dimensions.depth || s.dimensions.width;
                    typeInfo = `Cube â€¢ ${s.dimensions.width.toFixed(1)}Ã—${s.dimensions.height.toFixed(1)}Ã—${depth.toFixed(1)}m â€¢ Gain ${s.gain}`;
                } else {
                    typeInfo = `${s.dimensions.width.toFixed(1)}m Ã— ${s.dimensions.height.toFixed(1)}m â€¢ Gain ${s.gain}`;
                }
                
                let icon;
                if (s.type === 'custom') {
                    icon = `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>`;
                } else if (s.type === 'sphere') {
                    icon = `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><ellipse cx="12" cy="12" rx="10" ry="4" fill="none" stroke="currentColor" stroke-width="1"/><path d="M12 2v20" stroke="currentColor" stroke-width="1"/></svg>`;
                } else if (s.type === 'cube') {
                    icon = `<svg viewBox="0 0 24 24"><path d="M21 16.5c0 .38-.21.71-.53.88l-7.9 4.44c-.16.12-.36.18-.57.18-.21 0-.41-.06-.57-.18l-7.9-4.44A.991.991 0 013 16.5v-9c0-.38.21-.71.53-.88l7.9-4.44c.16-.12.36-.18.57-.18.21 0 .41.06.57.18l7.9 4.44c.32.17.53.5.53.88v9zM12 4.15L5 8.09v7.82l7 3.94l7-3.94V8.09l-7-3.94z"/></svg>`;
                } else {
                    icon = `<svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>`;
                }
                
                return `
                <div class="object-item ${state.selectedType === 'surface' && state.selectedObject === s.id ? 'selected' : ''}" onclick="selectObject('surface', ${s.id})">
                    <div class="object-icon surface">${icon}</div>
                    <div class="object-info">
                        <div class="object-name">${s.name}</div>
                        <div class="object-type">${typeInfo}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeSurface(${s.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>`;
            }).join('');
        }
        
        // ==========================================
        // COVERAGE CALCULATION - PROPER IMPLEMENTATION
        // ==========================================
        
        function calculateCoverage() {
            if (state.surfaces.length === 0 || state.projectors.filter(p => p.enabled).length === 0) {
                updateCoverageDisplay(0, 0, 0, 0);
                return;
            }
            
            let totalSamples = 0;
            let coveredSamples = 0;
            let totalCdm2 = 0;
            let minCdm2 = Infinity;
            let maxCdm2 = 0;
            let cdm2Samples = [];
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            
            // Sample each surface using actual geometry
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (!mesh || !mesh.geometry) return;
                
                // Update matrix world to ensure accurate transforms
                mesh.updateMatrixWorld(true);
                
                const geometry = mesh.geometry;
                const positionAttr = geometry.attributes.position;
                const normalAttr = geometry.attributes.normal;
                
                if (!positionAttr) return;
                
                // For accuracy, sample at vertex positions and face centers
                const sampledPoints = [];
                
                // Sample vertices
                const vertexStride = Math.max(1, Math.floor(positionAttr.count / 200)); // Limit to ~200 vertices
                for (let i = 0; i < positionAttr.count; i += vertexStride) {
                    const localPos = new THREE.Vector3(
                        positionAttr.getX(i),
                        positionAttr.getY(i),
                        positionAttr.getZ(i)
                    );
                    
                    let localNormal;
                    if (normalAttr) {
                        localNormal = new THREE.Vector3(
                            normalAttr.getX(i),
                            normalAttr.getY(i),
                            normalAttr.getZ(i)
                        );
                    } else {
                        localNormal = new THREE.Vector3(0, 0, 1);
                    }
                    
                    sampledPoints.push({ pos: localPos, normal: localNormal });
                }
                
                // Also sample face centers for indexed geometry
                if (geometry.index) {
                    const indices = geometry.index.array;
                    const faceStride = Math.max(3, Math.floor(indices.length / 300) * 3); // Limit to ~100 faces
                    
                    for (let i = 0; i < indices.length; i += faceStride) {
                        if (i + 2 >= indices.length) break;
                        
                        const i0 = indices[i], i1 = indices[i + 1], i2 = indices[i + 2];
                        
                        const p0 = new THREE.Vector3(positionAttr.getX(i0), positionAttr.getY(i0), positionAttr.getZ(i0));
                        const p1 = new THREE.Vector3(positionAttr.getX(i1), positionAttr.getY(i1), positionAttr.getZ(i1));
                        const p2 = new THREE.Vector3(positionAttr.getX(i2), positionAttr.getY(i2), positionAttr.getZ(i2));
                        
                        // Face center
                        const center = new THREE.Vector3().addVectors(p0, p1).add(p2).divideScalar(3);
                        
                        // Face normal (computed from vertices)
                        const edge1 = new THREE.Vector3().subVectors(p1, p0);
                        const edge2 = new THREE.Vector3().subVectors(p2, p0);
                        const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                        
                        sampledPoints.push({ pos: center, normal: faceNormal });
                    }
                }
                
                // Process each sample point
                sampledPoints.forEach(sample => {
                    // Transform to world space
                    const worldPos = sample.pos.clone().applyMatrix4(mesh.matrixWorld);
                    
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    const worldNormal = sample.normal.clone().applyMatrix3(normalMatrix).normalize();
                    
                    totalSamples++;
                    let sampleCdm2 = 0;
                    let isHit = false;
                    
                    enabledProjectors.forEach(proj => {
                        const data = projectorMatrixData.get(proj.id);
                        const shadowData = shadowMaps.get(proj.id);
                        if (!data) return;
                        
                        // Check if point is within projector frustum
                        const projCoord = new THREE.Vector4(worldPos.x, worldPos.y, worldPos.z, 1);
                        projCoord.applyMatrix4(data.matrix);
                        
                        if (projCoord.w <= 0) return;
                        
                        const ndc = new THREE.Vector3(
                            projCoord.x / projCoord.w,
                            projCoord.y / projCoord.w,
                            projCoord.z / projCoord.w
                        );
                        
                        const uv = new THREE.Vector2(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
                        
                        if (uv.x < 0 || uv.x > 1 || uv.y < 0 || uv.y > 1) return;
                        if (ndc.z < -1 || ndc.z > 1) return;
                        
                        // Check facing - surface must face the projector
                        const toProj = new THREE.Vector3().subVectors(data.position, worldPos).normalize();
                        const facing = worldNormal.dot(toProj);
                        if (facing <= 0) return;
                        
                        // Shadow occlusion check - sample shadow map
                        // This mirrors the shader logic
                        if (shadowData && shadowData.renderTarget) {
                            const fragDepthNormalized = ndc.z * 0.5 + 0.5;
                            
                            // Read shadow map at this UV (approximation - we use a raycast instead for CPU accuracy)
                            // For better accuracy, cast a ray from projector to point and check for intersections
                            const rayOrigin = data.position.clone();
                            const rayDir = new THREE.Vector3().subVectors(worldPos, rayOrigin).normalize();
                            const distToPoint = data.position.distanceTo(worldPos);
                            
                            const shadowRay = new THREE.Raycaster(rayOrigin, rayDir, 0.01, distToPoint - 0.01);
                            const intersects = shadowRay.intersectObjects(surfaceGroup.children, false);
                            
                            // If ray hits something before reaching this point, it's occluded
                            if (intersects.length > 0) {
                                const hitDist = intersects[0].distance;
                                if (hitDist < distToPoint - 0.05) {
                                    return; // Occluded by another surface
                                }
                            }
                        }
                        
                        isHit = true;
                        
                        // Calculate luminance in cd/mÂ²
                        const dist = data.position.distanceTo(worldPos);
                        const projWidth = dist / data.throwRatio;
                        const projHeight = projWidth / proj.aspectRatio;
                        const projArea = projWidth * projHeight;
                        const lux = data.lumens / projArea;
                        const cdm2 = (lux * surface.gain / Math.PI) * facing;
                        
                        sampleCdm2 += cdm2;
                    });
                    
                    if (isHit) {
                        coveredSamples++;
                        cdm2Samples.push(sampleCdm2);
                        totalCdm2 += sampleCdm2;
                        minCdm2 = Math.min(minCdm2, sampleCdm2);
                        maxCdm2 = Math.max(maxCdm2, sampleCdm2);
                    }
                });
            });
            
            const coverage = totalSamples > 0 ? (coveredSamples / totalSamples) * 100 : 0;
            const avgCdm2 = cdm2Samples.length > 0 ? totalCdm2 / cdm2Samples.length : 0;
            
            updateCoverageDisplay(
                coverage,
                avgCdm2,
                minCdm2 === Infinity ? 0 : minCdm2,
                maxCdm2
            );
        }
        
        function updateCoverageDisplay(coverage, avgCdm2, minCdm2, maxCdm2) {
            document.getElementById('coverage-fill').style.width = coverage + '%';
            document.getElementById('coverage-percent').textContent = coverage.toFixed(1) + '%';
            document.getElementById('avg-cdm2').textContent = Math.round(avgCdm2).toLocaleString();
            document.getElementById('min-cdm2').textContent = Math.round(minCdm2).toLocaleString();
            document.getElementById('max-cdm2').textContent = Math.round(maxCdm2).toLocaleString();
        }
        
        // ==========================================
        // SELECTION & PROPERTIES
        // ==========================================
        
        function selectObject(type, id) {
            state.selectedType = type;
            state.selectedObject = id;
            updateProjectorList();
            updateSurfaceList();
            updatePropertiesPanel();
            
            // Enable/disable transform tools based on selection
            enableTransformTools(!!id);
            
            // Update gizmo position (gizmo visibility depends on current mode)
            updateGizmoPosition();
        }
        
        function buildTextureControlsHtml(p) {
            const videoData = videoTextureData.get(p.id);
            
            if (p.customTextureType === 'video' && videoData) {
                // Video controls
                const duration = videoData.video.duration || 0;
                const currentTime = videoData.video.currentTime || 0;
                const isPlaying = videoData.playing;
                const isLooping = videoData.loop;
                const resolution = videoData.resolution || 'native';
                const nativeRes = `${videoData.nativeWidth}Ã—${videoData.nativeHeight}`;
                
                return `
                    <div class="video-preview">
                        <div class="video-info">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
                            <span>Video (${nativeRes})</span>
                        </div>
                        <div class="video-controls">
                            <button class="video-btn" onclick="${isPlaying ? 'pauseVideo' : 'playVideo'}(${p.id})" title="${isPlaying ? 'Pause' : 'Play'}">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                    ${isPlaying 
                                        ? '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>' 
                                        : '<path d="M8 5v14l11-7z"/>'}
                                </svg>
                            </button>
                            <button class="video-btn" onclick="restartVideo(${p.id})" title="Restart">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                            </button>
                            <button class="video-btn ${isLooping ? 'active' : ''}" onclick="toggleVideoLoop(${p.id})" title="Loop">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
                            </button>
                        </div>
                        <div class="video-seek">
                            <input type="range" min="0" max="${duration}" step="0.1" value="${currentTime}" 
                                oninput="seekVideo(${p.id}, +this.value)" 
                                style="width: 100%;">
                            <div class="video-time">${formatTime(currentTime)} / ${formatTime(duration)}</div>
                        </div>
                        <div class="property-row" style="margin-top: 8px;">
                            <span class="property-label">Quality</span>
                            <div class="single-input">
                                <select onchange="updateVideoResolution(${p.id}, this.value)">
                                    <option value="native" ${resolution === 'native' ? 'selected' : ''}>Native (${nativeRes})</option>
                                    <option value="1080p" ${resolution === '1080p' ? 'selected' : ''}>1080p</option>
                                    <option value="720p" ${resolution === '720p' ? 'selected' : ''}>720p</option>
                                    <option value="480p" ${resolution === '480p' ? 'selected' : ''}>480p</option>
                                    <option value="360p" ${resolution === '360p' ? 'selected' : ''}>360p</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <button class="btn clear-texture-btn" onclick="clearCustomTexture(${p.id})">Clear Video</button>
                `;
            } else if (p.customTextureUrl && p.customTextureType !== 'video') {
                // Image preview
                return `
                    <div class="texture-preview" style="background-image: url('${p.customTextureUrl}')"></div>
                    <button class="btn clear-texture-btn" onclick="clearCustomTexture(${p.id})">Clear Image</button>
                `;
            } else {
                // Upload prompt
                return `
                    <div class="texture-upload" onclick="document.getElementById('tex-upload-${p.id}').click()">
                        <input type="file" id="tex-upload-${p.id}" accept="image/*,video/*" onchange="loadCustomTexture(${p.id}, this.files[0])">
                        <p>Click to upload image or video</p>
                    </div>
                `;
            }
        }
        
        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-panel');
            
            if (!state.selectedObject) {
                panel.innerHTML = `<div class="no-selection"><div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div><h3>No Selection</h3><p>Select an object to edit.</p></div>`;
                return;
            }
            
            if (state.selectedType === 'projector') {
                const p = state.projectors.find(x => x.id === state.selectedObject);
                if (!p) return;
                
                const presetOptions = Object.entries(projectorPresets).map(([key, val]) => 
                    `<option value="${key}" ${p.preset === key ? 'selected' : ''}>${val.name}</option>`
                ).join('');
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Projector</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${p.name}" onchange="updateProjectorProp(${p.id}, 'name', this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Preset</span><div class="single-input"><select onchange="applyPreset(${p.id}, this.value)">${presetOptions}</select></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${p.position.x}" onchange="updateProjectorPos(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${p.position.y}" onchange="updateProjectorPos(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${p.position.z}" onchange="updateProjectorPos(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${p.rotation.x}" onchange="updateProjectorRot(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${p.rotation.y}" onchange="updateProjectorRot(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${p.rotation.z}" onchange="updateProjectorRot(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Optics</div>
                            <div class="slider-row"><span class="slider-label">Throw Ratio</span><div class="slider-container"><input type="range" class="slider" min="0.3" max="3" step="0.05" value="${p.throwRatio}" oninput="updateProjectorProp(${p.id}, 'throwRatio', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.05" min="0.3" max="3" value="${p.throwRatio.toFixed(2)}" onchange="updateProjectorProp(${p.id}, 'throwRatio', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Zoom</span><div class="slider-container"><input type="range" class="slider" min="0.8" max="1.5" step="0.01" value="${p.zoom}" oninput="updateProjectorProp(${p.id}, 'zoom', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="0.8" max="1.5" value="${p.zoom.toFixed(2)}" onchange="updateProjectorProp(${p.id}, 'zoom', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="property-row"><span class="property-label">Lumens</span><div class="single-input"><input type="number" step="1000" value="${p.lumens}" onchange="updateProjectorProp(${p.id}, 'lumens', +this.value)"></div></div>
                            <div class="slider-row"><span class="slider-label">Brightness (%)</span><div class="slider-container"><input type="range" class="slider" min="0" max="100" step="5" value="${p.brightness || 100}" oninput="updateProjectorProp(${p.id}, 'brightness', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="5" min="0" max="100" value="${p.brightness || 100}" onchange="updateProjectorProp(${p.id}, 'brightness', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="property-row"><span class="property-label">Stack Qty</span><div class="single-input"><input type="number" step="1" min="1" max="10" value="${p.stack || 1}" onchange="updateProjectorProp(${p.id}, 'stack', +this.value)" style="width: 60px;"></div></div>
                            <div class="property-row" style="font-size: 10px; color: var(--text-muted); margin-top: -4px;"><span>Effective: ${Math.round(p.lumens * (p.brightness || 100) / 100 * (p.stack || 1))} lm</span></div>
                            <div class="property-row"><span class="property-label">Resolution</span><div class="single-input"><input type="text" value="${p.resolution || '1920Ã—1080'}" readonly style="opacity: 0.6;"></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Lens Shift</div>
                            <div class="slider-row"><span class="slider-label">Horizontal (%)</span><div class="slider-container"><input type="range" class="slider" min="-100" max="100" step="1" value="${p.lens?.shiftH || 0}" oninput="updateLensShift(${p.id}, 'shiftH', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="-100" max="100" value="${p.lens?.shiftH || 0}" onchange="updateLensShift(${p.id}, 'shiftH', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Vertical (%)</span><div class="slider-container"><input type="range" class="slider" min="-100" max="100" step="1" value="${p.lens?.shiftV || 0}" oninput="updateLensShift(${p.id}, 'shiftV', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="-100" max="100" value="${p.lens?.shiftV || 0}" onchange="updateLensShift(${p.id}, 'shiftV', +this.value); this.previousElementSibling.value=this.value"></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Lens Model</div>
                            <div class="property-row"><span class="property-label">Lens Type</span><div class="single-input"><select onchange="updateLensProp(${p.id}, 'type', this.value)">
                                <option value="rectilinear" ${(p.lens?.type || 'rectilinear') === 'rectilinear' ? 'selected' : ''}>Rectilinear (Standard)</option>
                                <option value="fisheye_equidistant" ${p.lens?.type === 'fisheye_equidistant' ? 'selected' : ''}>Fisheye - Equidistant</option>
                                <option value="fisheye_equisolid" ${p.lens?.type === 'fisheye_equisolid' ? 'selected' : ''}>Fisheye - Equisolid</option>
                                <option value="fisheye_stereographic" ${p.lens?.type === 'fisheye_stereographic' ? 'selected' : ''}>Fisheye - Stereographic</option>
                                <option value="fisheye_orthographic" ${p.lens?.type === 'fisheye_orthographic' ? 'selected' : ''}>Fisheye - Orthographic</option>
                            </select></div></div>
                            ${(p.lens?.type && p.lens.type.startsWith('fisheye')) ? `<div class="slider-row"><span class="slider-label">Fisheye FOV (Â°)</span><div class="slider-container"><input type="range" class="slider" min="90" max="220" step="5" value="${p.lens?.fisheyeFov || 180}" oninput="updateLensProp(${p.id}, 'fisheyeFov', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="5" min="90" max="220" value="${p.lens?.fisheyeFov || 180}" onchange="updateLensProp(${p.id}, 'fisheyeFov', +this.value); this.previousElementSibling.value=this.value"></div></div>` : ''}
                            <div class="slider-row"><span class="slider-label">Barrel/Pincushion (K1)</span><div class="slider-container"><input type="range" class="slider" min="-0.5" max="0.5" step="0.01" value="${p.lens?.k1 || 0}" oninput="updateLensProp(${p.id}, 'k1', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="-0.5" max="0.5" value="${(p.lens?.k1 || 0).toFixed(2)}" onchange="updateLensProp(${p.id}, 'k1', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Radial K2</span><div class="slider-container"><input type="range" class="slider" min="-0.3" max="0.3" step="0.01" value="${p.lens?.k2 || 0}" oninput="updateLensProp(${p.id}, 'k2', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="-0.3" max="0.3" value="${(p.lens?.k2 || 0).toFixed(2)}" onchange="updateLensProp(${p.id}, 'k2', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Radial K3</span><div class="slider-container"><input type="range" class="slider" min="-0.2" max="0.2" step="0.01" value="${p.lens?.k3 || 0}" oninput="updateLensProp(${p.id}, 'k3', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="-0.2" max="0.2" value="${(p.lens?.k3 || 0).toFixed(2)}" onchange="updateLensProp(${p.id}, 'k3', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Tangential P1</span><div class="slider-container"><input type="range" class="slider" min="-0.1" max="0.1" step="0.001" value="${p.lens?.p1 || 0}" oninput="updateLensProp(${p.id}, 'p1', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(3)"><input type="number" class="slider-input" step="0.001" min="-0.1" max="0.1" value="${(p.lens?.p1 || 0).toFixed(3)}" onchange="updateLensProp(${p.id}, 'p1', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Tangential P2</span><div class="slider-container"><input type="range" class="slider" min="-0.1" max="0.1" step="0.001" value="${p.lens?.p2 || 0}" oninput="updateLensProp(${p.id}, 'p2', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(3)"><input type="number" class="slider-input" step="0.001" min="-0.1" max="0.1" value="${(p.lens?.p2 || 0).toFixed(3)}" onchange="updateLensProp(${p.id}, 'p2', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <button class="btn btn-sm" style="width: 100%; margin-top: 8px;" onclick="resetLensParams(${p.id})">Reset Lens to Default</button>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">K1-K3: Radial distortion. P1-P2: Tangential.</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Body Mesh</div>
                            <div class="property-row"><span class="property-label">Size (m)</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>W</label><input type="number" step="0.05" min="0.05" value="${(p.body?.width || 0.4).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'width', +this.value)"></div>
                                    <div class="input-group"><label>H</label><input type="number" step="0.05" min="0.05" value="${(p.body?.height || 0.2).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'height', +this.value)"></div>
                                    <div class="input-group"><label>D</label><input type="number" step="0.05" min="0.05" value="${(p.body?.depth || 0.5).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'depth', +this.value)"></div>
                                </div>
                            </div>
                            <div class="property-row"><span class="property-label">Offset (m)</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.05" value="${(p.body?.offsetX || 0).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'offsetX', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.05" value="${(p.body?.offsetY || 0).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'offsetY', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.05" value="${(p.body?.offsetZ || 0).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'offsetZ', +this.value)"></div>
                                </div>
                            </div>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Offset is relative to projection origin (lens center)</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Custom Texture</div>
                            ${buildTextureControlsHtml(p)}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Range</div>
                            <div class="slider-row"><span class="slider-label">Max Distance</span><div class="slider-container"><input type="range" class="slider" min="10" max="500" step="5" value="${p.farPlane || 100}" oninput="updateProjectorProp(${p.id}, 'farPlane', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="5" min="10" max="500" value="${p.farPlane || 100}" onchange="updateProjectorProp(${p.id}, 'farPlane', +this.value); this.previousElementSibling.value=this.value">m</div></div>
                            <div class="slider-row"><span class="slider-label">Frustum Display</span><div class="slider-container"><input type="range" class="slider" min="5" max="100" step="1" value="${p.frustumDistance || 20}" oninput="updateProjectorProp(${p.id}, 'frustumDistance', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="5" max="100" value="${p.frustumDistance || 20}" onchange="updateProjectorProp(${p.id}, 'frustumDistance', +this.value); this.previousElementSibling.value=this.value">m</div></div>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Max Distance affects shadow occlusion range</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Display</div>
                            <div class="toggle-row"><span class="toggle-label">Enabled</span><div class="toggle ${p.enabled ? 'active' : ''}" onclick="toggleProjectorEnabled(${p.id})"></div></div>
                        </div>
                    </div></div>`;
            } else if (state.selectedType === 'surface') {
                const s = state.surfaces.find(x => x.id === state.selectedObject);
                if (!s) return;
                
                const isCustomOBJ = s.type === 'custom';
                
                // Build type selector HTML (hidden for custom OBJ)
                const typeHtml = isCustomOBJ 
                    ? `<div class="property-row"><span class="property-label">Type</span><div class="single-input"><input type="text" value="Custom OBJ" disabled style="opacity: 0.6"></div></div>`
                    : `<div class="property-row"><span class="property-label">Type</span><div class="single-input"><select onchange="updateSurfaceProp(${s.id}, 'type', this.value)"><option value="flat" ${s.type==='flat'?'selected':''}>Flat</option><option value="curved" ${s.type==='curved'?'selected':''}>Curved</option><option value="sphere" ${s.type==='sphere'?'selected':''}>Sphere</option><option value="cube" ${s.type==='cube'?'selected':''}>Cube</option></select></div></div>`;
                
                // Build dimensions HTML (scale for OBJ, type-specific for others)
                let dimensionsHtml;
                if (isCustomOBJ) {
                    const scale = s.scale || 1.0;
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Scale</div>
                            <div class="slider-row"><span class="slider-label">Uniform Scale</span><div class="slider-container"><input type="range" class="slider" min="0.1" max="5" step="0.1" value="${scale}" oninput="updateSurfaceScale(${s.id}, +this.value); this.nextElementSibling.value=Number(this.value).toFixed(1)"><input type="number" class="slider-input" step="0.1" min="0.1" max="10" value="${scale.toFixed(1)}" onchange="updateSurfaceScale(${s.id}, +this.value); this.previousElementSibling.value=this.value">Ã—</div></div>
                            <div class="property-row" style="opacity: 0.6"><span class="property-label">Original Size</span><div class="single-input"><input type="text" value="${s.dimensions.width.toFixed(1)}m Ã— ${s.dimensions.height.toFixed(1)}m" disabled></div></div>
                        </div>`;
                } else if (s.type === 'sphere') {
                    const radius = s.dimensions.radius || s.dimensions.width / 2 || 2;
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Radius (m)</span><div class="single-input"><input type="number" step="0.1" min="0.1" value="${radius}" onchange="updateSurfaceDim(${s.id}, 'radius', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Segments</span><div class="single-input"><input type="number" step="4" min="8" max="128" value="${s.segments || 32}" onchange="updateSurfaceProp(${s.id}, 'segments', +this.value)"></div></div>
                        </div>`;
                } else if (s.type === 'cube') {
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Width (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'width', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Height (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.height}" onchange="updateSurfaceDim(${s.id}, 'height', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Depth (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.depth || s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'depth', +this.value)"></div></div>
                        </div>`;
                } else {
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Width (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'width', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Height (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.height}" onchange="updateSurfaceDim(${s.id}, 'height', +this.value)"></div></div>
                            ${s.type === 'curved' ? `<div class="slider-row"><span class="slider-label">Curvature</span><div class="slider-container"><input type="range" class="slider" min="5" max="180" value="${s.curvature}" oninput="updateSurfaceProp(${s.id}, 'curvature', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="5" max="180" value="${s.curvature}" onchange="updateSurfaceProp(${s.id}, 'curvature', +this.value); this.previousElementSibling.value=this.value">Â°</div></div>` : ''}
                        </div>`;
                }
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Surface</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${s.name}" onchange="updateSurfaceProp(${s.id}, 'name', this.value)"></div></div>
                            ${typeHtml}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${s.position.x}" onchange="updateSurfacePos(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${s.position.y}" onchange="updateSurfacePos(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${s.position.z}" onchange="updateSurfacePos(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${s.rotation.x}" onchange="updateSurfaceRot(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${s.rotation.y}" onchange="updateSurfaceRot(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${s.rotation.z}" onchange="updateSurfaceRot(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        ${dimensionsHtml}
                        <div class="property-group">
                            <div class="property-group-title">Screen Properties</div>
                            <div class="slider-row"><span class="slider-label">Screen Gain</span><div class="slider-container"><input type="range" class="slider" min="0.5" max="2.5" step="0.1" value="${s.gain}" oninput="updateSurfaceProp(${s.id}, 'gain', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(1)"><input type="number" class="slider-input" step="0.1" min="0.5" max="2.5" value="${s.gain.toFixed(1)}" onchange="updateSurfaceProp(${s.id}, 'gain', +this.value); this.previousElementSibling.value=this.value"></div></div>
                        </div>
                    </div></div>`;
            }
        }
        
        // ==========================================
        // PROPERTY HANDLERS
        // ==========================================
        // PROPERTY HANDLERS WITH VALIDATION
        // ==========================================
        
        function updateProjectorProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Validate numeric properties
                if (prop === 'lumens') val = Math.max(100, Math.min(100000, val));
                if (prop === 'throwRatio') val = Math.max(0.3, Math.min(10, val));
                if (prop === 'zoom') val = Math.max(0.5, Math.min(2, val));
                
                p[prop] = val;
                if (prop !== 'name') p.preset = 'custom';
                updateProjectorMesh(p);
                updateProjectorList();
            }
        }
        
        function updateProjectorPos(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                saveStateForUndo(`Move ${p.name} (panel)`);
                p.position[axis] = val;
                updateProjectorMesh(p);
            }
        }
        
        function updateProjectorRot(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                saveStateForUndo(`Rotate ${p.name} (panel)`);
                p.rotation[axis] = val;
                updateProjectorMesh(p);
            }
        }
        
        function toggleProjectorEnabled(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p.enabled = !p.enabled;
                const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
                if (mesh) mesh.visible = p.enabled;
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
                calculateCoverage();
            }
        }
        
        function updateLensProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Initialize lens object if needed
                if (!p.lens) {
                    p.lens = {
                        type: 'rectilinear',
                        fisheyeFov: 180,
                        shiftH: 0, shiftV: 0,
                        k1: 0, k2: 0, k3: 0,
                        p1: 0, p2: 0,
                        cx: 0, cy: 0
                    };
                }
                p.lens[prop] = val;
                updateProjectorMatrix(p);
                // Update shadow map when fisheyeFov or type changes (affects shadow frustum)
                if (prop === 'fisheyeFov' || prop === 'type') {
                    updateShadowMap(p);
                }
                updateAllSurfaceMaterials();
                calculateCoverage();
                // Refresh panel when type changes to show/hide fisheyeFov slider
                if (prop === 'type') {
                    updatePropertiesPanel();
                }
            }
        }
        
        function updateLensShift(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                if (!p.lens) {
                    p.lens = {
                        type: 'rectilinear',
                        fisheyeFov: 180,
                        shiftH: 0, shiftV: 0,
                        k1: 0, k2: 0, k3: 0,
                        p1: 0, p2: 0,
                        cx: 0, cy: 0
                    };
                }
                // Store both the percentage value and convert to cx/cy
                p.lens[prop] = val;
                if (prop === 'shiftH') {
                    p.lens.cx = val / 50;  // Convert -100..100% to -2..2 range (for full image shift)
                } else if (prop === 'shiftV') {
                    p.lens.cy = val / 50;
                }
                updateProjectorMatrix(p);
                updateAllSurfaceMaterials();
                calculateCoverage();
            }
        }
        
        function updateBodyProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Initialize body object if needed
                if (!p.body) {
                    p.body = {
                        width: 0.4, height: 0.2, depth: 0.5,
                        offsetX: 0, offsetY: 0, offsetZ: 0
                    };
                }
                // Validate dimensions (must be positive)
                if (['width', 'height', 'depth'].includes(prop)) {
                    val = Math.max(0.05, Math.min(5, val));
                }
                // Validate offset (reasonable range)
                if (['offsetX', 'offsetY', 'offsetZ'].includes(prop)) {
                    val = Math.max(-5, Math.min(5, val));
                }
                p.body[prop] = val;
                
                // Rebuild the projector mesh
                rebuildProjectorBody(p);
            }
        }
        
        function rebuildProjectorBody(projector) {
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === projector.id);
            if (!mesh) return;
            
            // Find and remove old body and indicator
            const oldBody = mesh.children.find(c => c.userData.isProjector);
            if (oldBody) {
                if (oldBody.geometry) oldBody.geometry.dispose();
                if (oldBody.material) oldBody.material.dispose();
                mesh.remove(oldBody);
            }
            
            // Remove old indicator (cone without specific userData)
            const oldIndicator = mesh.children.find(c => c.geometry && c.geometry.type === 'ConeGeometry');
            if (oldIndicator) {
                if (oldIndicator.geometry) oldIndicator.geometry.dispose();
                if (oldIndicator.material) oldIndicator.material.dispose();
                mesh.remove(oldIndicator);
            }
            
            // Create new body with updated dimensions
            const bodyW = projector.body?.width || 0.4;
            const bodyH = projector.body?.height || 0.2;
            const bodyD = projector.body?.depth || 0.5;
            const offsetX = projector.body?.offsetX || 0;
            const offsetY = projector.body?.offsetY || 0;
            const offsetZ = projector.body?.offsetZ || 0;
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(bodyW, bodyH, bodyD),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            body.userData.isProjector = true;
            body.userData.projectorId = projector.id;
            body.position.set(offsetX, offsetY, offsetZ);
            mesh.add(body);
            
            // Create new indicator
            const indicatorSize = Math.min(bodyW, bodyH) * 0.4;
            const indicator = new THREE.Mesh(
                new THREE.ConeGeometry(indicatorSize, indicatorSize * 2.5, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            indicator.rotation.x = Math.PI / 2;
            indicator.position.y = offsetY + bodyH / 2 + indicatorSize;
            indicator.position.z = offsetZ + bodyD * 0.3;
            mesh.add(indicator);
        }
        
        function resetLensParams(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p.lens = {
                    type: 'rectilinear',
                    fisheyeFov: 180,
                    shiftH: 0, shiftV: 0,
                    k1: 0, k2: 0, k3: 0,
                    p1: 0, p2: 0,
                    cx: 0, cy: 0
                };
                updateProjectorMatrix(p);
                updateShadowMap(p);
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
                calculateCoverage();
            }
        }
        
        function updateSurfaceProp(id, prop, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                // Validate gain
                if (prop === 'gain') val = Math.max(0.1, Math.min(5, val));
                if (prop === 'curvature') val = Math.max(0, Math.min(180, val));
                if (prop === 'segments') val = Math.max(8, Math.min(128, val));
                
                // Handle type change - set appropriate default dimensions
                if (prop === 'type') {
                    if (val === 'sphere' && s.type !== 'sphere') {
                        // Switching to sphere - set radius based on current size
                        const avgSize = (s.dimensions.width + s.dimensions.height) / 2;
                        s.dimensions.radius = avgSize / 2;
                        s.segments = 32;
                    } else if (val === 'cube' && s.type !== 'cube') {
                        // Switching to cube - ensure depth is set
                        if (!s.dimensions.depth) {
                            s.dimensions.depth = s.dimensions.width;
                        }
                    }
                }
                
                s[prop] = val;
                updateSurfaceMesh(s);
                updateSurfaceList();
                updatePropertiesPanel();
            }
        }
        
        function updateSurfacePos(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                saveStateForUndo(`Move ${s.name} (panel)`);
                s.position[axis] = val;
                updateSurfaceMesh(s);
            }
        }
        
        function updateSurfaceRot(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                saveStateForUndo(`Rotate ${s.name} (panel)`);
                s.rotation[axis] = val;
                updateSurfaceMesh(s);
            }
        }
        
        function updateSurfaceDim(id, dim, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                saveStateForUndo(`Resize ${s.name}`);
                // Validate dimensions - must be positive
                val = Math.max(0.1, Math.min(100, val));
                s.dimensions[dim] = val;
                updateSurfaceMesh(s);
                updateSurfaceList();
            }
        }
        
        function updateSurfaceScale(id, scale) {
            const s = state.surfaces.find(x => x.id === id);
            if (s && s.type === 'custom') {
                // Validate scale
                scale = Math.max(0.1, Math.min(10, scale));
                s.scale = scale;
                // Update the mesh scale
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
                if (mesh) {
                    mesh.scale.setScalar(scale);
                }
                updateAllSurfaceMaterials();
                debouncedCalculateCoverage();
            }
        }
        
        // Debounced coverage calculation for better performance
        let coverageTimeout = null;
        function debouncedCalculateCoverage() {
            if (coverageTimeout) clearTimeout(coverageTimeout);
            coverageTimeout = setTimeout(calculateCoverage, 150);
        }
        
        // ==========================================
        // VIEW & OPTIONS
        // ==========================================
        
        function setView(view) {
            state.currentView = view;
            document.querySelectorAll('.view-btn:not(.pilot-btn)').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Show/hide pilot button based on view
            const pilotBtn = document.getElementById('pilot-mode-btn');
            if (view === 'projector') {
                pilotBtn.style.display = 'inline-block';
            } else {
                pilotBtn.style.display = 'none';
                // Disable pilot mode when leaving projector POV
                if (pilotMode.enabled) {
                    pilotMode.enabled = false;
                    pilotMode.projectorId = null;
                    pilotBtn.classList.remove('active');
                }
            }
            
            const views = {
                perspective: () => { camera.position.set(0, 8, -18); camera.rotation.set(0, Math.PI, 0); },
                top: () => { camera.position.set(0, 25, 0.01); camera.rotation.set(-Math.PI/2, 0, 0); },
                front: () => { camera.position.set(0, 3, -20); camera.rotation.set(0, Math.PI, 0); },
                side: () => { camera.position.set(-20, 3, 0); camera.rotation.set(0, Math.PI/2, 0); },
                projector: () => {
                    let p = null;
                    if (state.selectedType === 'projector' && state.selectedObject) {
                        p = state.projectors.find(x => x.id === state.selectedObject);
                    }
                    if (!p && state.projectors.length) p = state.projectors[0];
                    if (p) {
                        pilotMode.projectorId = p.id;
                        camera.position.set(p.position.x, p.position.y, p.position.z);
                        const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(
                            THREE.MathUtils.degToRad(p.rotation.x),
                            THREE.MathUtils.degToRad(p.rotation.y),
                            THREE.MathUtils.degToRad(p.rotation.z), 'YXZ'
                        ));
                        camera.lookAt(p.position.x + forward.x * 10, p.position.y + forward.y * 10, p.position.z + forward.z * 10);
                    }
                }
            };
            views[view]?.();
            document.getElementById('camera-info').textContent = view.charAt(0).toUpperCase() + view.slice(1);
        }
        
        function togglePilotMode() {
            pilotMode.enabled = !pilotMode.enabled;
            const pilotBtn = document.getElementById('pilot-mode-btn');
            pilotBtn.classList.toggle('active', pilotMode.enabled);
            
            if (pilotMode.enabled && pilotMode.projectorId) {
                // Save undo state before starting pilot mode
                saveUndo();
                // Select the projector we're piloting
                selectObject('projector', pilotMode.projectorId);
            }
        }
        
        // Debounce timer for pilot mode undo saves
        let pilotUndoTimer = null;
        
        function syncProjectorToCamera() {
            if (!pilotMode.enabled || !pilotMode.projectorId) return;
            
            const p = state.projectors.find(x => x.id === pilotMode.projectorId);
            if (!p) return;
            
            // Get camera position
            p.position.x = camera.position.x;
            p.position.y = camera.position.y;
            p.position.z = camera.position.z;
            
            // Get camera rotation and convert to projector rotation
            // Camera looks at -Z, projector looks at +Z
            // A 180Â° Y flip also inverts X rotation behavior
            camera.rotation.order = 'YXZ';
            // Negate X rotation because 180Â° Y flip inverts pitch direction
            p.rotation.x = -THREE.MathUtils.radToDeg(camera.rotation.x);
            // Add 180Â° to Y rotation to flip the direction
            p.rotation.y = THREE.MathUtils.radToDeg(camera.rotation.y) + 180;
            // Normalize to -180 to 180 range
            while (p.rotation.y > 180) p.rotation.y -= 360;
            while (p.rotation.y < -180) p.rotation.y += 360;
            // Negate Z rotation as well due to the flip
            p.rotation.z = -THREE.MathUtils.radToDeg(camera.rotation.z);
            
            // Update projector visuals and projection
            updateProjectorMatrix(p);
            updateProjectorMesh(p);
            updateShadowMap(p);
            updateAllSurfaceMaterials();
            updatePropertiesPanel();
            updateGizmoPosition();
            
            // Debounced undo save - save state after 500ms of no changes
            if (pilotUndoTimer) clearTimeout(pilotUndoTimer);
            pilotUndoTimer = setTimeout(() => {
                saveUndo();
                pilotUndoTimer = null;
            }, 500);
        }
        
        function toggleOption(opt) {
            state.displayOptions[opt] = !state.displayOptions[opt];
            document.getElementById(`toggle-${opt}`).classList.toggle('active', state.displayOptions[opt]);
            
            if (opt === 'frustums') projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
            else if (opt === 'grid') gridHelper.visible = state.displayOptions.grid;
            else if (opt === 'wireframe') surfaceGroup.children.forEach(m => { if (m.material) m.material.wireframe = state.displayOptions.wireframe; });
            else if (opt === 'heatmap') {
                document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) m.material.uniforms.showHeatmap.value = state.displayOptions.heatmap;
                });
            }
            else if (opt === 'coverage' || opt === 'overlap') {
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) {
                        m.material.uniforms.showCoverage.value = state.displayOptions.coverage;
                        m.material.uniforms.showOverlap.value = state.displayOptions.overlap;
                    }
                });
            }
            else if (opt === 'distance') {
                updateDistanceHelpers();
            }
        }
        
        // Debug mode: visualize lens type and rejection reasons
        let debugLensTypeEnabled = false;
        function toggleDebugLensType() {
            debugLensTypeEnabled = !debugLensTypeEnabled;
            surfaceGroup.children.forEach(m => {
                if (m.material?.uniforms?.debugLensType) {
                    m.material.uniforms.debugLensType.value = debugLensTypeEnabled;
                }
            });
            showToast(debugLensTypeEnabled ? 
                'Debug Mode ON: Green=Rectilinear, Blue=Fisheye, Dark colors=rejection reasons (Ctrl+D to toggle)' : 
                'Debug Mode OFF');
        }
        
        function updateDistanceHelpers() {
            // Clear existing helpers
            while (distanceHelperGroup.children.length > 0) {
                const child = distanceHelperGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                distanceHelperGroup.remove(child);
            }
            
            // Remove any existing labels
            document.querySelectorAll('.distance-label').forEach(el => el.remove());
            
            if (!state.displayOptions.distance) return;
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            if (enabledProjectors.length === 0 || surfaceGroup.children.length === 0) return;
            
            enabledProjectors.forEach(proj => {
                // Get projector world position and direction
                const projMesh = projectorGroup.children.find(c => c.userData.projectorId === proj.id);
                if (!projMesh) return;
                
                const projPos = new THREE.Vector3(proj.position.x, proj.position.y, proj.position.z);
                
                // Calculate forward direction from rotation
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(proj.rotation.x),
                    THREE.MathUtils.degToRad(proj.rotation.y),
                    THREE.MathUtils.degToRad(proj.rotation.z),
                    'YXZ'
                );
                const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                
                // Raycast from projector center to find nearest surface
                const raycaster = new THREE.Raycaster(projPos, forward, 0.1, proj.farPlane || 100);
                const intersects = raycaster.intersectObjects(surfaceGroup.children, false);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const distance = hit.distance;
                    
                    // Create line from projector to hit point
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([projPos, hit.point]);
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00, 
                        transparent: true, 
                        opacity: 0.8,
                        depthTest: false
                    });
                    const line = new THREE.Line(lineGeom, lineMat);
                    line.renderOrder = 999;
                    distanceHelperGroup.add(line);
                    
                    // Create a small sphere at the hit point
                    const sphereGeom = new THREE.SphereGeometry(0.05, 8, 8);
                    const sphereMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
                    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                    sphere.position.copy(hit.point);
                    sphere.renderOrder = 999;
                    distanceHelperGroup.add(sphere);
                    
                    // Create HTML label for distance
                    const label = document.createElement('div');
                    label.className = 'distance-label';
                    label.innerHTML = `
                        <strong>${proj.name}</strong><br>
                        ${distance.toFixed(2)}m
                    `;
                    label.dataset.projectorId = proj.id;
                    document.querySelector('.viewport').appendChild(label);
                    
                    // Store hit point for label positioning in animate loop
                    label.hitPoint = hit.point.clone();
                    label.midPoint = projPos.clone().add(hit.point).multiplyScalar(0.5);
                }
            });
        }
        
        function updateHeatmapMax(value) {
            state.heatmapMax = value;
            document.getElementById('legend-mid').textContent = Math.round(value / 2);
            document.getElementById('legend-max').textContent = value + '+';
            
            // Update all surface materials with new heatmap max
            surfaceGroup.children.forEach(m => {
                if (m.material?.uniforms?.heatmapMax) {
                    m.material.uniforms.heatmapMax.value = value;
                }
            });
        }
        
        function setPattern(pattern) {
            state.currentPattern = pattern;
            document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Reset scroll offset when changing pattern
            patternScrollState.offset = { x: 0, y: 0 };
            
            updateAllSurfaceMaterials();
        }
        
        function togglePatternScroll() {
            patternScrollState.enabled = !patternScrollState.enabled;
            document.getElementById('toggle-pattern-scroll').classList.toggle('active', patternScrollState.enabled);
            
            // Reset offset when disabling
            if (!patternScrollState.enabled) {
                patternScrollState.offset = { x: 0, y: 0 };
                // Reset shader uniforms on all surfaces
                surfaceGroup.children.forEach(mesh => {
                    if (mesh.material && mesh.material.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (mesh.material.uniforms[`texOffset${i}`]) {
                                mesh.material.uniforms[`texOffset${i}`].value.set(0, 0);
                            }
                        }
                    }
                });
            }
        }
        
        function updatePatternScrollSpeed(speed) {
            patternScrollState.speed = speed;
        }
        
        function updatePatternScrollDirection(direction) {
            patternScrollState.direction = direction;
        }
        
        // ==========================================
        // UTILITY
        // ==========================================
        
        function updateStatus() {
            const enabledCount = state.projectors.filter(p => p.enabled).length;
            const activeCount = Math.min(enabledCount, 8);
            let projText = state.projectors.length + ' Projector' + (state.projectors.length !== 1 ? 's' : '');
            if (enabledCount > 0) {
                projText += ` (${activeCount}/${enabledCount} active)`;
            }
            if (enabledCount > 8) {
                projText += ' âš ï¸';
            }
            document.getElementById('projector-status').textContent = projText;
            document.getElementById('surface-status').textContent = state.surfaces.length + ' Surface' + (state.surfaces.length !== 1 ? 's' : '');
        }
        
        function resetScene() {
            while (projectorGroup.children.length) projectorGroup.remove(projectorGroup.children[0]);
            while (surfaceGroup.children.length) { const m = surfaceGroup.children[0]; m.material?.dispose(); m.geometry?.dispose(); surfaceGroup.remove(m); }
            
            // Clean up video textures
            videoTextureData.forEach((videoData) => {
                if (videoData.updateInterval) clearInterval(videoData.updateInterval);
                videoData.video.pause();
                videoData.video.src = '';
                if (videoData.texture) videoData.texture.dispose();
            });
            videoTextureData.clear();
            
            state.projectors = []; state.surfaces = []; state.selectedObject = null; state.selectedType = null;
            projectorMatrixData.clear(); projectionTextures.clear(); customTextureData.clear();
            updateProjectorList(); updateSurfaceList(); updatePropertiesPanel(); updateStatus();
            updateCoverageDisplay(0, 0, 0, 0);
            
            // Clear undo history (old IDs no longer valid)
            undoHistory.length = 0;
            
            // Reset transform tools
            enableTransformTools(false);
            setTransformMode('select');
            if (gizmoGroup) gizmoGroup.visible = false;
        }
        
        // ==========================================
        // IMPORT / EXPORT
        // ==========================================
        
        const exportOptions = {
            projectors: true,
            surfaces: true,
            settings: true,
            textures: false,
            format: 'json'  // 'json' or 'csv'
        };
        
        const importOptions = {
            replace: true,
            merge: false
        };
        
        let pendingImportData = null;
        let pendingImportFormat = 'json';  // 'json' or 'csv'
        
        function setExportFormat(format) {
            exportOptions.format = format;
            
            // Update button states
            document.getElementById('export-format-json').classList.toggle('btn-primary', format === 'json');
            document.getElementById('export-format-json').classList.toggle('btn', format !== 'json');
            document.getElementById('export-format-csv').classList.toggle('btn-primary', format === 'csv');
            document.getElementById('export-format-csv').classList.toggle('btn', format !== 'csv');
            document.getElementById('export-format-obj').classList.toggle('btn-primary', format === 'obj');
            document.getElementById('export-format-obj').classList.toggle('btn', format !== 'obj');
            
            // Show/hide appropriate options
            document.getElementById('json-export-options').style.display = format === 'json' ? 'block' : 'none';
            document.getElementById('csv-export-options').style.display = format === 'csv' ? 'block' : 'none';
            document.getElementById('obj-export-options').style.display = format === 'obj' ? 'block' : 'none';
            
            // Update counts
            if (format === 'csv') {
                document.getElementById('csv-export-projector-count').textContent = state.projectors.length;
            } else if (format === 'obj') {
                document.getElementById('obj-export-surface-count').textContent = state.surfaces.length;
            }
        }
        
        // ==========================================
        // COORDINATE SYSTEM TRANSFORMS
        // ==========================================
        // disguise: X=right, Y=forward (toward stage), Z=up (Z-up, right-handed)
        // Three.js/Our scene: X=right, Y=up, Z=forward (Y-up, right-handed)
        //
        // Position transform (swap Y and Z):
        //   Three.js X = disguise X
        //   Three.js Y = disguise Z (up)
        //   Three.js Z = disguise Y (forward)
        //
        // Rotation transform:
        //   disguise: Pitch=around X, Yaw=around Z, Roll=around Y
        //   Three.js: X=pitch, Y=yaw, Z=roll
        //
        //   - Pitch: NEGATE (disguise negative=down, Three.js positive=down)
        //   - Yaw: NEGATE (disguise CW+, Three.js CCW+)
        //   - Roll: unchanged
        
        function disguisePosToThreeJS(pos) {
            return {
                x: pos.x,
                y: pos.z,        // Z (up) â†’ Y
                z: pos.y         // Y (forward) â†’ Z
            };
        }
        
        function threeJSPosToDisguise(pos) {
            return {
                x: pos.x,
                y: pos.z,        // Z â†’ Y (forward)
                z: pos.y         // Y â†’ Z (up)
            };
        }
        
        function disguiseRotToThreeJS(rot) {
            // rot = { pitch, yaw, roll } in degrees
            return {
                x: -rot.pitch,   // NEGATE: opposite tilt convention
                y: -rot.yaw,     // NEGATE: CW to CCW conversion
                z: rot.roll
            };
        }
        
        function threeJSRotToDisguise(rot) {
            // rot = { x, y, z } in degrees
            return {
                pitch: -rot.x,   // NEGATE: opposite tilt convention
                yaw: -rot.y,     // NEGATE: CCW to CW conversion
                roll: rot.z
            };
        }
        
        function disguiseToThreeJS(pos, rot) {
            return {
                position: disguisePosToThreeJS(pos),
                rotation: disguiseRotToThreeJS(rot)
            };
        }
        
        function threeJSToDisguise(pos, rot) {
            return {
                position: threeJSPosToDisguise(pos),
                rotation: threeJSRotToDisguise(rot)
            };
        }
        
        // Export to disguise-compatible CSV format
        function exportToCSV() {
            const headers = [
                'Projector_Name',
                'Projector_Qte(Stack)',
                'Projector_Native-Rez-X',
                'Projector_Native-Rez-Y',
                'Projector_Lumens(lux)',
                'Projector_Brightness(%)',
                'Projector_Total_Lumens(lux)',
                'Projector_Trow-Ratio',
                'Lens_Shift-H(%)',
                'Lens_Shift-V(%)',
                'Lens_X',
                'Lens_Y',
                'Lens_Z',
                'Pitch(deg)',
                'Yaw(deg)',
                'Roll(deg)',
                'Target_X',
                'Target_Y',
                'Target_Z',
                'Target_Distance',
                'Target_Width',
                'Target_Height',
                'Target_Illuminance',
                'Target_DPI',
                'Unit_Dim',
                'Unit_Illuminance',
                'Projector_UUID'
            ];
            
            const rows = state.projectors.map(p => {
                const metrics = calculateProjectorMetrics(p);
                const resParts = p.resolution.split('Ã—');
                const resX = parseInt(resParts[0]) || 1920;
                const resY = parseInt(resParts[1]) || 1080;
                
                // Calculate target point in Three.js space (project forward from projector)
                // In our system, +Z is forward (projector optical axis)
                const targetDist = p.frustumDistance || 20;
                
                // Use Euler to get forward direction, consistent with rest of codebase
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(p.rotation.x),
                    THREE.MathUtils.degToRad(p.rotation.y),
                    THREE.MathUtils.degToRad(p.rotation.z),
                    'YXZ'
                );
                const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                
                const targetThreeJS = {
                    x: p.position.x + forward.x * targetDist,
                    y: p.position.y + forward.y * targetDist,
                    z: p.position.z + forward.z * targetDist
                };
                
                // Transform Three.js coordinates to disguise coordinates
                const disguisePos = threeJSPosToDisguise(p.position);
                const disguiseRot = threeJSRotToDisguise(p.rotation);
                const disguiseTarget = threeJSPosToDisguise(targetThreeJS);
                
                return [
                    p.name,
                    p.stack || 1,
                    resX,
                    resY,
                    p.lumens,
                    p.brightness || 100,
                    metrics.effectiveLumens,
                    p.throwRatio,
                    p.lens?.shiftH || 0,
                    p.lens?.shiftV || 0,
                    disguisePos.x.toFixed(3),
                    disguisePos.y.toFixed(3),
                    disguisePos.z.toFixed(3),
                    disguiseRot.pitch.toFixed(8),
                    disguiseRot.yaw.toFixed(8),
                    disguiseRot.roll.toFixed(8),
                    disguiseTarget.x.toFixed(3),
                    disguiseTarget.y.toFixed(3),
                    disguiseTarget.z.toFixed(3),
                    metrics.distance.toFixed(3),
                    metrics.width.toFixed(3),
                    metrics.height.toFixed(3),
                    Math.round(metrics.illuminance),
                    metrics.dpi.toFixed(2),
                    'm',
                    'lux',
                    p.uuid || generateUUID()
                ].join(',');
            });
            
            return [headers.join(','), ...rows].join('\n');
        }
        
        // Export all surfaces to OBJ format
        function exportToOBJ() {
            let objContent = '# Projection Studio OBJ Export\n';
            objContent += `# Generated: ${new Date().toISOString()}\n`;
            objContent += `# Surfaces: ${state.surfaces.length}\n\n`;
            
            let vertexOffset = 0;
            let uvOffset = 0;
            let normalOffset = 0;
            
            state.surfaces.forEach(surface => {
                // Find the mesh for this surface
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (!mesh || !mesh.geometry) return;
                
                // Get the geometry in world coordinates
                const geometry = mesh.geometry.clone();
                mesh.updateMatrixWorld();
                geometry.applyMatrix4(mesh.matrixWorld);
                
                // Ensure we have the attributes
                if (!geometry.attributes.position) return;
                
                const positions = geometry.attributes.position.array;
                const uvs = geometry.attributes.uv ? geometry.attributes.uv.array : null;
                const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
                const indices = geometry.index ? geometry.index.array : null;
                
                // Clean the surface name for OBJ (remove special chars)
                const cleanName = surface.name.replace(/[^a-zA-Z0-9_-]/g, '_');
                objContent += `# Surface: ${surface.name}\n`;
                objContent += `o ${cleanName}\n`;
                
                // Write vertices
                const vertexCount = positions.length / 3;
                for (let i = 0; i < vertexCount; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];
                    objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
                }
                
                // Write texture coordinates
                if (uvs) {
                    const uvCount = uvs.length / 2;
                    for (let i = 0; i < uvCount; i++) {
                        const u = uvs[i * 2];
                        const v = uvs[i * 2 + 1];
                        objContent += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
                    }
                }
                
                // Write normals
                if (normals) {
                    const normalCount = normals.length / 3;
                    for (let i = 0; i < normalCount; i++) {
                        const nx = normals[i * 3];
                        const ny = normals[i * 3 + 1];
                        const nz = normals[i * 3 + 2];
                        objContent += `vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n`;
                    }
                }
                
                // Write faces
                if (indices) {
                    // Indexed geometry
                    const faceCount = indices.length / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const a = indices[i * 3] + 1 + vertexOffset;
                        const b = indices[i * 3 + 1] + 1 + vertexOffset;
                        const c = indices[i * 3 + 2] + 1 + vertexOffset;
                        
                        if (uvs && normals) {
                            const ua = indices[i * 3] + 1 + uvOffset;
                            const ub = indices[i * 3 + 1] + 1 + uvOffset;
                            const uc = indices[i * 3 + 2] + 1 + uvOffset;
                            const na = indices[i * 3] + 1 + normalOffset;
                            const nb = indices[i * 3 + 1] + 1 + normalOffset;
                            const nc = indices[i * 3 + 2] + 1 + normalOffset;
                            objContent += `f ${a}/${ua}/${na} ${b}/${ub}/${nb} ${c}/${uc}/${nc}\n`;
                        } else if (uvs) {
                            const ua = indices[i * 3] + 1 + uvOffset;
                            const ub = indices[i * 3 + 1] + 1 + uvOffset;
                            const uc = indices[i * 3 + 2] + 1 + uvOffset;
                            objContent += `f ${a}/${ua} ${b}/${ub} ${c}/${uc}\n`;
                        } else {
                            objContent += `f ${a} ${b} ${c}\n`;
                        }
                    }
                } else {
                    // Non-indexed geometry (triangles)
                    const faceCount = vertexCount / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const a = i * 3 + 1 + vertexOffset;
                        const b = i * 3 + 2 + vertexOffset;
                        const c = i * 3 + 3 + vertexOffset;
                        
                        if (uvs && normals) {
                            objContent += `f ${a}/${a - vertexOffset + uvOffset}/${a - vertexOffset + normalOffset} ${b}/${b - vertexOffset + uvOffset}/${b - vertexOffset + normalOffset} ${c}/${c - vertexOffset + uvOffset}/${c - vertexOffset + normalOffset}\n`;
                        } else if (uvs) {
                            objContent += `f ${a}/${a - vertexOffset + uvOffset} ${b}/${b - vertexOffset + uvOffset} ${c}/${c - vertexOffset + uvOffset}\n`;
                        } else {
                            objContent += `f ${a} ${b} ${c}\n`;
                        }
                    }
                }
                
                // Update offsets for next object
                vertexOffset += vertexCount;
                if (uvs) uvOffset += uvs.length / 2;
                if (normals) normalOffset += normals.length / 3;
                
                objContent += '\n';
                
                // Clean up cloned geometry
                geometry.dispose();
            });
            
            return objContent;
        }
        
        // Parse disguise CSV format
        function parseDisguiseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header and at least one data row');
            }
            
            const headers = lines[0].split(',').map(h => h.trim());
            const projectors = [];
            
            // Map header names to indices
            const headerMap = {};
            headers.forEach((h, i) => headerMap[h] = i);
            
            // Helper to get value by header name
            const getValue = (row, header, defaultVal = 0) => {
                const idx = headerMap[header];
                if (idx === undefined || idx >= row.length) return defaultVal;
                const val = row[idx];
                return val === '' ? defaultVal : val;
            };
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Parse CSV line (handle potential commas in quoted fields)
                const row = line.split(',').map(v => v.trim());
                
                const name = getValue(row, 'Projector_Name', `Projector ${i}`);
                const resX = parseInt(getValue(row, 'Projector_Native-Rez-X', 1920));
                const resY = parseInt(getValue(row, 'Projector_Native-Rez-Y', 1080));
                
                // Raw disguise coordinates (Z-up system)
                const disguisePos = {
                    x: parseFloat(getValue(row, 'Lens_X', 0)),
                    y: parseFloat(getValue(row, 'Lens_Y', 0)),
                    z: parseFloat(getValue(row, 'Lens_Z', 2.5))
                };
                const disguiseRot = {
                    pitch: parseFloat(getValue(row, 'Pitch(deg)', 0)),
                    yaw: parseFloat(getValue(row, 'Yaw(deg)', 0)),
                    roll: parseFloat(getValue(row, 'Roll(deg)', 0))
                };
                const disguiseTarget = {
                    x: parseFloat(getValue(row, 'Target_X', 0)),
                    y: parseFloat(getValue(row, 'Target_Y', 0)),
                    z: parseFloat(getValue(row, 'Target_Z', 0))
                };
                
                // Transform from disguise (Z-up) to Three.js (Y-up)
                // disguise: X=right, Y=forward, Z=up
                // Three.js: X=right, Y=up, Z=towards camera
                const transformed = disguiseToThreeJS(disguisePos, disguiseRot);
                const transformedTarget = disguisePosToThreeJS(disguiseTarget);
                
                const projector = {
                    id: Date.now() + Math.random() * 1000,
                    uuid: getValue(row, 'Projector_UUID', generateUUID()),
                    name: name,
                    preset: 'custom',
                    position: transformed.position,
                    rotation: transformed.rotation,
                    lumens: parseFloat(getValue(row, 'Projector_Lumens(lux)', 10000)),
                    brightness: parseFloat(getValue(row, 'Projector_Brightness(%)', 100)),
                    stack: parseInt(getValue(row, 'Projector_Qte(Stack)', 1)),
                    throwRatio: parseFloat(getValue(row, 'Projector_Trow-Ratio', 1.5)),
                    aspectRatio: resX / resY,
                    resolution: `${resX}Ã—${resY}`,
                    zoom: 1.0,
                    enabled: true,
                    customTextureUrl: null,
                    nearPlane: 0.1,
                    farPlane: 100,
                    frustumDistance: parseFloat(getValue(row, 'Target_Distance', 20)),
                    lens: {
                        type: 'rectilinear',
                        fisheyeFov: 180,
                        shiftH: parseFloat(getValue(row, 'Lens_Shift-H(%)', 0)),
                        shiftV: parseFloat(getValue(row, 'Lens_Shift-V(%)', 0)),
                        k1: 0, k2: 0, k3: 0,
                        p1: 0, p2: 0,
                        cx: parseFloat(getValue(row, 'Lens_Shift-H(%)', 0)) / 50,
                        cy: parseFloat(getValue(row, 'Lens_Shift-V(%)', 0)) / 50
                    },
                    target: transformedTarget
                };
                
                projectors.push(projector);
            }
            
            return { projectors, surfaces: [] };
        }
        
        function showExportModal() {
            // Check if session is valid, otherwise request authentication
            if (!isSessionValid()) {
                requestAuthentication(_showExportModalInternal);
                return;
            }
            _showExportModalInternal();
        }
        
        function _showExportModalInternal() {
            // Update counts
            document.getElementById('export-projector-count').textContent = 
                `${state.projectors.length} projector${state.projectors.length !== 1 ? 's' : ''} with settings`;
            
            // Show surface count with custom OBJ info
            const customObjCount = state.surfaces.filter(s => s.type === 'custom' && s.objData).length;
            let surfaceText = `${state.surfaces.length} surface${state.surfaces.length !== 1 ? 's' : ''} with settings`;
            if (customObjCount > 0) {
                surfaceText += ` (${customObjCount} custom OBJ)`;
            }
            document.getElementById('export-surface-count').textContent = surfaceText;
            
            const imageCount = state.projectors.filter(p => p.customTextureUrl && p.customTextureType !== 'video').length;
            const videoCount = state.projectors.filter(p => p.customTextureType === 'video').length;
            let textureText = imageCount > 0 
                ? `${imageCount} image${imageCount !== 1 ? 's' : ''} (increases file size)` 
                : 'No image textures';
            if (videoCount > 0) {
                textureText += ` â€¢ ${videoCount} video${videoCount !== 1 ? 's' : ''} (not exportable)`;
            }
            document.getElementById('export-texture-count').textContent = textureText;
            
            // Set default filename with timestamp
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`;
            document.getElementById('export-filename').value = `projection-config-${timestamp}`;
            
            // Reset format selection to JSON
            exportOptions.format = 'json';
            setExportFormat('json');
            
            document.getElementById('export-modal').classList.add('active');
        }
        
        function toggleExportOption(option) {
            exportOptions[option] = !exportOptions[option];
            const checkbox = document.getElementById(`export-check-${option}`);
            checkbox.classList.toggle('checked', exportOptions[option]);
        }
        
        function toggleImportOption(option) {
            // Radio-button behavior for replace/merge
            if (option === 'replace') {
                importOptions.replace = true;
                importOptions.merge = false;
            } else if (option === 'merge') {
                importOptions.replace = false;
                importOptions.merge = true;
            }
            
            document.getElementById('import-check-replace').classList.toggle('checked', importOptions.replace);
            document.getElementById('import-check-merge').classList.toggle('checked', importOptions.merge);
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            if (id === 'import-modal') {
                pendingImportData = null;
            }
        }
        
        function toggleContactPanel() {
            const panel = document.getElementById('contact-panel');
            panel.classList.toggle('active');
            
            // Close when clicking outside
            if (panel.classList.contains('active')) {
                setTimeout(() => {
                    document.addEventListener('click', closeContactPanelOutside);
                }, 10);
            }
        }
        
        function closeContactPanelOutside(e) {
            const panel = document.getElementById('contact-panel');
            const wrapper = e.target.closest('.contact-wrapper');
            if (!wrapper && panel.classList.contains('active')) {
                panel.classList.remove('active');
                document.removeEventListener('click', closeContactPanelOutside);
            }
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            
            toastMessage.textContent = message;
            toast.className = `toast ${type} active`;
            
            // Update icon based on type
            const svg = toast.querySelector('svg');
            if (type === 'success') {
                svg.innerHTML = '<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>';
            } else if (type === 'error') {
                svg.innerHTML = '<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>';
            }
            
            setTimeout(() => {
                toast.classList.remove('active');
            }, 3000);
        }
        
        function doExport() {
            const filename = document.getElementById('export-filename').value.trim() || 'projection-config';
            
            // CSV Export
            if (exportOptions.format === 'csv') {
                const csvContent = exportToCSV();
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                closeModal('export-modal');
                showToast(`Exported "${filename}.csv" (disguise format) successfully`);
                return;
            }
            
            // OBJ Export
            if (exportOptions.format === 'obj') {
                const objContent = exportToOBJ();
                const blob = new Blob([objContent], { type: 'text/plain;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.obj`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                closeModal('export-modal');
                showToast(`Exported "${filename}.obj" (${state.surfaces.length} surfaces) successfully`);
                return;
            }
            
            // JSON Export
            const config = {
                version: '2.8',
                exportDate: new Date().toISOString(),
                metadata: {
                    projectorCount: state.projectors.length,
                    surfaceCount: state.surfaces.length
                }
            };
            
            if (exportOptions.projectors) {
                config.projectors = state.projectors.map(p => {
                    const proj = { ...p };
                    // Ensure UUID exists
                    if (!proj.uuid) proj.uuid = generateUUID();
                    // Skip video textures (can't be embedded)
                    if (p.customTextureType === 'video') {
                        proj.customTextureUrl = null;
                        proj.customTextureType = null;
                        proj.videoResolution = null;
                    } else if (!exportOptions.textures) {
                        proj.customTextureUrl = null;
                        proj.customTextureType = null;
                    }
                    return proj;
                });
            }
            
            if (exportOptions.surfaces) {
                config.surfaces = state.surfaces.map(s => ({
                    id: s.id,
                    name: s.name,
                    type: s.type,
                    position: { ...s.position },
                    rotation: { ...s.rotation },
                    dimensions: { ...s.dimensions },
                    curvature: s.curvature,
                    segments: s.segments || 32,  // For sphere surfaces
                    color: s.color,
                    gain: s.gain,
                    scale: s.scale || 1.0,
                    objData: s.objData || null // Include custom OBJ data
                }));
            }
            
            if (exportOptions.settings) {
                config.settings = {
                    currentPattern: state.currentPattern,
                    displayOptions: { ...state.displayOptions },
                    heatmapMax: state.heatmapMax,
                    currentView: state.currentView
                };
            }
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeModal('export-modal');
            showToast(`Exported "${filename}.json" successfully`);
        }
        
        function importConfig(file) {
            if (!file) return;
            
            const isCSV = file.name.toLowerCase().endsWith('.csv');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    
                    if (isCSV) {
                        // Parse CSV (disguise format)
                        data = parseDisguiseCSV(e.target.result);
                        pendingImportFormat = 'csv';
                        
                        // Update preview for CSV
                        document.getElementById('import-version').textContent = 'disguise CSV';
                        document.getElementById('import-projectors').textContent = 
                            `${data.projectors.length} projector${data.projectors.length !== 1 ? 's' : ''}`;
                        document.getElementById('import-surfaces').textContent = 'None (CSV only contains projectors)';
                        document.getElementById('import-textures').textContent = 'None';
                        document.getElementById('import-settings').textContent = 'Not included';
                    } else {
                        // Parse JSON
                        data = JSON.parse(e.target.result);
                        pendingImportFormat = 'json';
                        
                        // Update preview for JSON
                        document.getElementById('import-version').textContent = data.version || 'Unknown';
                        document.getElementById('import-projectors').textContent = 
                            data.projectors ? `${data.projectors.length} projector${data.projectors.length !== 1 ? 's' : ''}` : 'None';
                        
                        // Show surface count with custom OBJ info
                        const customObjCount = data.surfaces ? data.surfaces.filter(s => s.type === 'custom' && s.objData).length : 0;
                        let surfaceText = data.surfaces ? `${data.surfaces.length} surface${data.surfaces.length !== 1 ? 's' : ''}` : 'None';
                        if (customObjCount > 0) {
                            surfaceText += ` (${customObjCount} custom OBJ)`;
                        }
                        document.getElementById('import-surfaces').textContent = surfaceText;
                        
                        const imageCount = data.projectors ? data.projectors.filter(p => p.customTextureUrl && p.customTextureType !== 'video').length : 0;
                        document.getElementById('import-textures').textContent = 
                            imageCount > 0 ? `${imageCount} image${imageCount !== 1 ? 's' : ''} embedded` : 'None';
                        
                        document.getElementById('import-settings').textContent = 
                            data.settings ? 'Included' : 'Not included';
                    }
                    
                    pendingImportData = data;
                    
                    // Show modal
                    document.getElementById('import-modal').classList.add('active');
                    
                    // Clear file input so same file can be selected again
                    document.getElementById('import-file').value = '';
                    
                } catch (err) {
                    showToast(`Error parsing file: ${isCSV ? 'Invalid CSV format' : 'Invalid JSON format'}`, 'error');
                    console.error('Import error:', err);
                }
            };
            reader.onerror = function() {
                showToast('Error reading file', 'error');
            };
            reader.readAsText(file);
        }
        
        function doImport() {
            if (!pendingImportData) {
                showToast('No import data available', 'error');
                return;
            }
            
            const data = pendingImportData;
            
            // Clear scene if replacing
            if (importOptions.replace) {
                resetScene();
            }
            
            let importedProjectors = 0;
            let importedSurfaces = 0;
            
            // Import projectors
            if (data.projectors && Array.isArray(data.projectors)) {
                data.projectors.forEach(projData => {
                    const id = Date.now() + Math.random() * 1000;
                    const projector = {
                        id,
                        uuid: projData.uuid || generateUUID(),
                        name: projData.name || `Projector ${state.projectors.length + 1}`,
                        preset: projData.preset || 'custom',
                        position: projData.position || { x: 0, y: 4, z: -8 },
                        rotation: projData.rotation || { x: -10, y: 0, z: 0 },
                        lumens: projData.lumens || 10000,
                        brightness: projData.brightness || 100,
                        stack: projData.stack || 1,
                        throwRatio: projData.throwRatio || 1.5,
                        aspectRatio: projData.aspectRatio || 16/9,
                        resolution: projData.resolution || '1920Ã—1080',
                        zoom: projData.zoom || 1.0,
                        enabled: projData.enabled !== false,
                        customTextureUrl: projData.customTextureUrl || null,
                        customTextureType: projData.customTextureType || null,
                        videoResolution: projData.videoResolution || null,
                        nearPlane: projData.nearPlane || 0.1,
                        farPlane: projData.farPlane || 100,
                        frustumDistance: projData.frustumDistance || 20,
                        lens: projData.lens ? {
                            type: projData.lens.type || 'rectilinear',
                            fisheyeFov: projData.lens.fisheyeFov || 180,
                            shiftH: projData.lens.shiftH || 0,
                            shiftV: projData.lens.shiftV || 0,
                            k1: projData.lens.k1 || 0,
                            k2: projData.lens.k2 || 0,
                            k3: projData.lens.k3 || 0,
                            p1: projData.lens.p1 || 0,
                            p2: projData.lens.p2 || 0,
                            cx: projData.lens.cx || (projData.lens.shiftH || 0) / 50,
                            cy: projData.lens.cy || (projData.lens.shiftV || 0) / 50
                        } : {
                            type: 'rectilinear',
                            fisheyeFov: 180,
                            shiftH: 0, shiftV: 0,
                            k1: 0, k2: 0, k3: 0,
                            p1: 0, p2: 0,
                            cx: 0, cy: 0
                        },
                        body: projData.body ? {
                            width: projData.body.width || 0.4,
                            height: projData.body.height || 0.2,
                            depth: projData.body.depth || 0.5,
                            offsetX: projData.body.offsetX || 0,
                            offsetY: projData.body.offsetY || 0,
                            offsetZ: projData.body.offsetZ || 0
                        } : {
                            width: 0.4, height: 0.2, depth: 0.5,
                            offsetX: 0, offsetY: 0, offsetZ: 0
                        },
                        target: projData.target || null
                    };
                    
                    state.projectors.push(projector);
                    createProjectorMesh(projector);
                    
                    // Load custom texture if present (only images, not videos)
                    if (projector.customTextureUrl && projector.customTextureType !== 'video') {
                        const img = new Image();
                        img.onload = function() {
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            customTextureData.set(projector.id, texture);
                            projectionTextures.set(projector.id, texture);
                            updateAllSurfaceMaterials();
                        };
                        img.src = projector.customTextureUrl;
                    } else if (projector.customTextureType === 'video') {
                        // Video textures can't be embedded - clear the reference
                        projector.customTextureUrl = null;
                        projector.customTextureType = null;
                        projector.videoResolution = null;
                    }
                    
                    updateProjectorMatrix(projector);
                    updateShadowMap(projector);  // Create shadow map for imported projector
                    importedProjectors++;
                });
            }
            
            // Import surfaces
            if (data.surfaces && Array.isArray(data.surfaces)) {
                data.surfaces.forEach(surfData => {
                    const id = Date.now() + Math.random() * 1000;
                    const surface = {
                        id,
                        name: surfData.name || `Surface ${state.surfaces.length + 1}`,
                        type: surfData.type || 'flat',
                        position: surfData.position || { x: 0, y: 3, z: 5 },
                        rotation: surfData.rotation || { x: 0, y: 180, z: 0 },
                        dimensions: surfData.dimensions || { width: 8, height: 4.5 },
                        curvature: surfData.curvature || 30,
                        segments: surfData.segments || 32,  // For sphere surfaces
                        color: surfData.color || '#555555',
                        gain: surfData.gain || 1.0,
                        scale: surfData.scale || 1.0,
                        objData: surfData.objData || null // Preserve custom OBJ data
                    };
                    
                    state.surfaces.push(surface);
                    createSurfaceMesh(surface);
                    importedSurfaces++;
                });
            }
            
            // Import settings
            if (data.settings) {
                if (data.settings.currentPattern) {
                    state.currentPattern = data.settings.currentPattern;
                    document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                    // Try to activate the right pattern button
                    const patternBtns = document.querySelectorAll('.pattern-btn');
                    const patterns = ['none', 'grid', 'checker', 'gradient', 'colorbars', 'cross', 'white', 'blend'];
                    const idx = patterns.indexOf(data.settings.currentPattern);
                    if (idx >= 0 && patternBtns[idx]) patternBtns[idx].classList.add('active');
                }
                
                if (data.settings.displayOptions) {
                    Object.keys(data.settings.displayOptions).forEach(key => {
                        if (state.displayOptions.hasOwnProperty(key)) {
                            state.displayOptions[key] = data.settings.displayOptions[key];
                            const toggle = document.getElementById(`toggle-${key}`);
                            if (toggle) toggle.classList.toggle('active', state.displayOptions[key]);
                        }
                    });
                    
                    // Apply display options
                    projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
                    gridHelper.visible = state.displayOptions.grid;
                    document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                }
                
                if (data.settings.heatmapMax) {
                    state.heatmapMax = data.settings.heatmapMax;
                    document.getElementById('heatmap-max-slider').value = data.settings.heatmapMax;
                    document.getElementById('heatmap-max-value').textContent = data.settings.heatmapMax;
                    document.getElementById('legend-mid').textContent = Math.round(data.settings.heatmapMax / 2);
                    document.getElementById('legend-max').textContent = data.settings.heatmapMax + '+';
                }
            }
            
            // Update UI
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateSurfaceList();
            updateStatus();
            calculateCoverage();
            
            // Re-enable transform tools (they get disabled by resetScene)
            // Select first projector if any were imported, otherwise first surface
            if (state.projectors.length > 0) {
                selectObject('projector', state.projectors[0].id);
            } else if (state.surfaces.length > 0) {
                selectObject('surface', state.surfaces[0].id);
            } else {
                enableTransformTools(false);
            }
            
            // Update undo button state
            updateUndoButton();
            
            closeModal('import-modal');
            
            const message = `Imported ${importedProjectors} projector${importedProjectors !== 1 ? 's' : ''} and ${importedSurfaces} surface${importedSurfaces !== 1 ? 's' : ''}`;
            showToast(message);
        }
        
        function quickSave() {
            // Check if session is valid, otherwise request authentication
            if (!isSessionValid()) {
                requestAuthentication(_quickSaveInternal);
                return;
            }
            _quickSaveInternal();
        }
        
        function _quickSaveInternal() {
            // Quick save with current timestamp
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}_${String(date.getHours()).padStart(2,'0')}-${String(date.getMinutes()).padStart(2,'0')}`;
            
            const config = {
                version: '2.8',
                exportDate: date.toISOString(),
                metadata: {
                    projectorCount: state.projectors.length,
                    surfaceCount: state.surfaces.length
                },
                projectors: state.projectors.map(p => ({ ...p })),
                surfaces: [...state.surfaces],
                settings: {
                    currentPattern: state.currentPattern,
                    displayOptions: { ...state.displayOptions },
                    heatmapMax: state.heatmapMax,
                    currentView: state.currentView
                }
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `projection-autosave-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Project saved successfully');
        }
        
        function confirmNewProject() {
            if (state.projectors.length === 0 && state.surfaces.length === 0) {
                // Nothing to lose, just reset
                resetScene();
                showToast('New project created');
                return;
            }
            
            if (confirm('Start a new project? All unsaved changes will be lost.')) {
                resetScene();
                showToast('New project created');
            }
        }
        
        // ==========================================
        // ANIMATION
        // ==========================================
        
        let lastTime = performance.now(), frames = 0;
        function animate() {
            requestAnimationFrame(animate);
            updateCameraMovement();
            
            const deltaTime = 1/60; // Approximate delta time
            
            // Update video textures (for downsampled videos that need canvas updates)
            videoTextureData.forEach((videoData, projectorId) => {
                if (videoData.playing && videoData.texture) {
                    // For downsampled textures, copy video frame to canvas
                    if (videoData.texture.userData && videoData.texture.userData.isDownsampled) {
                        const { ctx, canvas, video } = videoData.texture.userData;
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        videoData.texture.needsUpdate = true;
                    } else {
                        // For native VideoTexture, just mark as needs update
                        videoData.texture.needsUpdate = true;
                    }
                }
            });
            
            // Update pattern scroll animation
            if (patternScrollState.enabled && state.currentPattern !== 'none') {
                const speed = patternScrollState.speed * deltaTime;
                
                switch (patternScrollState.direction) {
                    case 'horizontal':
                        patternScrollState.offset.x += speed;
                        break;
                    case 'vertical':
                        patternScrollState.offset.y += speed;
                        break;
                    case 'diagonal':
                        patternScrollState.offset.x += speed * 0.707;
                        patternScrollState.offset.y += speed * 0.707;
                        break;
                }
                
                // Wrap offsets
                patternScrollState.offset.x %= 1;
                patternScrollState.offset.y %= 1;
                
                // Update shader uniforms on all surface materials
                const enabled = state.projectors.filter(p => p.enabled);
                surfaceGroup.children.forEach(mesh => {
                    if (mesh.material && mesh.material.uniforms) {
                        // Update all 4 possible projector texture offsets
                        for (let i = 0; i < Math.min(enabled.length, 4); i++) {
                            const proj = enabled[i];
                            // Only scroll patterns, not custom textures/videos
                            if (!proj.customTextureUrl) {
                                mesh.material.uniforms[`texOffset${i}`].value.set(
                                    patternScrollState.offset.x, 
                                    patternScrollState.offset.y
                                );
                            } else {
                                // Reset offset for custom textures
                                mesh.material.uniforms[`texOffset${i}`].value.set(0, 0);
                            }
                        }
                    }
                });
            } else if (patternScrollState.offset.x !== 0 || patternScrollState.offset.y !== 0) {
                // Reset offsets when disabled
                patternScrollState.offset.x = 0;
                patternScrollState.offset.y = 0;
                surfaceGroup.children.forEach(mesh => {
                    if (mesh.material && mesh.material.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (mesh.material.uniforms[`texOffset${i}`]) {
                                mesh.material.uniforms[`texOffset${i}`].value.set(0, 0);
                            }
                        }
                    }
                });
            }
            
            // Update gizmo scale based on camera distance (only if not dragging)
            if (gizmoGroup && gizmoGroup.visible && !gizmoState.isDragging) {
                const dist = camera.position.distanceTo(gizmoGroup.position);
                const scale = dist * 0.15;
                gizmoGroup.scale.setScalar(Math.max(0.5, Math.min(scale, 2)));
            }
            
            // Update distance label positions in screen space
            if (state.displayOptions.distance) {
                const container = document.querySelector('.viewport');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    
                    document.querySelectorAll('.distance-label').forEach(label => {
                        if (label.midPoint) {
                            const screenPos = label.midPoint.clone().project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * rect.width;
                            const y = (-screenPos.y * 0.5 + 0.5) * rect.height;
                            
                            // Only show if in front of camera
                            if (screenPos.z < 1) {
                                label.style.left = x + 'px';
                                label.style.top = y + 'px';
                                label.style.display = 'block';
                            } else {
                                label.style.display = 'none';
                            }
                        }
                    });
                }
            }
            
            frames++;
            if (performance.now() - lastTime >= 1000) {
                document.getElementById('fps-counter').textContent = frames + ' FPS';
                frames = 0; lastTime = performance.now();
            }
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
