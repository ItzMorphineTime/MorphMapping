<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta author="Joe Loe">
    <title>Projection Study Configurator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0c;
            --bg-secondary: #111114;
            --bg-tertiary: #18181c;
            --bg-panel: #141418;
            --border-color: #2a2a32;
            --border-hover: #3a3a44;
            --text-primary: #e8e8ec;
            --text-secondary: #9898a4;
            --text-muted: #5c5c68;
            --accent-primary: #00d4aa;
            --accent-secondary: #00a888;
            --accent-glow: rgba(0, 212, 170, 0.15);
            --warning: #ffaa00;
            --danger: #ff4466;
            --projector-color: #00aaff;
            --surface-color: #8844ff;
        }
        
        body { font-family: 'Outfit', sans-serif; background: var(--bg-primary); color: var(--text-primary); height: 100vh; overflow: hidden; }
        .app-container { display: grid; grid-template-columns: 320px 1fr 360px; grid-template-rows: 56px 1fr 48px; height: 100vh; }
        
        .header { grid-column: 1 / -1; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent-primary), var(--projector-color)); border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .logo-icon svg { width: 18px; height: 18px; fill: var(--bg-primary); }
        .logo-text { font-weight: 600; font-size: 16px; letter-spacing: -0.02em; }
        .logo-text span { color: var(--text-secondary); font-weight: 400; }
        .header-actions { display: flex; gap: 8px; }
        
        .btn { font-family: 'Outfit', sans-serif; padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; align-items: center; gap: 6px; }
        .btn:hover { background: var(--bg-panel); border-color: var(--border-hover); }
        .btn-primary { background: var(--accent-primary); border-color: var(--accent-primary); color: var(--bg-primary); }
        .btn-primary:hover { background: var(--accent-secondary); border-color: var(--accent-secondary); }
        .btn svg { width: 14px; height: 14px; }
        
        .sidebar-left, .sidebar-right { background: var(--bg-secondary); overflow-y: auto; }
        .sidebar-left { border-right: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .sidebar-right { border-left: 1px solid var(--border-color); }
        
        .panel-section { border-bottom: 1px solid var(--border-color); }
        .panel-header { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; }
        .panel-header:hover { background: var(--bg-tertiary); }
        .panel-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-secondary); }
        .panel-content { padding: 0 16px 16px; }
        .panel-badge { background: var(--bg-tertiary); padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 500; color: var(--text-muted); }
        
        .object-list { display: flex; flex-direction: column; gap: 4px; }
        .object-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; cursor: pointer; transition: all 0.15s ease; border: 1px solid transparent; }
        .object-item:hover { background: var(--bg-panel); }
        .object-item.selected { border-color: var(--accent-primary); background: var(--accent-glow); }
        .object-icon { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .object-icon.projector { background: rgba(0, 170, 255, 0.15); }
        .object-icon.projector svg { fill: var(--projector-color); }
        .object-icon.surface { background: rgba(136, 68, 255, 0.15); }
        .object-icon.surface svg { fill: var(--surface-color); }
        .object-icon svg { width: 14px; height: 14px; }
        .object-info { flex: 1; min-width: 0; }
        .object-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .object-type { font-size: 11px; color: var(--text-muted); }
        .object-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s ease; }
        .object-item:hover .object-actions { opacity: 1; }
        
        .icon-btn { width: 24px; height: 24px; border-radius: 4px; border: none; background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .icon-btn:hover { background: var(--border-color); color: var(--text-primary); }
        .icon-btn.danger:hover { background: rgba(255, 68, 102, 0.2); color: var(--danger); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }
        
        .add-buttons { display: flex; gap: 8px; padding: 16px; border-top: 1px solid var(--border-color); margin-top: auto; }
        .add-btn { flex: 1; padding: 10px; border-radius: 6px; border: 1px dashed var(--border-color); background: transparent; color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .add-btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); background: var(--accent-glow); }
        .add-btn svg { width: 18px; height: 18px; fill: currentColor; }
        
        .property-group { margin-bottom: 16px; }
        .property-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 10px; }
        .property-row { display: flex; align-items: center; margin-bottom: 8px; }
        .property-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .property-inputs { display: flex; gap: 4px; flex: 1; }
        .input-group { flex: 1; position: relative; }
        .input-group label { position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-size: 10px; font-weight: 600; color: var(--text-muted); pointer-events: none; }
        .input-group input { width: 100%; padding: 8px 8px 8px 22px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .input-group input:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        .single-input { flex: 1; }
        .single-input input, .single-input select { width: 100%; padding: 8px 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .single-input select { font-family: 'Outfit', sans-serif; cursor: pointer; }
        .single-input input:focus, .single-input select:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        
        .slider-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .slider-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .slider-container { flex: 1; display: flex; align-items: center; gap: 10px; }
        .slider { flex: 1; -webkit-appearance: none; height: 4px; border-radius: 2px; background: var(--border-color); outline: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; }
        .slider-value { width: 50px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-secondary); text-align: right; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .toggle-label { font-size: 12px; color: var(--text-secondary); }
        .toggle { width: 36px; height: 20px; border-radius: 10px; background: var(--border-color); cursor: pointer; position: relative; transition: background 0.2s ease; }
        .toggle.active { background: var(--accent-primary); }
        .toggle::after { content: ''; position: absolute; width: 16px; height: 16px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: transform 0.2s ease; }
        .toggle.active::after { transform: translateX(16px); }
        
        .viewport { background: var(--bg-primary); position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; }
        #canvas-container canvas { display: block; }
        
        .viewport-overlay { position: absolute; top: 12px; left: 12px; display: flex; gap: 8px; }
        .view-btn { padding: 6px 12px; border-radius: 4px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 11px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; }
        .view-btn:hover, .view-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); }
        
        .viewport-info { position: absolute; bottom: 12px; left: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 10px 14px; border-radius: 6px; border: 1px solid var(--border-color); }
        .viewport-info-row { display: flex; gap: 16px; font-size: 11px; }
        .viewport-info-item { display: flex; align-items: center; gap: 6px; }
        .viewport-info-item span:first-child { color: var(--text-muted); }
        .viewport-info-item span:last-child { font-family: 'JetBrains Mono', monospace; color: var(--text-secondary); }
        
        .controls-hint { position: absolute; bottom: 12px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 10px; color: var(--text-muted); }
        .controls-hint kbd { background: var(--bg-tertiary); padding: 2px 5px; border-radius: 3px; font-family: 'JetBrains Mono', monospace; margin: 0 2px; }
        
        .pattern-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .pattern-btn { aspect-ratio: 1; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); cursor: pointer; transition: all 0.15s ease; overflow: hidden; }
        .pattern-btn:hover { border-color: var(--border-hover); }
        .pattern-btn.active { border-color: var(--accent-primary); box-shadow: 0 0 0 1px var(--accent-primary); }
        .pattern-preview { width: 100%; height: 100%; }
        .pattern-grid-lines { background: linear-gradient(var(--text-muted) 1px, transparent 1px), linear-gradient(90deg, var(--text-muted) 1px, transparent 1px); background-size: 8px 8px; }
        .pattern-checker { background: repeating-conic-gradient(var(--text-muted) 0% 25%, var(--bg-tertiary) 0% 50%) 50% / 12px 12px; }
        .pattern-gradient { background: linear-gradient(90deg, #000, #fff); }
        .pattern-colorbars { background: linear-gradient(90deg, #fff 0% 14.28%, #ff0 14.28% 28.56%, #0ff 28.56% 42.84%, #0f0 42.84% 57.12%, #f0f 57.12% 71.4%, #f00 71.4% 85.68%, #00f 85.68% 100%); }
        .pattern-cross { background: var(--bg-tertiary); position: relative; }
        .pattern-cross::before, .pattern-cross::after { content: ''; position: absolute; background: var(--text-muted); }
        .pattern-cross::before { width: 1px; height: 100%; left: 50%; }
        .pattern-cross::after { height: 1px; width: 100%; top: 50%; }
        .pattern-white { background: #fff; }
        .pattern-none { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--text-muted); }
        .pattern-blend { background: linear-gradient(90deg, rgba(255,0,0,0.5) 0% 20%, transparent 20% 80%, rgba(0,255,0,0.5) 80% 100%); }
        
        .status-bar { grid-column: 1 / -1; background: var(--bg-tertiary); border-top: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; font-size: 11px; }
        .status-left, .status-right { display: flex; align-items: center; gap: 16px; }
        .status-item { display: flex; align-items: center; gap: 6px; color: var(--text-muted); }
        .status-item svg { width: 12px; height: 12px; fill: currentColor; }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent-primary); }
        
        .empty-state { padding: 24px 16px; text-align: center; }
        .empty-state p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        
        .no-selection { padding: 40px 20px; text-align: center; }
        .no-selection-icon { width: 48px; height: 48px; margin: 0 auto 16px; background: var(--bg-tertiary); border-radius: 12px; display: flex; align-items: center; justify-content: center; }
        .no-selection-icon svg { width: 24px; height: 24px; fill: var(--text-muted); }
        .no-selection h3 { font-size: 14px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary); }
        .no-selection p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        .coverage-display { margin-top: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; border: 1px solid var(--border-color); }
        .coverage-bar { height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; margin-top: 8px; }
        .coverage-fill { height: 100%; background: var(--accent-primary); border-radius: 3px; transition: width 0.3s ease; }
        .coverage-stats { display: flex; justify-content: space-between; font-size: 11px; margin-top: 8px; }
        .coverage-stat { color: var(--text-muted); }
        .coverage-stat span { color: var(--text-secondary); font-family: 'JetBrains Mono', monospace; }
        
        .texture-upload { margin-top: 8px; padding: 16px; border: 2px dashed var(--border-color); border-radius: 6px; text-align: center; cursor: pointer; transition: all 0.15s ease; }
        .texture-upload:hover { border-color: var(--accent-primary); background: var(--accent-glow); }
        .texture-upload input { display: none; }
        .texture-upload p { font-size: 11px; color: var(--text-muted); margin: 0; }
        .texture-preview { width: 100%; height: 80px; border-radius: 4px; background-size: contain; background-repeat: no-repeat; background-position: center; background-color: var(--bg-primary); margin-bottom: 8px; border: 1px solid var(--border-color); }
        .clear-texture-btn { margin-top: 8px; width: 100%; padding: 6px; font-size: 11px; }
        
        .luminance-legend { 
            margin-top: 12px; 
            padding: 12px; 
            background: var(--bg-primary); 
            border-radius: 6px; 
            border: 1px solid var(--border-color);
        }
        .legend-gradient { 
            height: 20px; 
            border-radius: 4px; 
            background: linear-gradient(90deg, 
                #000033 0%, 
                #0044aa 20%, 
                #00aa44 40%, 
                #aaaa00 60%, 
                #ff6600 80%, 
                #ff0000 95%,
                #ffffff 100%
            ); 
            margin-bottom: 6px;
        }
        .legend-labels { 
            display: flex; 
            justify-content: space-between; 
            font-size: 10px; 
            color: var(--text-secondary); 
            font-family: 'JetBrains Mono', monospace;
        }
        .legend-unit {
            text-align: center;
            font-size: 9px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 480px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.2s ease;
        }
        .modal-overlay.active .modal {
            transform: scale(1);
        }
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .modal-title {
            font-size: 16px;
            font-weight: 600;
        }
        .modal-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .modal-close svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 50vh;
        }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .export-option {
            display: flex;
            align-items: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }
        .export-option:hover {
            background: var(--bg-panel);
            border-color: var(--border-hover);
        }
        .export-option.selected {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
        }
        .export-option-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        .export-option-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--accent-primary);
        }
        .export-option-info h4 {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 2px;
        }
        .export-option-info p {
            font-size: 11px;
            color: var(--text-muted);
            margin: 0;
        }
        .export-checkbox {
            margin-left: auto;
        }
        .checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .checkbox.checked {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        .checkbox svg {
            width: 12px;
            height: 12px;
            fill: var(--bg-primary);
            opacity: 0;
        }
        .checkbox.checked svg {
            opacity: 1;
        }
        .import-preview {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .import-preview h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .import-stat {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        .import-stat:last-child {
            border-bottom: none;
        }
        .import-stat span:first-child {
            color: var(--text-muted);
        }
        .import-stat span:last-child {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        .import-warning {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 6px;
            margin-top: 12px;
        }
        .import-warning svg {
            width: 16px;
            height: 16px;
            fill: var(--warning);
            flex-shrink: 0;
            margin-top: 1px;
        }
        .import-warning p {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }
        .filename-input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            margin-bottom: 16px;
        }
        .filename-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-primary);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        .toast.success {
            border-color: var(--accent-primary);
        }
        .toast.error {
            border-color: var(--danger);
        }
        .toast svg {
            width: 18px;
            height: 18px;
        }
        .toast.success svg {
            fill: var(--accent-primary);
        }
        .toast.error svg {
            fill: var(--danger);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                <span class="logo-text">Projection Studio <span>v2.3</span></span>
            </div>
            <div class="header-actions">
                <button class="btn" onclick="confirmNewProject()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>New</button>
                <button class="btn" onclick="document.getElementById('import-file').click()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>Import</button>
                <input type="file" id="import-file" accept=".json" style="display:none" onchange="importConfig(this.files[0])">
                <button class="btn" onclick="showExportModal()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>Export</button>
                <button class="btn btn-primary" onclick="quickSave()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>Save</button>
            </div>
        </header>
        
        <aside class="sidebar-left">
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Projectors</span><span class="panel-badge" id="projector-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="projector-list"><div class="empty-state"><p>No projectors added yet.</p></div></div></div>
            </div>
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Surfaces</span><span class="panel-badge" id="surface-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="surface-list"><div class="empty-state"><p>No surfaces added yet.</p></div></div></div>
            </div>
            <div class="add-buttons">
                <button class="add-btn" onclick="addProjector()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Projector</button>
                <button class="add-btn" onclick="addSurface()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Surface</button>
            </div>
        </aside>
        
        <main class="viewport">
            <div id="canvas-container"></div>
            <div class="viewport-overlay">
                <button class="view-btn active" onclick="setView('perspective')">Perspective</button>
                <button class="view-btn" onclick="setView('top')">Top</button>
                <button class="view-btn" onclick="setView('front')">Front</button>
                <button class="view-btn" onclick="setView('side')">Side</button>
                <button class="view-btn" onclick="setView('projector')">Projector POV</button>
            </div>
            <div class="viewport-info">
                <div class="viewport-info-row">
                    <div class="viewport-info-item"><span>Camera:</span><span id="camera-info">Perspective</span></div>
                    <div class="viewport-info-item"><span>Units:</span><span>Meters</span></div>
                </div>
            </div>
            <div class="controls-hint">
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;
                <kbd>Q</kbd><kbd>E</kbd> Up/Down &nbsp;
                <kbd>Drag</kbd> Look
            </div>
        </main>
        
        <aside class="sidebar-right">
            <div id="properties-panel">
                <div class="no-selection">
                    <div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div>
                    <h3>No Selection</h3>
                    <p>Select an object to edit.</p>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Test Patterns</span></div>
                <div class="panel-content">
                    <div class="pattern-grid">
                        <button class="pattern-btn active" onclick="setPattern('none')" title="None"><div class="pattern-preview pattern-none">OFF</div></button>
                        <button class="pattern-btn" onclick="setPattern('grid')" title="Grid"><div class="pattern-preview pattern-grid-lines"></div></button>
                        <button class="pattern-btn" onclick="setPattern('checker')" title="Checkerboard"><div class="pattern-preview pattern-checker"></div></button>
                        <button class="pattern-btn" onclick="setPattern('gradient')" title="Gradient"><div class="pattern-preview pattern-gradient"></div></button>
                        <button class="pattern-btn" onclick="setPattern('colorbars')" title="Color Bars"><div class="pattern-preview pattern-colorbars"></div></button>
                        <button class="pattern-btn" onclick="setPattern('cross')" title="Focus Cross"><div class="pattern-preview pattern-cross"></div></button>
                        <button class="pattern-btn" onclick="setPattern('white')" title="White"><div class="pattern-preview pattern-white"></div></button>
                        <button class="pattern-btn" onclick="setPattern('blend')" title="Blend Zones"><div class="pattern-preview pattern-blend"></div></button>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Display Options</span></div>
                <div class="panel-content">
                    <div class="toggle-row"><span class="toggle-label">Show Frustums</span><div class="toggle active" id="toggle-frustums" onclick="toggleOption('frustums')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Grid</span><div class="toggle active" id="toggle-grid" onclick="toggleOption('grid')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Coverage</span><div class="toggle active" id="toggle-coverage" onclick="toggleOption('coverage')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Overlap</span><div class="toggle" id="toggle-overlap" onclick="toggleOption('overlap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Luminance Heatmap</span><div class="toggle" id="toggle-heatmap" onclick="toggleOption('heatmap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Wireframe</span><div class="toggle" id="toggle-wireframe" onclick="toggleOption('wireframe')"></div></div>
                </div>
            </div>
            
            <div class="panel-section" id="heatmap-panel" style="display: none;">
                <div class="panel-header"><span class="panel-title">Luminance Heatmap</span></div>
                <div class="panel-content">
                    <div class="property-group">
                        <div class="property-group-title">Scale (cd/m²)</div>
                        <div class="slider-row">
                            <span class="slider-label">Max Value</span>
                            <div class="slider-container">
                                <input type="range" class="slider" min="100" max="10000" step="100" value="2000" id="heatmap-max-slider" oninput="updateHeatmapMax(+this.value); document.getElementById('heatmap-max-value').textContent=this.value">
                                <span class="slider-value" id="heatmap-max-value">2000</span>
                            </div>
                        </div>
                    </div>
                    <div class="luminance-legend">
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>0</span>
                            <span id="legend-mid">1000</span>
                            <span id="legend-max">2000+</span>
                        </div>
                        <div class="legend-unit">cd/m² (nits)</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Coverage Analysis</span></div>
                <div class="panel-content">
                    <div class="coverage-display">
                        <div class="property-group-title">Surface Coverage</div>
                        <div class="coverage-bar"><div class="coverage-fill" id="coverage-fill" style="width: 0%"></div></div>
                        <div class="coverage-stats">
                            <div class="coverage-stat">Covered: <span id="coverage-percent">0%</span></div>
                            <div class="coverage-stat">Avg: <span id="avg-cdm2">0</span> cd/m²</div>
                        </div>
                        <div class="coverage-stats" style="margin-top: 4px;">
                            <div class="coverage-stat">Min: <span id="min-cdm2">0</span> cd/m²</div>
                            <div class="coverage-stat">Max: <span id="max-cdm2">0</span> cd/m²</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
        
        <footer class="status-bar">
            <div class="status-left">
                <div class="status-item"><div class="status-dot"></div>Ready</div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg><span id="projector-status">0 Projectors</span></div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg><span id="surface-status">0 Surfaces</span></div>
            </div>
            <div class="status-right"><div class="status-item"><span id="fps-counter">60 FPS</span></div></div>
        </footer>
    </div>
    
    <!-- Export Modal -->
    <div class="modal-overlay" id="export-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Export Project</span>
                <button class="modal-close" onclick="closeModal('export-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 6px;">Filename</label>
                <input type="text" class="filename-input" id="export-filename" value="projection-config" placeholder="Enter filename">
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Include in export:</label>
                
                <div class="export-option" onclick="toggleExportOption('projectors')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Projectors</h4>
                        <p id="export-projector-count">0 projectors with settings</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-projectors">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('surfaces')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Surfaces</h4>
                        <p id="export-surface-count">0 surfaces with settings</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-surfaces">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('settings')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.49.49 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Display Settings</h4>
                        <p>Pattern, heatmap, view options</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-settings">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('textures')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Custom Textures</h4>
                        <p id="export-texture-count">Embed texture images (increases file size)</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="export-check-textures">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('export-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doExport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Export
                </button>
            </div>
        </div>
    </div>
    
    <!-- Import Modal -->
    <div class="modal-overlay" id="import-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Import Project</span>
                <button class="modal-close" onclick="closeModal('import-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="import-preview">
                    <h4>File Contents</h4>
                    <div class="import-stat">
                        <span>Version</span>
                        <span id="import-version">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Projectors</span>
                        <span id="import-projectors">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Surfaces</span>
                        <span id="import-surfaces">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Custom Textures</span>
                        <span id="import-textures">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Settings</span>
                        <span id="import-settings">-</span>
                    </div>
                </div>
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Import options:</label>
                
                <div class="export-option" onclick="toggleImportOption('replace')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Replace Current Scene</h4>
                        <p>Clear existing objects before importing</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="import-check-replace">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleImportOption('merge')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Merge with Current</h4>
                        <p>Add imported objects to existing scene</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="import-check-merge">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="import-warning">
                    <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    <p>This will modify your current scene. Make sure to export your work first if you want to keep it.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('import-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doImport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
                    Import
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
        <span id="toast-message">Success!</span>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==========================================
        // PROJECTION STUDIO v2.3
        // Fixed coverage, frustum zoom, presets, luminance heatmap
        // ==========================================
        
        const state = {
            projectors: [],
            surfaces: [],
            selectedObject: null,
            selectedType: null,
            currentPattern: 'none',
            displayOptions: { frustums: true, grid: true, coverage: true, overlap: false, heatmap: false, wireframe: false },
            currentView: 'perspective',
            heatmapMax: 2000 // cd/m² maximum for heatmap scale
        };
        
        let scene, camera, renderer, gridHelper, projectorGroup, surfaceGroup, raycaster, mouse;
        const projectionTextures = new Map();
        const projectorMatrixData = new Map();
        const customTextureData = new Map();
        
        // Keyboard state for WASD controls
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false };
        
        // Projector presets with real-world specifications
        const projectorPresets = {
            'custom': { name: 'Custom', lumens: 10000, throwRatio: 1.5, aspectRatio: 16/9, resolution: '1920×1080' },
            'barco-udx-4k40': { name: 'Barco UDX-4K40', lumens: 40000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840×2160' },
            'barco-udx-4k26': { name: 'Barco UDX-4K26', lumens: 26000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840×2160' },
            'christie-griffyn-4k35': { name: 'Christie Griffyn 4K35', lumens: 36500, throwRatio: 1.38, aspectRatio: 16/9, resolution: '4096×2160' },
            'christie-d4k40': { name: 'Christie D4K40-RGB', lumens: 45000, throwRatio: 1.8, aspectRatio: 1.9, resolution: '4096×2160' },
            'panasonic-pt-rq35k': { name: 'Panasonic PT-RQ35K', lumens: 30500, throwRatio: 1.7, aspectRatio: 16/9, resolution: '5120×3200' },
            'panasonic-pt-rz120': { name: 'Panasonic PT-RZ120', lumens: 12000, throwRatio: 1.7, aspectRatio: 16/10, resolution: '1920×1200' },
            'epson-pro-l30000': { name: 'Epson Pro L30000U', lumens: 30000, throwRatio: 1.57, aspectRatio: 16/10, resolution: '1920×1200' },
            'sony-vpl-gtz380': { name: 'Sony VPL-GTZ380', lumens: 10000, throwRatio: 1.4, aspectRatio: 17/9, resolution: '4096×2160' },
            'digital-projection-titan': { name: 'DP TITAN Laser 37000', lumens: 37000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840×2160' }
        };
        
        // ==========================================
        // SHADERS - With luminance calculation
        // ==========================================
        
        const projectionVertexShader = `
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            void main() {
                vWorldPosition = modelMatrix * vec4(position, 1.0);
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // Fragment shader with proper luminance calculation (cd/m²) and linear heatmap
        const projectionFragmentShader = `
            uniform sampler2D projTex0;
            uniform sampler2D projTex1;
            uniform sampler2D projTex2;
            uniform sampler2D projTex3;
            uniform mat4 projMat0;
            uniform mat4 projMat1;
            uniform mat4 projMat2;
            uniform mat4 projMat3;
            uniform vec3 projPos0;
            uniform vec3 projPos1;
            uniform vec3 projPos2;
            uniform vec3 projPos3;
            uniform float projLumens0;
            uniform float projLumens1;
            uniform float projLumens2;
            uniform float projLumens3;
            uniform float projThrow0;
            uniform float projThrow1;
            uniform float projThrow2;
            uniform float projThrow3;
            uniform int numProjectors;
            uniform bool showCoverage;
            uniform bool showOverlap;
            uniform bool showHeatmap;
            uniform float surfaceGain;
            uniform vec3 baseColor;
            uniform float heatmapMax; // Maximum cd/m² for heatmap scale
            
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            // Linear heatmap color function with white for overflow
            // 0.0 = dark blue, 0.5 = green, 1.0 = red, >1.0 = white
            vec3 heatmapColor(float t) {
                // Clamp display but allow overflow detection
                if (t > 1.0) {
                    // Fade to white for values above max
                    float overflow = min((t - 1.0) * 2.0, 1.0);
                    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), overflow);
                }
                
                t = clamp(t, 0.0, 1.0);
                
                // Linear gradient: dark blue -> blue -> cyan -> green -> yellow -> orange -> red
                if (t < 0.167) {
                    return mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.27, 0.67), t / 0.167);
                } else if (t < 0.333) {
                    return mix(vec3(0.0, 0.27, 0.67), vec3(0.0, 0.67, 0.27), (t - 0.167) / 0.167);
                } else if (t < 0.5) {
                    return mix(vec3(0.0, 0.67, 0.27), vec3(0.67, 0.67, 0.0), (t - 0.333) / 0.167);
                } else if (t < 0.667) {
                    return mix(vec3(0.67, 0.67, 0.0), vec3(1.0, 0.67, 0.0), (t - 0.5) / 0.167);
                } else if (t < 0.833) {
                    return mix(vec3(1.0, 0.67, 0.0), vec3(1.0, 0.4, 0.0), (t - 0.667) / 0.167);
                } else {
                    return mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.833) / 0.167);
                }
            }
            
            // Sample projector and return color and luminance contribution
            // Returns: vec4(color.rgb, cd/m²)
            vec4 sampleProjector(mat4 projMat, sampler2D projTex, vec3 projPos, float lumens, float throwRatio) {
                vec4 projCoord = projMat * vWorldPosition;
                
                if (projCoord.w <= 0.0) return vec4(0.0);
                
                vec3 ndc = projCoord.xyz / projCoord.w;
                vec2 uv = ndc.xy * 0.5 + 0.5;
                
                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec4(0.0);
                if (ndc.z < -1.0 || ndc.z > 1.0) return vec4(0.0);
                
                vec3 toProj = normalize(projPos - vWorldPosition.xyz);
                float facing = dot(vWorldNormal, toProj);
                if (facing <= 0.0) return vec4(0.0);
                
                float dist = length(projPos - vWorldPosition.xyz);
                
                // Calculate projected image size at this distance
                float projWidth = dist / throwRatio;
                float projHeight = projWidth / (16.0/9.0);
                float projArea = projWidth * projHeight;
                
                // Illuminance (lux) = lumens / area
                float lux = lumens / projArea;
                
                // Luminance (cd/m²) = Illuminance × Reflectance / π
                // For projection screens: cd/m² = lux × gain / π
                // This accounts for the Lambertian reflection model
                float cdm2 = (lux * surfaceGain / 3.14159) * facing;
                
                // Edge falloff for soft blending
                float edgeDist = max(abs(uv.x - 0.5), abs(uv.y - 0.5)) * 2.0;
                float edgeFalloff = 1.0 - smoothstep(0.85, 1.0, edgeDist);
                
                cdm2 *= edgeFalloff;
                
                vec4 texColor = texture2D(projTex, uv);
                
                // Color intensity based on luminance (normalized for display)
                float displayIntensity = cdm2 / 1500.0; // Normalize for reasonable display
                
                return vec4(texColor.rgb * displayIntensity * facing, cdm2);
            }
            
            void main() {
                vec3 color = baseColor * 0.02;
                float totalCdm2 = 0.0;
                int hitCount = 0;
                
                if (numProjectors > 0) {
                    vec4 result = sampleProjector(projMat0, projTex0, projPos0, projLumens0, projThrow0);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 1) {
                    vec4 result = sampleProjector(projMat1, projTex1, projPos1, projLumens1, projThrow1);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 2) {
                    vec4 result = sampleProjector(projMat2, projTex2, projPos2, projLumens2, projThrow2);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 3) {
                    vec4 result = sampleProjector(projMat3, projTex3, projPos3, projLumens3, projThrow3);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                
                // Luminance heatmap mode
                if (showHeatmap) {
                    if (hitCount == 0) {
                        color = vec3(0.0, 0.0, 0.1); // Dark blue for uncovered
                    } else {
                        // Linear scale: 0 to heatmapMax maps to 0.0 to 1.0
                        float normalizedLuminance = totalCdm2 / heatmapMax;
                        color = heatmapColor(normalizedLuminance);
                    }
                } else {
                    // Coverage visualization: red if not hit
                    if (showCoverage && hitCount == 0) {
                        color = vec3(0.25, 0.02, 0.02);
                    }
                    
                    // Overlap visualization: orange tint
                    if (showOverlap && hitCount > 1) {
                        float overlapIntensity = float(hitCount - 1) / 3.0;
                        color = mix(color, vec3(1.0, 0.5, 0.0), min(overlapIntensity, 0.7));
                    }
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // ==========================================
        // INITIALIZATION
        // ==========================================
        
        function init() {
            initThreeJS();
            initControls();
            initKeyboardControls();
            animate();
            updateStatus();
        }
        
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0c);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, -18);
            camera.rotation.order = 'YXZ';
            camera.rotation.set(0, Math.PI, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            
            gridHelper = new THREE.GridHelper(50, 50, 0x2a2a32, 0x1a1a20);
            scene.add(gridHelper);
            
            projectorGroup = new THREE.Group();
            surfaceGroup = new THREE.Group();
            scene.add(projectorGroup);
            scene.add(surfaceGroup);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        function initControls() {
            let isMouseDown = false;
            let prevMouseX = 0, prevMouseY = 0;
            let mouseDownX = 0, mouseDownY = 0;
            let isDragging = false;
            
            renderer.domElement.addEventListener('mousedown', e => {
                if (e.button === 0 || e.button === 2) {
                    isMouseDown = true;
                    isDragging = false;
                    prevMouseX = e.clientX;
                    prevMouseY = e.clientY;
                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('mouseup', e => {
                if (!isDragging && e.button === 0) {
                    handleCanvasClick(e);
                }
                isMouseDown = false;
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => { isMouseDown = false; isDragging = false; });
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            renderer.domElement.addEventListener('mousemove', e => {
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                
                const totalMovement = Math.abs(e.clientX - mouseDownX) + Math.abs(e.clientY - mouseDownY);
                if (totalMovement > 5) isDragging = true;
                
                camera.rotation.order = 'YXZ';
                camera.rotation.y -= deltaX * 0.003;
                camera.rotation.x -= deltaY * 0.003;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
        }
        
        function initKeyboardControls() {
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) { keys[key] = true; e.preventDefault(); }
            });
            window.addEventListener('keyup', e => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
            });
        }
        
        function updateCameraMovement() {
            const speed = 0.15;
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            const right = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();
            
            const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
            const rightHoriz = new THREE.Vector3(right.x, 0, right.z).normalize();
            
            if (keys.w) camera.position.addScaledVector(forward, speed);
            if (keys.s) camera.position.addScaledVector(forward, -speed);
            if (keys.a) camera.position.addScaledVector(rightHoriz, -speed);
            if (keys.d) camera.position.addScaledVector(rightHoriz, speed);
            if (keys.e) camera.position.y += speed;
            if (keys.q) camera.position.y -= speed;
        }
        
        function handleCanvasClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const projMeshes = [];
            projectorGroup.traverse(c => { if (c.isMesh && c.userData.isProjector) projMeshes.push(c); });
            let hits = raycaster.intersectObjects(projMeshes);
            if (hits.length > 0) { selectObject('projector', hits[0].object.userData.projectorId); return; }
            
            hits = raycaster.intersectObjects(surfaceGroup.children);
            if (hits.length > 0 && hits[0].object.userData.surfaceId) {
                selectObject('surface', hits[0].object.userData.surfaceId);
            }
        }
        
        // ==========================================
        // TEXTURE GENERATION
        // ==========================================
        
        function createPatternTexture(pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            switch(pattern) {
                case 'none':
                    ctx.fillStyle = '#999';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'grid':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 512; i += 32) {
                        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
                    }
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(4, 4, 504, 504);
                    break;
                case 'checker':
                    for (let y = 0; y < 512; y += 32)
                        for (let x = 0; x < 512; x += 32) {
                            ctx.fillStyle = ((x + y) / 32) % 2 === 0 ? '#fff' : '#000';
                            ctx.fillRect(x, y, 32, 32);
                        }
                    break;
                case 'gradient':
                    const grad = ctx.createLinearGradient(0, 0, 512, 0);
                    grad.addColorStop(0, '#000'); grad.addColorStop(1, '#fff');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'colorbars':
                    ['#fff','#ff0','#0ff','#0f0','#f0f','#f00','#00f'].forEach((c, i) => {
                        ctx.fillStyle = c;
                        ctx.fillRect(i * 512/7, 0, 512/7 + 1, 512);
                    });
                    break;
                case 'cross':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(256, 0); ctx.lineTo(256, 512);
                    ctx.moveTo(0, 256); ctx.lineTo(512, 256);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(256, 256, 100, 0, Math.PI * 2);
                    ctx.arc(256, 256, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 3;
                    [[10,10],[452,10],[10,452],[452,452]].forEach(([x,y]) => ctx.strokeRect(x, y, 50, 50));
                    break;
                case 'white':
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'blend':
                    ctx.fillStyle = '#888';
                    ctx.fillRect(0, 0, 512, 512);
                    const lg = ctx.createLinearGradient(0, 0, 120, 0);
                    lg.addColorStop(0, 'rgba(255,0,0,1)'); lg.addColorStop(1, 'transparent');
                    ctx.fillStyle = lg; ctx.fillRect(0, 0, 120, 512);
                    const rg = ctx.createLinearGradient(392, 0, 512, 0);
                    rg.addColorStop(0, 'transparent'); rg.addColorStop(1, 'rgba(0,255,0,1)');
                    ctx.fillStyle = rg; ctx.fillRect(392, 0, 120, 512);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // ==========================================
        // PROJECTOR
        // ==========================================
        
        function addProjector(presetKey = 'custom') {
            const preset = projectorPresets[presetKey] || projectorPresets['custom'];
            const id = Date.now();
            const projector = {
                id,
                name: `Projector ${state.projectors.length + 1}`,
                preset: presetKey,
                position: { x: 0, y: 4, z: -8 },
                rotation: { x: -10, y: 0, z: 0 },
                lumens: preset.lumens,
                throwRatio: preset.throwRatio,
                aspectRatio: preset.aspectRatio,
                resolution: preset.resolution,
                zoom: 1.0,
                enabled: true,
                customTextureUrl: null
            };
            
            state.projectors.push(projector);
            createProjectorMesh(projector);
            updateProjectorMatrix(projector);
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', id);
            calculateCoverage();
        }
        
        function createProjectorMesh(projector) {
            const group = new THREE.Group();
            group.userData.projectorId = projector.id;
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.2, 0.5),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            body.userData.isProjector = true;
            body.userData.projectorId = projector.id;
            group.add(body);
            
            // Direction indicator above projector
            const indicator = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.2, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            indicator.rotation.x = Math.PI / 2;
            indicator.position.y = 0.25;
            indicator.position.z = 0.15;
            group.add(indicator);
            
            group.add(createFrustum(projector));
            
            group.position.set(projector.position.x, projector.position.y, projector.position.z);
            group.rotation.set(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z)
            );
            
            projectorGroup.add(group);
        }
        
        function createFrustum(projector) {
            const group = new THREE.Group();
            group.userData.isFrustum = true;
            
            const dist = 15;
            // FIXED: Divide by zoom (zoom in = narrower beam = smaller frustum)
            const w = (dist / projector.throwRatio) / projector.zoom;
            const h = w / projector.aspectRatio;
            
            const mat = new THREE.LineBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.5 });
            
            const pts = [
                [0,0,0], [-w/2,-h/2,dist], [0,0,0], [w/2,-h/2,dist],
                [0,0,0], [w/2,h/2,dist], [0,0,0], [-w/2,h/2,dist]
            ].map(p => new THREE.Vector3(...p));
            group.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), mat));
            
            const rect = [[-w/2,-h/2,dist], [w/2,-h/2,dist], [w/2,h/2,dist], [-w/2,h/2,dist], [-w/2,-h/2,dist]]
                .map(p => new THREE.Vector3(...p));
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rect), mat));
            
            group.visible = state.displayOptions.frustums;
            return group;
        }
        
        function updateProjectorMatrix(projector) {
            // FIXED: Divide by zoom for correct FOV calculation
            const fov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom)) * (180 / Math.PI);
            
            const projCam = new THREE.PerspectiveCamera(fov, projector.aspectRatio, 0.1, 100);
            projCam.position.set(projector.position.x, projector.position.y, projector.position.z);
            
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z),
                'YXZ'
            );
            
            const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
            const target = new THREE.Vector3().copy(projCam.position).add(forward);
            projCam.lookAt(target);
            
            projCam.updateMatrixWorld(true);
            projCam.updateProjectionMatrix();
            
            const vpMatrix = new THREE.Matrix4();
            vpMatrix.multiplyMatrices(projCam.projectionMatrix, projCam.matrixWorldInverse);
            
            projectorMatrixData.set(projector.id, {
                matrix: vpMatrix,
                position: new THREE.Vector3(projector.position.x, projector.position.y, projector.position.z),
                lumens: projector.lumens,
                throwRatio: projector.throwRatio * projector.zoom // Effective throw ratio
            });
            
            if (projector.customTextureUrl && customTextureData.has(projector.id)) {
                projectionTextures.set(projector.id, customTextureData.get(projector.id));
            } else {
                projectionTextures.set(projector.id, createPatternTexture(state.currentPattern));
            }
        }
        
        function updateProjectorMesh(projector) {
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === projector.id);
            if (mesh) {
                mesh.position.set(projector.position.x, projector.position.y, projector.position.z);
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(projector.rotation.x),
                    THREE.MathUtils.degToRad(projector.rotation.y),
                    THREE.MathUtils.degToRad(projector.rotation.z)
                );
                
                const oldF = mesh.children.find(c => c.userData.isFrustum);
                if (oldF) mesh.remove(oldF);
                mesh.add(createFrustum(projector));
            }
            
            updateProjectorMatrix(projector);
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function applyPreset(projectorId, presetKey) {
            const projector = state.projectors.find(p => p.id === projectorId);
            const preset = projectorPresets[presetKey];
            if (!projector || !preset) return;
            
            projector.preset = presetKey;
            projector.lumens = preset.lumens;
            projector.throwRatio = preset.throwRatio;
            projector.aspectRatio = preset.aspectRatio;
            projector.resolution = preset.resolution;
            
            updateProjectorMesh(projector);
            updateProjectorList();
            updatePropertiesPanel();
        }
        
        function removeProjector(id) {
            state.projectors = state.projectors.filter(p => p.id !== id);
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
            if (mesh) projectorGroup.remove(mesh);
            projectorMatrixData.delete(id);
            projectionTextures.delete(id);
            customTextureData.delete(id);
            
            if (state.selectedType === 'projector' && state.selectedObject === id) {
                state.selectedObject = null;
                state.selectedType = null;
                updatePropertiesPanel();
            }
            
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            calculateCoverage();
        }
        
        function loadCustomTexture(projectorId, file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    
                    const projector = state.projectors.find(p => p.id === projectorId);
                    if (projector) {
                        projector.customTextureUrl = e.target.result;
                        customTextureData.set(projectorId, texture);
                        projectionTextures.set(projectorId, texture);
                        updateAllSurfaceMaterials();
                        updatePropertiesPanel();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function clearCustomTexture(projectorId) {
            const projector = state.projectors.find(p => p.id === projectorId);
            if (projector) {
                projector.customTextureUrl = null;
                customTextureData.delete(projectorId);
                projectionTextures.set(projectorId, createPatternTexture(state.currentPattern));
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
            }
        }
        
        function updateProjectorList() {
            const list = document.getElementById('projector-list');
            document.getElementById('projector-count').textContent = state.projectors.length;
            
            if (state.projectors.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No projectors yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.projectors.map(p => `
                <div class="object-item ${state.selectedType === 'projector' && state.selectedObject === p.id ? 'selected' : ''}" onclick="selectObject('projector', ${p.id})">
                    <div class="object-icon projector"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                    <div class="object-info">
                        <div class="object-name">${p.name}</div>
                        <div class="object-type">${(p.lumens/1000).toFixed(0)}K lm${p.customTextureUrl ? ' • Custom' : ''}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn" onclick="event.stopPropagation(); duplicateProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>
            `).join('');
        }
        
        function duplicateProjector(id) {
            const orig = state.projectors.find(p => p.id === id);
            if (!orig) return;
            const dup = { ...JSON.parse(JSON.stringify(orig)), id: Date.now(), name: orig.name + ' (Copy)', position: { ...orig.position, x: orig.position.x + 2 }, customTextureUrl: null };
            state.projectors.push(dup);
            createProjectorMesh(dup);
            updateProjectorMatrix(dup);
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', dup.id);
            calculateCoverage();
        }
        
        // ==========================================
        // SURFACE
        // ==========================================
        
        function addSurface() {
            const id = Date.now();
            const surface = {
                id,
                name: `Surface ${state.surfaces.length + 1}`,
                type: 'flat',
                position: { x: 0, y: 3, z: 5 },
                rotation: { x: 0, y: 180, z: 0 },
                dimensions: { width: 8, height: 4.5 },
                curvature: 30,
                color: '#555555',
                gain: 1.0
            };
            
            state.surfaces.push(surface);
            createSurfaceMesh(surface);
            updateSurfaceList();
            updateStatus();
            selectObject('surface', id);
            calculateCoverage();
        }
        
        function createSurfaceMaterial(surface) {
            const defaultTex = createPatternTexture('none');
            
            const uniforms = {
                projTex0: { value: defaultTex }, projTex1: { value: defaultTex },
                projTex2: { value: defaultTex }, projTex3: { value: defaultTex },
                projMat0: { value: new THREE.Matrix4() }, projMat1: { value: new THREE.Matrix4() },
                projMat2: { value: new THREE.Matrix4() }, projMat3: { value: new THREE.Matrix4() },
                projPos0: { value: new THREE.Vector3() }, projPos1: { value: new THREE.Vector3() },
                projPos2: { value: new THREE.Vector3() }, projPos3: { value: new THREE.Vector3() },
                projLumens0: { value: 0 }, projLumens1: { value: 0 },
                projLumens2: { value: 0 }, projLumens3: { value: 0 },
                projThrow0: { value: 1.5 }, projThrow1: { value: 1.5 },
                projThrow2: { value: 1.5 }, projThrow3: { value: 1.5 },
                numProjectors: { value: 0 },
                showCoverage: { value: state.displayOptions.coverage },
                showOverlap: { value: state.displayOptions.overlap },
                showHeatmap: { value: state.displayOptions.heatmap },
                surfaceGain: { value: surface.gain },
                baseColor: { value: new THREE.Color(surface.color) },
                heatmapMax: { value: state.heatmapMax }
            };
            
            const enabled = state.projectors.filter(p => p.enabled);
            uniforms.numProjectors.value = enabled.length;
            
            enabled.slice(0, 4).forEach((proj, i) => {
                const data = projectorMatrixData.get(proj.id);
                const tex = projectionTextures.get(proj.id);
                if (data) {
                    uniforms[`projMat${i}`].value.copy(data.matrix);
                    uniforms[`projPos${i}`].value.copy(data.position);
                    uniforms[`projLumens${i}`].value = data.lumens;
                    uniforms[`projThrow${i}`].value = data.throwRatio;
                }
                if (tex) uniforms[`projTex${i}`].value = tex;
            });
            
            return new THREE.ShaderMaterial({
                uniforms,
                vertexShader: projectionVertexShader,
                fragmentShader: projectionFragmentShader,
                side: THREE.DoubleSide
            });
        }
        
        function createSurfaceMesh(surface) {
            let geom;
            if (surface.type === 'curved' && surface.curvature > 0) {
                const angle = surface.curvature * Math.PI / 180;
                const radius = surface.dimensions.width / Math.max(angle, 0.01);
                geom = new THREE.CylinderGeometry(radius, radius, surface.dimensions.height, 64, 1, true, Math.PI - angle/2, angle);
            } else {
                geom = new THREE.PlaneGeometry(surface.dimensions.width, surface.dimensions.height, 32, 32);
            }
            
            const mesh = new THREE.Mesh(geom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface; // Store reference for coverage calculation
            mesh.position.set(surface.position.x, surface.position.y, surface.position.z);
            mesh.rotation.set(
                THREE.MathUtils.degToRad(surface.rotation.x),
                THREE.MathUtils.degToRad(surface.rotation.y),
                THREE.MathUtils.degToRad(surface.rotation.z)
            );
            surfaceGroup.add(mesh);
        }
        
        function updateSurfaceMesh(surface) {
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
            if (mesh) {
                mesh.material.dispose();
                mesh.geometry.dispose();
                surfaceGroup.remove(mesh);
                createSurfaceMesh(surface);
            }
            calculateCoverage();
        }
        
        function updateAllSurfaceMaterials() {
            state.projectors.forEach(p => {
                if (!p.customTextureUrl) {
                    projectionTextures.set(p.id, createPatternTexture(state.currentPattern));
                }
            });
            
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (mesh) {
                    mesh.material.dispose();
                    mesh.material = createSurfaceMaterial(surface);
                }
            });
        }
        
        function removeSurface(id) {
            state.surfaces = state.surfaces.filter(s => s.id !== id);
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
            if (mesh) { mesh.material.dispose(); mesh.geometry.dispose(); surfaceGroup.remove(mesh); }
            if (state.selectedType === 'surface' && state.selectedObject === id) {
                state.selectedObject = null; state.selectedType = null; updatePropertiesPanel();
            }
            updateSurfaceList(); updateStatus(); calculateCoverage();
        }
        
        function updateSurfaceList() {
            const list = document.getElementById('surface-list');
            document.getElementById('surface-count').textContent = state.surfaces.length;
            
            if (state.surfaces.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No surfaces yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.surfaces.map(s => `
                <div class="object-item ${state.selectedType === 'surface' && state.selectedObject === s.id ? 'selected' : ''}" onclick="selectObject('surface', ${s.id})">
                    <div class="object-icon surface"><svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg></div>
                    <div class="object-info">
                        <div class="object-name">${s.name}</div>
                        <div class="object-type">${s.dimensions.width}m × ${s.dimensions.height}m • Gain ${s.gain}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeSurface(${s.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>
            `).join('');
        }
        
        // ==========================================
        // COVERAGE CALCULATION - PROPER IMPLEMENTATION
        // ==========================================
        
        function calculateCoverage() {
            if (state.surfaces.length === 0 || state.projectors.filter(p => p.enabled).length === 0) {
                updateCoverageDisplay(0, 0, 0, 0);
                return;
            }
            
            let totalSamples = 0;
            let coveredSamples = 0;
            let totalCdm2 = 0;
            let minCdm2 = Infinity;
            let maxCdm2 = 0;
            let cdm2Samples = [];
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            
            // Sample each surface
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (!mesh) return;
                
                const sampleResolution = 20; // 20x20 grid per surface
                const w = surface.dimensions.width;
                const h = surface.dimensions.height;
                
                for (let iy = 0; iy < sampleResolution; iy++) {
                    for (let ix = 0; ix < sampleResolution; ix++) {
                        // Local position on surface (-0.5 to 0.5)
                        const lx = (ix / (sampleResolution - 1) - 0.5) * w;
                        const ly = (iy / (sampleResolution - 1) - 0.5) * h;
                        
                        // Transform to world position
                        const localPos = new THREE.Vector3(lx, ly, 0);
                        const worldPos = localPos.applyMatrix4(mesh.matrixWorld);
                        
                        // Get world normal
                        const localNormal = new THREE.Vector3(0, 0, 1);
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                        const worldNormal = localNormal.applyMatrix3(normalMatrix).normalize();
                        
                        totalSamples++;
                        let sampleCdm2 = 0;
                        let isHit = false;
                        
                        enabledProjectors.forEach(proj => {
                            const data = projectorMatrixData.get(proj.id);
                            if (!data) return;
                            
                            // Check if point is within projector frustum
                            const projCoord = new THREE.Vector4(worldPos.x, worldPos.y, worldPos.z, 1);
                            projCoord.applyMatrix4(data.matrix);
                            
                            if (projCoord.w <= 0) return;
                            
                            const ndc = new THREE.Vector3(
                                projCoord.x / projCoord.w,
                                projCoord.y / projCoord.w,
                                projCoord.z / projCoord.w
                            );
                            
                            const uv = new THREE.Vector2(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
                            
                            if (uv.x < 0 || uv.x > 1 || uv.y < 0 || uv.y > 1) return;
                            if (ndc.z < -1 || ndc.z > 1) return;
                            
                            // Check facing
                            const toProj = new THREE.Vector3().subVectors(data.position, worldPos).normalize();
                            const facing = worldNormal.dot(toProj);
                            if (facing <= 0) return;
                            
                            isHit = true;
                            
                            // Calculate luminance in cd/m²
                            // cd/m² = (lumens / area) × gain / π × cos(angle)
                            const dist = data.position.distanceTo(worldPos);
                            const projWidth = dist / data.throwRatio;
                            const projHeight = projWidth / (16/9);
                            const projArea = projWidth * projHeight;
                            const lux = data.lumens / projArea;
                            const cdm2 = (lux * surface.gain / Math.PI) * facing;
                            
                            sampleCdm2 += cdm2;
                        });
                        
                        if (isHit) {
                            coveredSamples++;
                            cdm2Samples.push(sampleCdm2);
                            totalCdm2 += sampleCdm2;
                            minCdm2 = Math.min(minCdm2, sampleCdm2);
                            maxCdm2 = Math.max(maxCdm2, sampleCdm2);
                        }
                    }
                }
            });
            
            const coverage = totalSamples > 0 ? (coveredSamples / totalSamples) * 100 : 0;
            const avgCdm2 = cdm2Samples.length > 0 ? totalCdm2 / cdm2Samples.length : 0;
            
            updateCoverageDisplay(
                coverage,
                avgCdm2,
                minCdm2 === Infinity ? 0 : minCdm2,
                maxCdm2
            );
        }
        
        function updateCoverageDisplay(coverage, avgCdm2, minCdm2, maxCdm2) {
            document.getElementById('coverage-fill').style.width = coverage + '%';
            document.getElementById('coverage-percent').textContent = coverage.toFixed(1) + '%';
            document.getElementById('avg-cdm2').textContent = Math.round(avgCdm2).toLocaleString();
            document.getElementById('min-cdm2').textContent = Math.round(minCdm2).toLocaleString();
            document.getElementById('max-cdm2').textContent = Math.round(maxCdm2).toLocaleString();
        }
        
        // ==========================================
        // SELECTION & PROPERTIES
        // ==========================================
        
        function selectObject(type, id) {
            state.selectedType = type;
            state.selectedObject = id;
            updateProjectorList();
            updateSurfaceList();
            updatePropertiesPanel();
        }
        
        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-panel');
            
            if (!state.selectedObject) {
                panel.innerHTML = `<div class="no-selection"><div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div><h3>No Selection</h3><p>Select an object to edit.</p></div>`;
                return;
            }
            
            if (state.selectedType === 'projector') {
                const p = state.projectors.find(x => x.id === state.selectedObject);
                if (!p) return;
                
                const presetOptions = Object.entries(projectorPresets).map(([key, val]) => 
                    `<option value="${key}" ${p.preset === key ? 'selected' : ''}>${val.name}</option>`
                ).join('');
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Projector</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${p.name}" onchange="updateProjectorProp(${p.id}, 'name', this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Preset</span><div class="single-input"><select onchange="applyPreset(${p.id}, this.value)">${presetOptions}</select></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${p.position.x}" onchange="updateProjectorPos(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${p.position.y}" onchange="updateProjectorPos(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${p.position.z}" onchange="updateProjectorPos(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${p.rotation.x}" onchange="updateProjectorRot(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${p.rotation.y}" onchange="updateProjectorRot(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${p.rotation.z}" onchange="updateProjectorRot(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Optics</div>
                            <div class="slider-row"><span class="slider-label">Throw Ratio</span><div class="slider-container"><input type="range" class="slider" min="0.3" max="3" step="0.05" value="${p.throwRatio}" oninput="updateProjectorProp(${p.id}, 'throwRatio', +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(2)"><span class="slider-value">${p.throwRatio.toFixed(2)}</span></div></div>
                            <div class="slider-row"><span class="slider-label">Zoom</span><div class="slider-container"><input type="range" class="slider" min="0.8" max="1.5" step="0.01" value="${p.zoom}" oninput="updateProjectorProp(${p.id}, 'zoom', +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(2)+'x'"><span class="slider-value">${p.zoom.toFixed(2)}x</span></div></div>
                            <div class="property-row"><span class="property-label">Lumens</span><div class="single-input"><input type="number" step="1000" value="${p.lumens}" onchange="updateProjectorProp(${p.id}, 'lumens', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Resolution</span><div class="single-input"><input type="text" value="${p.resolution || '1920×1080'}" readonly style="opacity: 0.6;"></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Custom Texture</div>
                            ${p.customTextureUrl ? `
                                <div class="texture-preview" style="background-image: url('${p.customTextureUrl}')"></div>
                                <button class="btn clear-texture-btn" onclick="clearCustomTexture(${p.id})">Clear Custom Texture</button>
                            ` : `
                                <div class="texture-upload" onclick="document.getElementById('tex-upload-${p.id}').click()">
                                    <input type="file" id="tex-upload-${p.id}" accept="image/*" onchange="loadCustomTexture(${p.id}, this.files[0])">
                                    <p>Click to upload image</p>
                                </div>
                            `}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Display</div>
                            <div class="toggle-row"><span class="toggle-label">Enabled</span><div class="toggle ${p.enabled ? 'active' : ''}" onclick="toggleProjectorEnabled(${p.id})"></div></div>
                        </div>
                    </div></div>`;
            } else if (state.selectedType === 'surface') {
                const s = state.surfaces.find(x => x.id === state.selectedObject);
                if (!s) return;
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Surface</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${s.name}" onchange="updateSurfaceProp(${s.id}, 'name', this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Type</span><div class="single-input"><select onchange="updateSurfaceProp(${s.id}, 'type', this.value)"><option value="flat" ${s.type==='flat'?'selected':''}>Flat</option><option value="curved" ${s.type==='curved'?'selected':''}>Curved</option></select></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${s.position.x}" onchange="updateSurfacePos(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${s.position.y}" onchange="updateSurfacePos(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${s.position.z}" onchange="updateSurfacePos(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${s.rotation.x}" onchange="updateSurfaceRot(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${s.rotation.y}" onchange="updateSurfaceRot(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${s.rotation.z}" onchange="updateSurfaceRot(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Width (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'width', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Height (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.height}" onchange="updateSurfaceDim(${s.id}, 'height', +this.value)"></div></div>
                            ${s.type === 'curved' ? `<div class="slider-row"><span class="slider-label">Curvature</span><div class="slider-container"><input type="range" class="slider" min="5" max="180" value="${s.curvature}" oninput="updateSurfaceProp(${s.id}, 'curvature', +this.value); this.nextElementSibling.textContent=this.value+'°'"><span class="slider-value">${s.curvature}°</span></div></div>` : ''}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Screen Properties</div>
                            <div class="slider-row"><span class="slider-label">Screen Gain</span><div class="slider-container"><input type="range" class="slider" min="0.5" max="2.5" step="0.1" value="${s.gain}" oninput="updateSurfaceProp(${s.id}, 'gain', +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(1)"><span class="slider-value">${s.gain.toFixed(1)}</span></div></div>
                        </div>
                    </div></div>`;
            }
        }
        
        // ==========================================
        // PROPERTY HANDLERS
        // ==========================================
        
        function updateProjectorProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p[prop] = val;
                if (prop !== 'name') p.preset = 'custom';
                updateProjectorMesh(p);
                updateProjectorList();
            }
        }
        
        function updateProjectorPos(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) { p.position[axis] = val; updateProjectorMesh(p); }
        }
        
        function updateProjectorRot(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) { p.rotation[axis] = val; updateProjectorMesh(p); }
        }
        
        function toggleProjectorEnabled(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p.enabled = !p.enabled;
                const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
                if (mesh) mesh.visible = p.enabled;
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
                calculateCoverage();
            }
        }
        
        function updateSurfaceProp(id, prop, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) { s[prop] = val; updateSurfaceMesh(s); updateSurfaceList(); updatePropertiesPanel(); }
        }
        
        function updateSurfacePos(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) { s.position[axis] = val; updateSurfaceMesh(s); }
        }
        
        function updateSurfaceRot(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) { s.rotation[axis] = val; updateSurfaceMesh(s); }
        }
        
        function updateSurfaceDim(id, dim, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) { s.dimensions[dim] = val; updateSurfaceMesh(s); }
        }
        
        // ==========================================
        // VIEW & OPTIONS
        // ==========================================
        
        function setView(view) {
            state.currentView = view;
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            const views = {
                perspective: () => { camera.position.set(0, 8, -18); camera.rotation.set(0, Math.PI, 0); },
                top: () => { camera.position.set(0, 25, 0.01); camera.rotation.set(-Math.PI/2, 0, 0); },
                front: () => { camera.position.set(0, 3, -20); camera.rotation.set(0, Math.PI, 0); },
                side: () => { camera.position.set(-20, 3, 0); camera.rotation.set(0, Math.PI/2, 0); },
                projector: () => {
                    let p = null;
                    if (state.selectedType === 'projector' && state.selectedObject) {
                        p = state.projectors.find(x => x.id === state.selectedObject);
                    }
                    if (!p && state.projectors.length) p = state.projectors[0];
                    if (p) {
                        camera.position.set(p.position.x, p.position.y, p.position.z);
                        const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(
                            THREE.MathUtils.degToRad(p.rotation.x),
                            THREE.MathUtils.degToRad(p.rotation.y),
                            THREE.MathUtils.degToRad(p.rotation.z), 'YXZ'
                        ));
                        camera.lookAt(p.position.x + forward.x * 10, p.position.y + forward.y * 10, p.position.z + forward.z * 10);
                    }
                }
            };
            views[view]?.();
            document.getElementById('camera-info').textContent = view.charAt(0).toUpperCase() + view.slice(1);
        }
        
        function toggleOption(opt) {
            state.displayOptions[opt] = !state.displayOptions[opt];
            document.getElementById(`toggle-${opt}`).classList.toggle('active', state.displayOptions[opt]);
            
            if (opt === 'frustums') projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
            else if (opt === 'grid') gridHelper.visible = state.displayOptions.grid;
            else if (opt === 'wireframe') surfaceGroup.children.forEach(m => { if (m.material) m.material.wireframe = state.displayOptions.wireframe; });
            else if (opt === 'heatmap') {
                document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) m.material.uniforms.showHeatmap.value = state.displayOptions.heatmap;
                });
            }
            else if (opt === 'coverage' || opt === 'overlap') {
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) {
                        m.material.uniforms.showCoverage.value = state.displayOptions.coverage;
                        m.material.uniforms.showOverlap.value = state.displayOptions.overlap;
                    }
                });
            }
        }
        
        function updateHeatmapMax(value) {
            state.heatmapMax = value;
            document.getElementById('legend-mid').textContent = Math.round(value / 2);
            document.getElementById('legend-max').textContent = value + '+';
            
            // Update all surface materials with new heatmap max
            surfaceGroup.children.forEach(m => {
                if (m.material?.uniforms?.heatmapMax) {
                    m.material.uniforms.heatmapMax.value = value;
                }
            });
        }
        
        function setPattern(pattern) {
            state.currentPattern = pattern;
            document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            updateAllSurfaceMaterials();
        }
        
        // ==========================================
        // UTILITY
        // ==========================================
        
        function updateStatus() {
            document.getElementById('projector-status').textContent = state.projectors.length + ' Projector' + (state.projectors.length !== 1 ? 's' : '');
            document.getElementById('surface-status').textContent = state.surfaces.length + ' Surface' + (state.surfaces.length !== 1 ? 's' : '');
        }
        
        function resetScene() {
            while (projectorGroup.children.length) projectorGroup.remove(projectorGroup.children[0]);
            while (surfaceGroup.children.length) { const m = surfaceGroup.children[0]; m.material?.dispose(); m.geometry?.dispose(); surfaceGroup.remove(m); }
            state.projectors = []; state.surfaces = []; state.selectedObject = null; state.selectedType = null;
            projectorMatrixData.clear(); projectionTextures.clear(); customTextureData.clear();
            updateProjectorList(); updateSurfaceList(); updatePropertiesPanel(); updateStatus();
            updateCoverageDisplay(0, 0, 0, 0);
        }
        
        // ==========================================
        // IMPORT / EXPORT
        // ==========================================
        
        const exportOptions = {
            projectors: true,
            surfaces: true,
            settings: true,
            textures: false
        };
        
        const importOptions = {
            replace: true,
            merge: false
        };
        
        let pendingImportData = null;
        
        function showExportModal() {
            // Update counts
            document.getElementById('export-projector-count').textContent = 
                `${state.projectors.length} projector${state.projectors.length !== 1 ? 's' : ''} with settings`;
            document.getElementById('export-surface-count').textContent = 
                `${state.surfaces.length} surface${state.surfaces.length !== 1 ? 's' : ''} with settings`;
            
            const textureCount = state.projectors.filter(p => p.customTextureUrl).length;
            document.getElementById('export-texture-count').textContent = 
                textureCount > 0 ? `${textureCount} custom texture${textureCount !== 1 ? 's' : ''} (increases file size)` : 'No custom textures';
            
            // Set default filename with timestamp
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`;
            document.getElementById('export-filename').value = `projection-config-${timestamp}`;
            
            document.getElementById('export-modal').classList.add('active');
        }
        
        function toggleExportOption(option) {
            exportOptions[option] = !exportOptions[option];
            const checkbox = document.getElementById(`export-check-${option}`);
            checkbox.classList.toggle('checked', exportOptions[option]);
        }
        
        function toggleImportOption(option) {
            // Radio-button behavior for replace/merge
            if (option === 'replace') {
                importOptions.replace = true;
                importOptions.merge = false;
            } else if (option === 'merge') {
                importOptions.replace = false;
                importOptions.merge = true;
            }
            
            document.getElementById('import-check-replace').classList.toggle('checked', importOptions.replace);
            document.getElementById('import-check-merge').classList.toggle('checked', importOptions.merge);
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            if (id === 'import-modal') {
                pendingImportData = null;
            }
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            
            toastMessage.textContent = message;
            toast.className = `toast ${type} active`;
            
            // Update icon based on type
            const svg = toast.querySelector('svg');
            if (type === 'success') {
                svg.innerHTML = '<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>';
            } else if (type === 'error') {
                svg.innerHTML = '<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>';
            }
            
            setTimeout(() => {
                toast.classList.remove('active');
            }, 3000);
        }
        
        function doExport() {
            const filename = document.getElementById('export-filename').value.trim() || 'projection-config';
            
            const config = {
                version: '2.3',
                exportDate: new Date().toISOString(),
                metadata: {
                    projectorCount: state.projectors.length,
                    surfaceCount: state.surfaces.length
                }
            };
            
            if (exportOptions.projectors) {
                config.projectors = state.projectors.map(p => {
                    const proj = { ...p };
                    if (!exportOptions.textures) {
                        proj.customTextureUrl = null;
                    }
                    return proj;
                });
            }
            
            if (exportOptions.surfaces) {
                config.surfaces = [...state.surfaces];
            }
            
            if (exportOptions.settings) {
                config.settings = {
                    currentPattern: state.currentPattern,
                    displayOptions: { ...state.displayOptions },
                    heatmapMax: state.heatmapMax,
                    currentView: state.currentView
                };
            }
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeModal('export-modal');
            showToast(`Exported "${filename}.json" successfully`);
        }
        
        function importConfig(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    pendingImportData = data;
                    
                    // Update preview
                    document.getElementById('import-version').textContent = data.version || 'Unknown';
                    document.getElementById('import-projectors').textContent = 
                        data.projectors ? `${data.projectors.length} projector${data.projectors.length !== 1 ? 's' : ''}` : 'None';
                    document.getElementById('import-surfaces').textContent = 
                        data.surfaces ? `${data.surfaces.length} surface${data.surfaces.length !== 1 ? 's' : ''}` : 'None';
                    
                    const textureCount = data.projectors ? data.projectors.filter(p => p.customTextureUrl).length : 0;
                    document.getElementById('import-textures').textContent = 
                        textureCount > 0 ? `${textureCount} embedded` : 'None';
                    
                    document.getElementById('import-settings').textContent = 
                        data.settings ? 'Included' : 'Not included';
                    
                    // Show modal
                    document.getElementById('import-modal').classList.add('active');
                    
                    // Clear file input so same file can be selected again
                    document.getElementById('import-file').value = '';
                    
                } catch (err) {
                    showToast('Error parsing file: Invalid JSON format', 'error');
                    console.error('Import error:', err);
                }
            };
            reader.onerror = function() {
                showToast('Error reading file', 'error');
            };
            reader.readAsText(file);
        }
        
        function doImport() {
            if (!pendingImportData) {
                showToast('No import data available', 'error');
                return;
            }
            
            const data = pendingImportData;
            
            // Clear scene if replacing
            if (importOptions.replace) {
                resetScene();
            }
            
            let importedProjectors = 0;
            let importedSurfaces = 0;
            
            // Import projectors
            if (data.projectors && Array.isArray(data.projectors)) {
                data.projectors.forEach(projData => {
                    const id = Date.now() + Math.random() * 1000;
                    const projector = {
                        id,
                        name: projData.name || `Projector ${state.projectors.length + 1}`,
                        preset: projData.preset || 'custom',
                        position: projData.position || { x: 0, y: 4, z: -8 },
                        rotation: projData.rotation || { x: -10, y: 0, z: 0 },
                        lumens: projData.lumens || 10000,
                        throwRatio: projData.throwRatio || 1.5,
                        aspectRatio: projData.aspectRatio || 16/9,
                        resolution: projData.resolution || '1920×1080',
                        zoom: projData.zoom || 1.0,
                        enabled: projData.enabled !== false,
                        customTextureUrl: projData.customTextureUrl || null
                    };
                    
                    state.projectors.push(projector);
                    createProjectorMesh(projector);
                    
                    // Load custom texture if present
                    if (projector.customTextureUrl) {
                        const img = new Image();
                        img.onload = function() {
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            customTextureData.set(projector.id, texture);
                            projectionTextures.set(projector.id, texture);
                            updateAllSurfaceMaterials();
                        };
                        img.src = projector.customTextureUrl;
                    }
                    
                    updateProjectorMatrix(projector);
                    importedProjectors++;
                });
            }
            
            // Import surfaces
            if (data.surfaces && Array.isArray(data.surfaces)) {
                data.surfaces.forEach(surfData => {
                    const id = Date.now() + Math.random() * 1000;
                    const surface = {
                        id,
                        name: surfData.name || `Surface ${state.surfaces.length + 1}`,
                        type: surfData.type || 'flat',
                        position: surfData.position || { x: 0, y: 3, z: 5 },
                        rotation: surfData.rotation || { x: 0, y: 180, z: 0 },
                        dimensions: surfData.dimensions || { width: 8, height: 4.5 },
                        curvature: surfData.curvature || 30,
                        color: surfData.color || '#555555',
                        gain: surfData.gain || 1.0
                    };
                    
                    state.surfaces.push(surface);
                    createSurfaceMesh(surface);
                    importedSurfaces++;
                });
            }
            
            // Import settings
            if (data.settings) {
                if (data.settings.currentPattern) {
                    state.currentPattern = data.settings.currentPattern;
                    document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                    // Try to activate the right pattern button
                    const patternBtns = document.querySelectorAll('.pattern-btn');
                    const patterns = ['none', 'grid', 'checker', 'gradient', 'colorbars', 'cross', 'white', 'blend'];
                    const idx = patterns.indexOf(data.settings.currentPattern);
                    if (idx >= 0 && patternBtns[idx]) patternBtns[idx].classList.add('active');
                }
                
                if (data.settings.displayOptions) {
                    Object.keys(data.settings.displayOptions).forEach(key => {
                        if (state.displayOptions.hasOwnProperty(key)) {
                            state.displayOptions[key] = data.settings.displayOptions[key];
                            const toggle = document.getElementById(`toggle-${key}`);
                            if (toggle) toggle.classList.toggle('active', state.displayOptions[key]);
                        }
                    });
                    
                    // Apply display options
                    projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
                    gridHelper.visible = state.displayOptions.grid;
                    document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                }
                
                if (data.settings.heatmapMax) {
                    state.heatmapMax = data.settings.heatmapMax;
                    document.getElementById('heatmap-max-slider').value = data.settings.heatmapMax;
                    document.getElementById('heatmap-max-value').textContent = data.settings.heatmapMax;
                    document.getElementById('legend-mid').textContent = Math.round(data.settings.heatmapMax / 2);
                    document.getElementById('legend-max').textContent = data.settings.heatmapMax + '+';
                }
            }
            
            // Update UI
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateSurfaceList();
            updateStatus();
            calculateCoverage();
            
            closeModal('import-modal');
            
            const message = `Imported ${importedProjectors} projector${importedProjectors !== 1 ? 's' : ''} and ${importedSurfaces} surface${importedSurfaces !== 1 ? 's' : ''}`;
            showToast(message);
        }
        
        function quickSave() {
            // Quick save with current timestamp
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}_${String(date.getHours()).padStart(2,'0')}-${String(date.getMinutes()).padStart(2,'0')}`;
            
            const config = {
                version: '2.3',
                exportDate: date.toISOString(),
                metadata: {
                    projectorCount: state.projectors.length,
                    surfaceCount: state.surfaces.length
                },
                projectors: state.projectors.map(p => ({ ...p })),
                surfaces: [...state.surfaces],
                settings: {
                    currentPattern: state.currentPattern,
                    displayOptions: { ...state.displayOptions },
                    heatmapMax: state.heatmapMax,
                    currentView: state.currentView
                }
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `projection-autosave-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Project saved successfully');
        }
        
        function confirmNewProject() {
            if (state.projectors.length === 0 && state.surfaces.length === 0) {
                // Nothing to lose, just reset
                resetScene();
                showToast('New project created');
                return;
            }
            
            if (confirm('Start a new project? All unsaved changes will be lost.')) {
                resetScene();
                showToast('New project created');
            }
        }
        
        // ==========================================
        // ANIMATION
        // ==========================================
        
        let lastTime = performance.now(), frames = 0;
        function animate() {
            requestAnimationFrame(animate);
            updateCameraMovement();
            frames++;
            if (performance.now() - lastTime >= 1000) {
                document.getElementById('fps-counter').textContent = frames + ' FPS';
                frames = 0; lastTime = performance.now();
            }
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
