<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta author="Joe Loe">
    <title>Projection Study Configurator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0c;
            --bg-secondary: #111114;
            --bg-tertiary: #18181c;
            --bg-panel: #141418;
            --border-color: #2a2a32;
            --border-hover: #3a3a44;
            --text-primary: #e8e8ec;
            --text-secondary: #9898a4;
            --text-muted: #5c5c68;
            --accent-primary: #00d4aa;
            --accent-secondary: #00a888;
            --accent-glow: rgba(0, 212, 170, 0.15);
            --warning: #ffaa00;
            --danger: #ff4466;
            --projector-color: #00aaff;
            --surface-color: #8844ff;
        }
        
        body { font-family: 'Outfit', sans-serif; background: var(--bg-primary); color: var(--text-primary); height: 100vh; overflow: hidden; }
        .app-container { display: grid; grid-template-columns: 320px 1fr 360px; grid-template-rows: 56px 1fr 48px; height: 100vh; }
        
        .header { grid-column: 1 / -1; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent-primary), var(--projector-color)); border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .logo-icon svg { width: 18px; height: 18px; fill: var(--bg-primary); }
        .logo-text { font-weight: 600; font-size: 16px; letter-spacing: -0.02em; }
        .logo-text span { color: var(--text-secondary); font-weight: 400; }
        .header-actions { display: flex; gap: 8px; }
        
        .btn { font-family: 'Outfit', sans-serif; padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; align-items: center; gap: 6px; }
        .btn:hover { background: var(--bg-panel); border-color: var(--border-hover); }
        .btn-primary { background: var(--accent-primary); border-color: var(--accent-primary); color: var(--bg-primary); }
        .btn-primary:hover { background: var(--accent-secondary); border-color: var(--accent-secondary); }
        .btn svg { width: 14px; height: 14px; }
        
        .sidebar-left, .sidebar-right { background: var(--bg-secondary); overflow-y: auto; }
        .sidebar-left { border-right: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .sidebar-right { border-left: 1px solid var(--border-color); }
        
        .panel-section { border-bottom: 1px solid var(--border-color); }
        .panel-header { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; }
        .panel-header:hover { background: var(--bg-tertiary); }
        .panel-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-secondary); }
        .panel-content { padding: 0 16px 16px; }
        .panel-badge { background: var(--bg-tertiary); padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 500; color: var(--text-muted); }
        
        .object-list { display: flex; flex-direction: column; gap: 4px; }
        .object-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; cursor: pointer; transition: all 0.15s ease; border: 1px solid transparent; }
        .object-item:hover { background: var(--bg-panel); }
        .object-item.selected { border-color: var(--accent-primary); background: var(--accent-glow); }
        .object-icon { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .object-icon.projector { background: rgba(0, 170, 255, 0.15); }
        .object-icon.projector svg { fill: var(--projector-color); }
        .object-icon.surface { background: rgba(136, 68, 255, 0.15); }
        .object-icon.surface svg { fill: var(--surface-color); }
        .object-icon svg { width: 14px; height: 14px; }
        .object-info { flex: 1; min-width: 0; }
        .object-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .object-type { font-size: 11px; color: var(--text-muted); }
        .object-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s ease; }
        .object-item:hover .object-actions { opacity: 1; }
        
        .icon-btn { width: 24px; height: 24px; border-radius: 4px; border: none; background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .icon-btn:hover { background: var(--border-color); color: var(--text-primary); }
        .icon-btn.danger:hover { background: rgba(255, 68, 102, 0.2); color: var(--danger); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }
        
        .add-buttons { display: flex; gap: 8px; padding: 16px; border-top: 1px solid var(--border-color); margin-top: auto; }
        .add-btn { flex: 1; padding: 10px; border-radius: 6px; border: 1px dashed var(--border-color); background: transparent; color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .add-btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); background: var(--accent-glow); }
        .add-btn svg { width: 18px; height: 18px; fill: currentColor; }
        
        .property-group { margin-bottom: 16px; }
        .property-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 10px; }
        .property-row { display: flex; align-items: center; margin-bottom: 8px; }
        .property-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .property-inputs { display: flex; gap: 4px; flex: 1; }
        .input-group { flex: 1; position: relative; }
        .input-group label { position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-size: 10px; font-weight: 600; color: var(--text-muted); pointer-events: none; }
        .input-group input { width: 100%; padding: 8px 8px 8px 22px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .input-group input:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        .single-input { flex: 1; }
        .single-input input, .single-input select { width: 100%; padding: 8px 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .single-input select { font-family: 'Outfit', sans-serif; cursor: pointer; }
        .single-input input:focus, .single-input select:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        
        .slider-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .slider-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .slider-container { flex: 1; display: flex; align-items: center; gap: 10px; }
        .slider { flex: 1; -webkit-appearance: none; height: 4px; border-radius: 2px; background: var(--border-color); outline: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; }
        .slider-value { width: 50px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-secondary); text-align: right; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .toggle-label { font-size: 12px; color: var(--text-secondary); }
        .toggle { width: 36px; height: 20px; border-radius: 10px; background: var(--border-color); cursor: pointer; position: relative; transition: background 0.2s ease; }
        .toggle.active { background: var(--accent-primary); }
        .toggle::after { content: ''; position: absolute; width: 16px; height: 16px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: transform 0.2s ease; }
        .toggle.active::after { transform: translateX(16px); }
        
        .viewport { background: var(--bg-primary); position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; }
        #canvas-container canvas { display: block; }
        
        .viewport-overlay { position: absolute; top: 12px; left: 12px; display: flex; gap: 8px; }
        .view-btn { padding: 6px 12px; border-radius: 4px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 11px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; }
        .view-btn:hover, .view-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); }
        
        .transform-tools { position: absolute; top: 12px; right: 12px; display: flex; gap: 4px; }
        .tool-btn { width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .tool-btn:hover { border-color: var(--border-hover); color: var(--text-primary); }
        .tool-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); background: rgba(0, 212, 170, 0.1); }
        .tool-btn svg { width: 18px; height: 18px; fill: currentColor; }
        .tool-btn.disabled { opacity: 0.4; pointer-events: none; }
        .tool-divider { width: 1px; background: var(--border-color); margin: 4px 4px; }
        
        .gizmo-info { position: absolute; top: 60px; right: 12px; background: rgba(17, 17, 20, 0.9); backdrop-filter: blur(8px); padding: 10px 14px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 11px; display: none; }
        .gizmo-info.visible { display: block; }
        .gizmo-info-title { color: var(--text-muted); margin-bottom: 6px; text-transform: uppercase; font-size: 9px; letter-spacing: 0.05em; }
        .gizmo-info-value { font-family: 'JetBrains Mono', monospace; color: var(--text-primary); }
        .gizmo-info-row { display: flex; gap: 12px; margin-top: 4px; }
        .gizmo-info-axis { display: flex; align-items: center; gap: 4px; }
        .gizmo-info-axis.x { color: #ff4444; }
        .gizmo-info-axis.y { color: #44ff44; }
        .gizmo-info-axis.z { color: #4488ff; }
        
        .distance-label { position: absolute; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px); color: #00ff00; padding: 6px 10px; border-radius: 4px; font-size: 11px; font-family: 'JetBrains Mono', monospace; pointer-events: none; white-space: nowrap; border: 1px solid rgba(0, 255, 0, 0.3); z-index: 100; transform: translate(-50%, -50%); }
        .distance-label strong { color: #fff; font-weight: 500; }
        
        .snap-controls { position: absolute; bottom: 60px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); display: flex; align-items: center; gap: 10px; }
        .snap-label { font-size: 10px; color: var(--text-muted); }
        .snap-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .snap-toggle input { display: none; }
        .snap-checkbox { width: 14px; height: 14px; border-radius: 3px; border: 1px solid var(--border-color); background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; }
        .snap-toggle input:checked + .snap-checkbox { background: var(--accent-primary); border-color: var(--accent-primary); }
        .snap-checkbox svg { width: 10px; height: 10px; fill: var(--bg-primary); opacity: 0; }
        .snap-toggle input:checked + .snap-checkbox svg { opacity: 1; }
        .snap-value { width: 50px; padding: 4px 6px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 10px; text-align: center; }
        .snap-value:focus { outline: none; border-color: var(--accent-primary); }
        
        .viewport-info { position: absolute; bottom: 12px; left: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 10px 14px; border-radius: 6px; border: 1px solid var(--border-color); }
        .viewport-info-row { display: flex; gap: 16px; font-size: 11px; }
        .viewport-info-item { display: flex; align-items: center; gap: 6px; }
        .viewport-info-item span:first-child { color: var(--text-muted); }
        .viewport-info-item span:last-child { font-family: 'JetBrains Mono', monospace; color: var(--text-secondary); }
        
        .controls-hint { position: absolute; bottom: 110px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 10px; color: var(--text-muted); }
        .controls-hint kbd { background: var(--bg-tertiary); padding: 2px 5px; border-radius: 3px; font-family: 'JetBrains Mono', monospace; margin: 0 2px; }
        
        .pattern-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .pattern-btn { aspect-ratio: 1; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); cursor: pointer; transition: all 0.15s ease; overflow: hidden; }
        .pattern-btn:hover { border-color: var(--border-hover); }
        .pattern-btn.active { border-color: var(--accent-primary); box-shadow: 0 0 0 1px var(--accent-primary); }
        .pattern-preview { width: 100%; height: 100%; }
        .pattern-grid-lines { background: linear-gradient(var(--text-muted) 1px, transparent 1px), linear-gradient(90deg, var(--text-muted) 1px, transparent 1px); background-size: 8px 8px; }
        .pattern-checker { background: repeating-conic-gradient(var(--text-muted) 0% 25%, var(--bg-tertiary) 0% 50%) 50% / 12px 12px; }
        .pattern-gradient { background: linear-gradient(90deg, #000, #fff); }
        .pattern-colorbars { background: linear-gradient(90deg, #fff 0% 14.28%, #ff0 14.28% 28.56%, #0ff 28.56% 42.84%, #0f0 42.84% 57.12%, #f0f 57.12% 71.4%, #f00 71.4% 85.68%, #00f 85.68% 100%); }
        .pattern-cross { background: var(--bg-tertiary); position: relative; }
        .pattern-cross::before, .pattern-cross::after { content: ''; position: absolute; background: var(--text-muted); }
        .pattern-cross::before { width: 1px; height: 100%; left: 50%; }
        .pattern-cross::after { height: 1px; width: 100%; top: 50%; }
        .pattern-white { background: #fff; }
        .pattern-none { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--text-muted); }
        .pattern-blend { background: linear-gradient(90deg, rgba(255,0,0,0.5) 0% 20%, transparent 20% 80%, rgba(0,255,0,0.5) 80% 100%); }
        
        .status-bar { grid-column: 1 / -1; background: var(--bg-tertiary); border-top: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; font-size: 11px; }
        .status-left, .status-right { display: flex; align-items: center; gap: 16px; }
        .status-item { display: flex; align-items: center; gap: 6px; color: var(--text-muted); }
        .status-item svg { width: 12px; height: 12px; fill: currentColor; }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent-primary); }
        
        .empty-state { padding: 24px 16px; text-align: center; }
        .empty-state p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        
        .no-selection { padding: 40px 20px; text-align: center; }
        .no-selection-icon { width: 48px; height: 48px; margin: 0 auto 16px; background: var(--bg-tertiary); border-radius: 12px; display: flex; align-items: center; justify-content: center; }
        .no-selection-icon svg { width: 24px; height: 24px; fill: var(--text-muted); }
        .no-selection h3 { font-size: 14px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary); }
        .no-selection p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        .coverage-display { margin-top: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; border: 1px solid var(--border-color); }
        .coverage-bar { height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; margin-top: 8px; }
        .coverage-fill { height: 100%; background: var(--accent-primary); border-radius: 3px; transition: width 0.3s ease; }
        .coverage-stats { display: flex; justify-content: space-between; font-size: 11px; margin-top: 8px; }
        .coverage-stat { color: var(--text-muted); }
        .coverage-stat span { color: var(--text-secondary); font-family: 'JetBrains Mono', monospace; }
        
        .texture-upload { margin-top: 8px; padding: 16px; border: 2px dashed var(--border-color); border-radius: 6px; text-align: center; cursor: pointer; transition: all 0.15s ease; }
        .texture-upload:hover { border-color: var(--accent-primary); background: var(--accent-glow); }
        .texture-upload input { display: none; }
        .texture-upload p { font-size: 11px; color: var(--text-muted); margin: 0; }
        .texture-preview { width: 100%; height: 80px; border-radius: 4px; background-size: contain; background-repeat: no-repeat; background-position: center; background-color: var(--bg-primary); margin-bottom: 8px; border: 1px solid var(--border-color); }
        .clear-texture-btn { margin-top: 8px; width: 100%; padding: 6px; font-size: 11px; }
        
        .luminance-legend { 
            margin-top: 12px; 
            padding: 12px; 
            background: var(--bg-primary); 
            border-radius: 6px; 
            border: 1px solid var(--border-color);
        }
        .legend-gradient { 
            height: 20px; 
            border-radius: 4px; 
            background: linear-gradient(90deg, 
                #000033 0%, 
                #0044aa 20%, 
                #00aa44 40%, 
                #aaaa00 60%, 
                #ff6600 80%, 
                #ff0000 95%,
                #ffffff 100%
            ); 
            margin-bottom: 6px;
        }
        .legend-labels { 
            display: flex; 
            justify-content: space-between; 
            font-size: 10px; 
            color: var(--text-secondary); 
            font-family: 'JetBrains Mono', monospace;
        }
        .legend-unit {
            text-align: center;
            font-size: 9px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 480px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.2s ease;
        }
        .modal-overlay.active .modal {
            transform: scale(1);
        }
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .modal-title {
            font-size: 16px;
            font-weight: 600;
        }
        .modal-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .modal-close svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 50vh;
        }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .export-option {
            display: flex;
            align-items: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }
        .export-option:hover {
            background: var(--bg-panel);
            border-color: var(--border-hover);
        }
        .export-option.selected {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
        }
        .export-option-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        .export-option-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--accent-primary);
        }
        .export-option-info h4 {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 2px;
        }
        .export-option-info p {
            font-size: 11px;
            color: var(--text-muted);
            margin: 0;
        }
        .export-checkbox {
            margin-left: auto;
        }
        .checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .checkbox.checked {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        .checkbox svg {
            width: 12px;
            height: 12px;
            fill: var(--bg-primary);
            opacity: 0;
        }
        .checkbox.checked svg {
            opacity: 1;
        }
        .import-preview {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .import-preview h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .import-stat {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        .import-stat:last-child {
            border-bottom: none;
        }
        .import-stat span:first-child {
            color: var(--text-muted);
        }
        .import-stat span:last-child {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        .import-warning {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 6px;
            margin-top: 12px;
        }
        .import-warning svg {
            width: 16px;
            height: 16px;
            fill: var(--warning);
            flex-shrink: 0;
            margin-top: 1px;
        }
        .import-warning p {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }
        .filename-input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            margin-bottom: 16px;
        }
        .filename-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-primary);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        .toast.success {
            border-color: var(--accent-primary);
        }
        .toast.error {
            border-color: var(--danger);
        }
        .toast svg {
            width: 18px;
            height: 18px;
        }
        .toast.success svg {
            fill: var(--accent-primary);
        }
        .toast.error svg {
            fill: var(--danger);
        }
        
        .password-modal .modal {
            width: 360px;
        }
        .password-input-wrapper {
            position: relative;
        }
        .password-input {
            width: 100%;
            padding: 12px 40px 12px 14px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        .password-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .password-input.error {
            border-color: var(--danger);
            animation: shake 0.4s ease;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px); }
            40%, 80% { transform: translateX(6px); }
        }
        .password-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }
        .password-toggle:hover {
            color: var(--text-secondary);
        }
        .password-toggle svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .password-error {
            color: var(--danger);
            font-size: 11px;
            margin-top: 8px;
            display: none;
        }
        .password-error.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                <span class="logo-text">Projection Studio <span>v2.3</span></span>
            </div>
            <div class="header-actions">
                <button class="btn" onclick="confirmNewProject()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>New</button>
                <button class="btn" onclick="document.getElementById('import-file').click()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>Import</button>
                <input type="file" id="import-file" accept=".json" style="display:none" onchange="importConfig(this.files[0])">
                <button class="btn" onclick="showExportModal()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>Export</button>
                <button class="btn btn-primary" onclick="quickSave()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>Save</button>
            </div>
        </header>
        
        <aside class="sidebar-left">
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Projectors</span><span class="panel-badge" id="projector-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="projector-list"><div class="empty-state"><p>No projectors added yet.</p></div></div></div>
            </div>
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Surfaces</span><span class="panel-badge" id="surface-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="surface-list"><div class="empty-state"><p>No surfaces added yet.</p></div></div></div>
            </div>
            <div class="add-buttons">
                <button class="add-btn" onclick="addProjector()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Projector</button>
                <button class="add-btn" onclick="addSurface()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Surface</button>
                <button class="add-btn" onclick="document.getElementById('obj-import').click()"><svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>OBJ</button>
                <input type="file" id="obj-import" accept=".obj" style="display:none" onchange="importOBJSurface(this.files[0])">
            </div>
        </aside>
        
        <main class="viewport">
            <div id="canvas-container"></div>
            <div class="viewport-overlay">
                <button class="view-btn active" onclick="setView('perspective')">Perspective</button>
                <button class="view-btn" onclick="setView('top')">Top</button>
                <button class="view-btn" onclick="setView('front')">Front</button>
                <button class="view-btn" onclick="setView('side')">Side</button>
                <button class="view-btn" onclick="setView('projector')">Projector POV</button>
            </div>
            
            <div class="transform-tools">
                <button class="tool-btn disabled" id="tool-select" onclick="setTransformMode('select')" title="Select (V)">
                    <svg viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-6.39 6.39-2.51L3 3zm10.57 10.57l-1.12 2.85-3.03-7.27 7.27 3.03-2.85 1.12l3.88 3.88-1.41 1.41-3.74-3.87z"/></svg>
                </button>
                <button class="tool-btn disabled" id="tool-translate" onclick="setTransformMode('translate')" title="Move (G)">
                    <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
                </button>
                <button class="tool-btn disabled" id="tool-rotate" onclick="setTransformMode('rotate')" title="Rotate (R)">
                    <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                </button>
                <div class="tool-divider"></div>
                <button class="tool-btn" id="tool-local" onclick="toggleCoordSpace()" title="Local/World Space">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                </button>
            </div>
            
            <div class="gizmo-info" id="gizmo-info">
                <div class="gizmo-info-title" id="gizmo-info-title">Position</div>
                <div class="gizmo-info-row">
                    <span class="gizmo-info-axis x">X: <span id="gizmo-x">0.00</span></span>
                    <span class="gizmo-info-axis y">Y: <span id="gizmo-y">0.00</span></span>
                    <span class="gizmo-info-axis z">Z: <span id="gizmo-z">0.00</span></span>
                </div>
            </div>
            
            <div class="snap-controls">
                <span class="snap-label">Snap:</span>
                <label class="snap-toggle">
                    <input type="checkbox" id="snap-enabled" onchange="updateSnapSettings()">
                    <div class="snap-checkbox"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg></div>
                </label>
                <input type="number" class="snap-value" id="snap-translate" value="0.5" step="0.1" min="0.1" title="Translation snap" onchange="updateSnapSettings()">
                <span class="snap-label">m</span>
                <input type="number" class="snap-value" id="snap-rotate" value="15" step="5" min="1" title="Rotation snap" onchange="updateSnapSettings()">
                <span class="snap-label">°</span>
            </div>
            <div class="viewport-info">
                <div class="viewport-info-row">
                    <div class="viewport-info-item"><span>Camera:</span><span id="camera-info">Perspective</span></div>
                    <div class="viewport-info-item"><span>Units:</span><span>Meters</span></div>
                </div>
            </div>
            <div class="controls-hint">
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;
                <kbd>Q</kbd><kbd>E</kbd> Up/Down &nbsp;
                <kbd>Drag</kbd> Look &nbsp;|&nbsp;
                <kbd>G</kbd> Translate &nbsp;
                <kbd>R</kbd> Rotate &nbsp;
                <kbd>Esc</kbd> Deselect &nbsp;
                <kbd>Del</kbd> Delete
            </div>
        </main>
        
        <aside class="sidebar-right">
            <div id="properties-panel">
                <div class="no-selection">
                    <div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div>
                    <h3>No Selection</h3>
                    <p>Select an object to edit.</p>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Test Patterns</span></div>
                <div class="panel-content">
                    <div class="pattern-grid">
                        <button class="pattern-btn active" onclick="setPattern('none')" title="None"><div class="pattern-preview pattern-none">OFF</div></button>
                        <button class="pattern-btn" onclick="setPattern('grid')" title="Grid"><div class="pattern-preview pattern-grid-lines"></div></button>
                        <button class="pattern-btn" onclick="setPattern('checker')" title="Checkerboard"><div class="pattern-preview pattern-checker"></div></button>
                        <button class="pattern-btn" onclick="setPattern('gradient')" title="Gradient"><div class="pattern-preview pattern-gradient"></div></button>
                        <button class="pattern-btn" onclick="setPattern('colorbars')" title="Color Bars"><div class="pattern-preview pattern-colorbars"></div></button>
                        <button class="pattern-btn" onclick="setPattern('cross')" title="Focus Cross"><div class="pattern-preview pattern-cross"></div></button>
                        <button class="pattern-btn" onclick="setPattern('white')" title="White"><div class="pattern-preview pattern-white"></div></button>
                        <button class="pattern-btn" onclick="setPattern('blend')" title="Blend Zones"><div class="pattern-preview pattern-blend"></div></button>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Display Options</span></div>
                <div class="panel-content">
                    <div class="toggle-row"><span class="toggle-label">Show Frustums</span><div class="toggle active" id="toggle-frustums" onclick="toggleOption('frustums')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Grid</span><div class="toggle active" id="toggle-grid" onclick="toggleOption('grid')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Coverage</span><div class="toggle active" id="toggle-coverage" onclick="toggleOption('coverage')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Overlap</span><div class="toggle" id="toggle-overlap" onclick="toggleOption('overlap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Distance</span><div class="toggle" id="toggle-distance" onclick="toggleOption('distance')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Luminance Heatmap</span><div class="toggle" id="toggle-heatmap" onclick="toggleOption('heatmap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Wireframe</span><div class="toggle" id="toggle-wireframe" onclick="toggleOption('wireframe')"></div></div>
                </div>
            </div>
            
            <div class="panel-section" id="heatmap-panel" style="display: none;">
                <div class="panel-header"><span class="panel-title">Luminance Heatmap</span></div>
                <div class="panel-content">
                    <div class="property-group">
                        <div class="property-group-title">Scale (cd/m²)</div>
                        <div class="slider-row">
                            <span class="slider-label">Max Value</span>
                            <div class="slider-container">
                                <input type="range" class="slider" min="100" max="10000" step="100" value="2000" id="heatmap-max-slider" oninput="updateHeatmapMax(+this.value); document.getElementById('heatmap-max-value').textContent=this.value">
                                <span class="slider-value" id="heatmap-max-value">2000</span>
                            </div>
                        </div>
                    </div>
                    <div class="luminance-legend">
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>0</span>
                            <span id="legend-mid">1000</span>
                            <span id="legend-max">2000+</span>
                        </div>
                        <div class="legend-unit">cd/m² (nits)</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Coverage Analysis</span></div>
                <div class="panel-content">
                    <div class="coverage-display">
                        <div class="property-group-title">Surface Coverage</div>
                        <div class="coverage-bar"><div class="coverage-fill" id="coverage-fill" style="width: 0%"></div></div>
                        <div class="coverage-stats">
                            <div class="coverage-stat">Covered: <span id="coverage-percent">0%</span></div>
                            <div class="coverage-stat">Avg: <span id="avg-cdm2">0</span> cd/m²</div>
                        </div>
                        <div class="coverage-stats" style="margin-top: 4px;">
                            <div class="coverage-stat">Min: <span id="min-cdm2">0</span> cd/m²</div>
                            <div class="coverage-stat">Max: <span id="max-cdm2">0</span> cd/m²</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
        
        <footer class="status-bar">
            <div class="status-left">
                <div class="status-item"><div class="status-dot"></div>Ready</div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg><span id="projector-status">0 Projectors</span></div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg><span id="surface-status">0 Surfaces</span></div>
            </div>
            <div class="status-right"><div class="status-item"><span id="fps-counter">60 FPS</span></div></div>
        </footer>
    </div>
    
    <!-- Export Modal -->
    <div class="modal-overlay" id="export-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Export Project</span>
                <button class="modal-close" onclick="closeModal('export-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 6px;">Filename</label>
                <input type="text" class="filename-input" id="export-filename" value="projection-config" placeholder="Enter filename">
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Include in export:</label>
                
                <div class="export-option" onclick="toggleExportOption('projectors')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Projectors</h4>
                        <p id="export-projector-count">0 projectors with settings</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-projectors">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('surfaces')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Surfaces</h4>
                        <p id="export-surface-count">0 surfaces with settings</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-surfaces">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('settings')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.49.49 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Display Settings</h4>
                        <p>Pattern, heatmap, view options</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="export-check-settings">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleExportOption('textures')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Custom Textures</h4>
                        <p id="export-texture-count">Embed texture images (increases file size)</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="export-check-textures">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('export-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doExport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Export
                </button>
            </div>
        </div>
    </div>
    
    <!-- Import Modal -->
    <div class="modal-overlay" id="import-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Import Project</span>
                <button class="modal-close" onclick="closeModal('import-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="import-preview">
                    <h4>File Contents</h4>
                    <div class="import-stat">
                        <span>Version</span>
                        <span id="import-version">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Projectors</span>
                        <span id="import-projectors">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Surfaces</span>
                        <span id="import-surfaces">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Custom Textures</span>
                        <span id="import-textures">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Settings</span>
                        <span id="import-settings">-</span>
                    </div>
                </div>
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Import options:</label>
                
                <div class="export-option" onclick="toggleImportOption('replace')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Replace Current Scene</h4>
                        <p>Clear existing objects before importing</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="import-check-replace">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleImportOption('merge')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Merge with Current</h4>
                        <p>Add imported objects to existing scene</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="import-check-merge">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="import-warning">
                    <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    <p>This will modify your current scene. Make sure to export your work first if you want to keep it.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('import-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doImport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
                    Import
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
        <span id="toast-message">Success!</span>
    </div>
    
    <!-- Password Modal -->
    <div class="modal-overlay password-modal" id="password-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Authentication Required</span>
                <button class="modal-close" onclick="closeModal('password-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 16px;">Enter the project password to export or save.</p>
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 6px;">Password</label>
                <div class="password-input-wrapper">
                    <input type="password" class="password-input" id="export-password" placeholder="Enter password" onkeydown="if(event.key==='Enter')verifyAndProceed()">
                    <button class="password-toggle" onclick="togglePasswordVisibility()" type="button">
                        <svg viewBox="0 0 24 24" id="password-eye"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                </div>
                <p class="password-error" id="password-error">Incorrect password. Please try again.</p>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('password-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="verifyAndProceed()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>
                    Verify
                </button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // OBJLoader for Three.js r128
    THREE.OBJLoader = function(manager) {
        this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        this.materials = null;
    };
    
    THREE.OBJLoader.prototype = {
        constructor: THREE.OBJLoader,
        
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
                onLoad(scope.parse(text));
            }, onProgress, onError);
        },
        
        setPath: function(value) {
            this.path = value;
            return this;
        },
        
        setMaterials: function(materials) {
            this.materials = materials;
            return this;
        },
        
        parse: function(text) {
            var state = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materialLibraries: [],
                startObject: function(name, fromDeclaration) {
                    if (this.object && this.object.fromDeclaration === false) {
                        this.object.name = name;
                        this.object.fromDeclaration = (fromDeclaration !== false);
                        return;
                    }
                    var previousMaterial = (this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined);
                    if (this.object && typeof this.object._finalize === 'function') {
                        this.object._finalize(true);
                    }
                    this.object = {
                        name: name || '',
                        fromDeclaration: (fromDeclaration !== false),
                        geometry: { vertices: [], normals: [], colors: [], uvs: [] },
                        materials: [],
                        smooth: true,
                        startMaterial: function(name, libraries) {
                            var previous = this._finalize(false);
                            if (previous && (previous.inherited || previous.groupCount <= 0)) {
                                this.materials.splice(previous.index, 1);
                            }
                            var material = { index: this.materials.length, name: name || '', mtllib: (Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : ''), smooth: (previous !== undefined ? previous.smooth : this.smooth), groupStart: (previous !== undefined ? previous.groupEnd : 0), groupEnd: -1, groupCount: -1, inherited: false };
                            this.materials.push(material);
                            return material;
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0) return this.materials[this.materials.length - 1];
                            return undefined;
                        },
                        _finalize: function(end) {
                            var lastMultiMaterial = this.currentMaterial();
                            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                                lastMultiMaterial.inherited = false;
                            }
                            if (end && this.materials.length > 1) {
                                for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                                    if (this.materials[mi].groupCount <= 0) {
                                        this.materials.splice(mi, 1);
                                    }
                                }
                            }
                            if (end && this.materials.length === 0) {
                                this.materials.push({ name: '', smooth: this.smooth });
                            }
                            return lastMultiMaterial;
                        }
                    };
                    if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
                        var declared = previousMaterial.clone(0);
                        declared.inherited = true;
                        this.object.materials.push(declared);
                    }
                    this.objects.push(this.object);
                },
                finalize: function() {
                    if (this.object && typeof this.object._finalize === 'function') {
                        this.object._finalize(true);
                    }
                },
                parseVertexIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseNormalIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseUVIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 2) * 2;
                },
                addVertex: function(a, b, c) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                    dst.push(src[b + 0], src[b + 1], src[b + 2]);
                    dst.push(src[c + 0], src[c + 1], src[c + 2]);
                },
                addVertexPoint: function(a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                },
                addVertexLine: function(a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                },
                addNormal: function(a, b, c) {
                    var src = this.normals;
                    var dst = this.object.geometry.normals;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                    dst.push(src[b + 0], src[b + 1], src[b + 2]);
                    dst.push(src[c + 0], src[c + 1], src[c + 2]);
                },
                addUV: function(a, b, c) {
                    var src = this.uvs;
                    var dst = this.object.geometry.uvs;
                    dst.push(src[a + 0], src[a + 1]);
                    dst.push(src[b + 0], src[b + 1]);
                    dst.push(src[c + 0], src[c + 1]);
                },
                addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
                    var vLen = this.vertices.length;
                    var ia = this.parseVertexIndex(a, vLen);
                    var ib = this.parseVertexIndex(b, vLen);
                    var ic = this.parseVertexIndex(c, vLen);
                    this.addVertex(ia, ib, ic);
                    if (na !== undefined && na !== '') {
                        var nLen = this.normals.length;
                        ia = this.parseNormalIndex(na, nLen);
                        ib = this.parseNormalIndex(nb, nLen);
                        ic = this.parseNormalIndex(nc, nLen);
                        this.addNormal(ia, ib, ic);
                    }
                    if (ua !== undefined && ua !== '') {
                        var uvLen = this.uvs.length;
                        ia = this.parseUVIndex(ua, uvLen);
                        ib = this.parseUVIndex(ub, uvLen);
                        ic = this.parseUVIndex(uc, uvLen);
                        this.addUV(ia, ib, ic);
                    }
                }
            };
            
            state.startObject('', false);
            var lines = text.split('\n');
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line.length === 0 || line.charAt(0) === '#') continue;
                var lineFirstChar = line.charAt(0);
                var data = line.split(/\s+/);
                var keyword = data[0];
                
                if (lineFirstChar === 'v') {
                    if (keyword === 'v') {
                        state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                    } else if (keyword === 'vn') {
                        state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                    } else if (keyword === 'vt') {
                        state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                    }
                } else if (lineFirstChar === 'f') {
                    var vertices = [];
                    for (var j = 1; j < data.length; j++) {
                        var vertex = data[j].split('/');
                        vertices.push(vertex);
                    }
                    for (var j = 1; j < vertices.length - 1; j++) {
                        var v1 = vertices[0], v2 = vertices[j], v3 = vertices[j + 1];
                        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                } else if (keyword === 'o' || keyword === 'g') {
                    state.startObject(data[1]);
                } else if (keyword === 'usemtl') {
                    state.object.startMaterial(data[1], state.materialLibraries);
                } else if (keyword === 's') {
                    if (data[1] === 'off' || data[1] === '0') {
                        state.object.smooth = false;
                    } else {
                        state.object.smooth = true;
                    }
                    var material = state.object.currentMaterial();
                    if (material) material.smooth = state.object.smooth;
                }
            }
            
            state.finalize();
            
            var container = new THREE.Group();
            for (var i = 0; i < state.objects.length; i++) {
                var object = state.objects[i];
                var geometry = object.geometry;
                if (geometry.vertices.length === 0) continue;
                
                var buffergeometry = new THREE.BufferGeometry();
                buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));
                if (geometry.normals.length > 0) {
                    buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
                } else {
                    buffergeometry.computeVertexNormals();
                }
                if (geometry.uvs.length > 0) {
                    buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
                }
                
                var material = new THREE.MeshBasicMaterial({ color: 0x888888 });
                var mesh = new THREE.Mesh(buffergeometry, material);
                mesh.name = object.name;
                container.add(mesh);
            }
            
            return container;
        }
    };
    </script>
    <script>
        // ==========================================
        // PROJECTION STUDIO v2.3
        // Fixed coverage, frustum zoom, presets, luminance heatmap
        // ==========================================
        
        const state = {
            projectors: [],
            surfaces: [],
            selectedObject: null,
            selectedType: null,
            currentPattern: 'none',
            displayOptions: { frustums: true, grid: true, coverage: true, overlap: false, distance: false, heatmap: false, wireframe: false },
            currentView: 'perspective',
            heatmapMax: 2000 // cd/m² maximum for heatmap scale
        };
        
        // ==========================================
        // SECURITY MODULE - DO NOT MODIFY
        // ==========================================
        
        // Session validation and integrity check routines
        let _0x7f3a = null; // pending action callback
        const _0x4e2d = [0x42,0x75,0x79,0x4a,0x6f,0x65,0x4c,0x6f,0x65,0x43,0x6f,0x66,0x66,0x65,0x65];
        const _0x9c1b = { v: null, t: Date.now() };
        
        // Integrity verification matrix
        const _0x3f8e = [
            [0x1a, 0x2b, 0x3c], [0x4d, 0x5e, 0x6f], // decoy
            [0x28, 0x33, 0x0d, 0x17], // offset markers
        ];
        
        // Session token generator (obfuscated validation)
        function _0x2a4f(input) {
            const _0x8b7c = _0x4e2d.map((c, i) => c ^ (_0x3f8e[2][i % 4]));
            const _0x6d9e = String.fromCharCode(..._0x4e2d);
            
            // Additional entropy mixing
            const _0x1f5a = input.split('').reduce((a, c, i) => {
                return a + (c.charCodeAt(0) * (i + 1));
            }, 0);
            
            const _0x7e3b = _0x6d9e.split('').reduce((a, c, i) => {
                return a + (c.charCodeAt(0) * (i + 1));
            }, 0);
            
            return _0x1f5a === _0x7e3b && input.length === _0x4e2d.length;
        }
        
        // Async hash verification with timing attack mitigation
        async function _0xa3c7(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            const hash = await crypto.subtle.digest('SHA-256', data);
            const arr = Array.from(new Uint8Array(hash));
            return arr.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        // Multi-layer verification
        async function _0x5b2e(input) {
            // Layer 1: Length and character validation
            if (!input || typeof input !== 'string') return false;
            
            // Layer 2: Quick rejection for obvious mismatches
            const quickCheck = _0x2a4f(input);
            if (!quickCheck) return false;
            
            // Layer 3: Cryptographic verification
            const inputHash = await _0xa3c7(input);
            const _0xd4f1 = await _0xa3c7(String.fromCharCode(..._0x4e2d));
            
            // Constant-time comparison to prevent timing attacks
            let match = inputHash.length === _0xd4f1.length;
            for (let i = 0; i < inputHash.length; i++) {
                match = match && (inputHash[i] === _0xd4f1[i]);
            }
            
            return match;
        }
        
        function requestAuthentication(callback) {
            _0x7f3a = callback;
            document.getElementById('export-password').value = '';
            document.getElementById('password-error').classList.remove('visible');
            document.getElementById('export-password').classList.remove('error');
            document.getElementById('password-modal').classList.add('active');
            setTimeout(() => document.getElementById('export-password').focus(), 100);
        }
        
        async function verifyAndProceed() {
            const input = document.getElementById('export-password').value;
            const isValid = await _0x5b2e(input);
            
            if (isValid) {
                _0x9c1b.v = true;
                _0x9c1b.t = Date.now();
                closeModal('password-modal');
                if (_0x7f3a) {
                    _0x7f3a();
                    _0x7f3a = null;
                }
            } else {
                document.getElementById('export-password').classList.add('error');
                document.getElementById('password-error').classList.add('visible');
                setTimeout(() => {
                    document.getElementById('export-password').classList.remove('error');
                }, 400);
            }
        }
        
        function togglePasswordVisibility() {
            const input = document.getElementById('export-password');
            const eye = document.getElementById('password-eye');
            if (input.type === 'password') {
                input.type = 'text';
                eye.innerHTML = '<path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>';
            } else {
                input.type = 'password';
                eye.innerHTML = '<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>';
            }
        }
        
        // Check if session is still valid (5 minute window)
        function isSessionValid() {
            return _0x9c1b.v === true && (Date.now() - _0x9c1b.t) < 300000;
        }
        
        // ==========================================
        // END SECURITY MODULE
        // ==========================================
        
        let scene, camera, renderer, gridHelper, projectorGroup, surfaceGroup, distanceHelperGroup, raycaster, mouse;
        const projectionTextures = new Map();
        const projectorMatrixData = new Map();
        const customTextureData = new Map();
        
        // Shadow map system for occlusion
        const shadowMaps = new Map(); // projector ID -> { renderTarget, camera }
        const SHADOW_MAP_SIZE = 1024;
        let depthMaterial = null;
        
        // Keyboard state for WASD controls
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false };
        
        // ==========================================
        // TRANSFORM GIZMO SYSTEM
        // ==========================================
        
        const gizmoState = {
            mode: 'select', // 'select', 'translate', 'rotate'
            activeAxis: null, // 'x', 'y', 'z', 'xy', 'xz', 'yz'
            isDragging: false,
            startPoint: new THREE.Vector3(),
            startValue: null,
            localSpace: false,
            snap: {
                enabled: false,
                translate: 0.5,
                rotate: 15
            }
        };
        
        let gizmoGroup = null;
        let translateGizmo = null;
        let rotateGizmo = null;
        const gizmoRaycaster = new THREE.Raycaster();
        gizmoRaycaster.params.Line.threshold = 0.15;
        
        function createGizmos() {
            gizmoGroup = new THREE.Group();
            gizmoGroup.visible = false;
            gizmoGroup.renderOrder = 999;
            scene.add(gizmoGroup);
            
            createTranslateGizmo();
            createRotateGizmo();
        }
        
        function createTranslateGizmo() {
            translateGizmo = new THREE.Group();
            translateGizmo.name = 'translateGizmo';
            
            const axisLength = 1.5;
            const coneHeight = 0.25;
            const coneRadius = 0.08;
            const lineWidth = 3;
            
            const colors = {
                x: 0xff4444,
                y: 0x44ff44,
                z: 0x4488ff
            };
            
            // Create axes
            ['x', 'y', 'z'].forEach(axis => {
                const group = new THREE.Group();
                group.userData.axis = axis;
                group.userData.gizmoType = 'translate';
                
                // Line
                const lineGeom = new THREE.BufferGeometry();
                const start = new THREE.Vector3();
                const end = new THREE.Vector3();
                if (axis === 'x') end.x = axisLength;
                if (axis === 'y') end.y = axisLength;
                if (axis === 'z') end.z = axisLength;
                lineGeom.setFromPoints([start, end]);
                
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: colors[axis], 
                    linewidth: lineWidth,
                    depthTest: false,
                    transparent: true
                });
                const line = new THREE.Line(lineGeom, lineMat);
                line.userData.axis = axis;
                line.userData.gizmoType = 'translate';
                group.add(line);
                
                // Cone (arrow head)
                const coneGeom = new THREE.ConeGeometry(coneRadius, coneHeight, 12);
                const coneMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true
                });
                const cone = new THREE.Mesh(coneGeom, coneMat);
                cone.userData.axis = axis;
                cone.userData.gizmoType = 'translate';
                
                // Position and rotate cone
                if (axis === 'x') {
                    cone.position.x = axisLength;
                    cone.rotation.z = -Math.PI / 2;
                } else if (axis === 'y') {
                    cone.position.y = axisLength;
                } else if (axis === 'z') {
                    cone.position.z = axisLength;
                    cone.rotation.x = Math.PI / 2;
                }
                group.add(cone);
                
                // Invisible cylinder for easier picking
                const pickGeom = new THREE.CylinderGeometry(0.1, 0.1, axisLength, 8);
                const pickMat = new THREE.MeshBasicMaterial({ visible: false });
                const picker = new THREE.Mesh(pickGeom, pickMat);
                picker.userData.axis = axis;
                picker.userData.gizmoType = 'translate';
                picker.userData.isPicker = true;
                
                if (axis === 'x') {
                    picker.rotation.z = -Math.PI / 2;
                    picker.position.x = axisLength / 2;
                } else if (axis === 'y') {
                    picker.position.y = axisLength / 2;
                } else if (axis === 'z') {
                    picker.rotation.x = Math.PI / 2;
                    picker.position.z = axisLength / 2;
                }
                group.add(picker);
                
                translateGizmo.add(group);
            });
            
            // Plane handles for 2-axis movement
            const planeSize = 0.35;
            const planeOffset = 0.5;
            const planeColors = {
                xy: 0x4488ff,
                xz: 0x44ff44,
                yz: 0xff4444
            };
            
            [['xy', 'z'], ['xz', 'y'], ['yz', 'x']].forEach(([plane, normal]) => {
                const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
                const planeMat = new THREE.MeshBasicMaterial({ 
                    color: planeColors[plane],
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    depthTest: false
                });
                const planeMesh = new THREE.Mesh(planeGeom, planeMat);
                planeMesh.userData.axis = plane;
                planeMesh.userData.gizmoType = 'translate';
                
                if (plane === 'xy') {
                    planeMesh.position.set(planeOffset, planeOffset, 0);
                } else if (plane === 'xz') {
                    planeMesh.position.set(planeOffset, 0, planeOffset);
                    planeMesh.rotation.x = Math.PI / 2;
                } else if (plane === 'yz') {
                    planeMesh.position.set(0, planeOffset, planeOffset);
                    planeMesh.rotation.y = Math.PI / 2;
                }
                
                translateGizmo.add(planeMesh);
            });
            
            gizmoGroup.add(translateGizmo);
        }
        
        function createRotateGizmo() {
            rotateGizmo = new THREE.Group();
            rotateGizmo.name = 'rotateGizmo';
            rotateGizmo.visible = false;
            
            const ringRadius = 1.2;
            const tubeRadius = 0.02;
            const segments = 64;
            
            const colors = {
                x: 0xff4444,
                y: 0x44ff44,
                z: 0x4488ff
            };
            
            ['x', 'y', 'z'].forEach(axis => {
                // Torus ring
                const torusGeom = new THREE.TorusGeometry(ringRadius, tubeRadius, 8, segments);
                const torusMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true
                });
                const torus = new THREE.Mesh(torusGeom, torusMat);
                torus.userData.axis = axis;
                torus.userData.gizmoType = 'rotate';
                
                // Invisible torus for easier picking
                const pickGeom = new THREE.TorusGeometry(ringRadius, 0.12, 8, segments);
                const pickMat = new THREE.MeshBasicMaterial({ visible: false });
                const picker = new THREE.Mesh(pickGeom, pickMat);
                picker.userData.axis = axis;
                picker.userData.gizmoType = 'rotate';
                picker.userData.isPicker = true;
                
                if (axis === 'x') {
                    torus.rotation.y = Math.PI / 2;
                    picker.rotation.y = Math.PI / 2;
                } else if (axis === 'y') {
                    torus.rotation.x = Math.PI / 2;
                    picker.rotation.x = Math.PI / 2;
                }
                // z axis is default orientation
                
                rotateGizmo.add(torus);
                rotateGizmo.add(picker);
            });
            
            gizmoGroup.add(rotateGizmo);
        }
        
        function updateGizmoPosition() {
            if (!gizmoGroup || !state.selectedObject) {
                if (gizmoGroup) gizmoGroup.visible = false;
                return;
            }
            
            let targetObject = null;
            let objectData = null;
            
            if (state.selectedType === 'projector') {
                targetObject = projectorGroup.children.find(c => c.userData.projectorId === state.selectedObject);
                objectData = state.projectors.find(p => p.id === state.selectedObject);
            } else if (state.selectedType === 'surface') {
                targetObject = surfaceGroup.children.find(c => c.userData.surfaceId === state.selectedObject);
                objectData = state.surfaces.find(s => s.id === state.selectedObject);
            }
            
            if (!targetObject || !objectData) {
                gizmoGroup.visible = false;
                return;
            }
            
            gizmoGroup.visible = gizmoState.mode !== 'select';
            gizmoGroup.position.copy(targetObject.position);
            
            // Apply rotation in local space mode
            if (gizmoState.localSpace) {
                gizmoGroup.rotation.copy(targetObject.rotation);
            } else {
                gizmoGroup.rotation.set(0, 0, 0);
            }
            
            // Scale gizmo based on camera distance
            const dist = camera.position.distanceTo(gizmoGroup.position);
            const scale = dist * 0.15;
            gizmoGroup.scale.setScalar(Math.max(0.5, Math.min(scale, 2)));
            
            // Show appropriate gizmo
            translateGizmo.visible = gizmoState.mode === 'translate';
            rotateGizmo.visible = gizmoState.mode === 'rotate';
        }
        
        function setTransformMode(mode) {
            gizmoState.mode = mode;
            
            // Update tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
                if (!state.selectedObject) {
                    btn.classList.add('disabled');
                }
            });
            
            const activeBtn = document.getElementById(`tool-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            updateGizmoPosition();
        }
        
        function toggleCoordSpace() {
            gizmoState.localSpace = !gizmoState.localSpace;
            document.getElementById('tool-local').classList.toggle('active', gizmoState.localSpace);
            updateGizmoPosition();
        }
        
        function updateSnapSettings() {
            gizmoState.snap.enabled = document.getElementById('snap-enabled').checked;
            gizmoState.snap.translate = parseFloat(document.getElementById('snap-translate').value) || 0.5;
            gizmoState.snap.rotate = parseFloat(document.getElementById('snap-rotate').value) || 15;
        }
        
        function enableTransformTools(enabled) {
            const tools = ['tool-select', 'tool-translate', 'tool-rotate'];
            tools.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.toggle('disabled', !enabled);
                }
            });
        }
        
        function handleGizmoInteraction(event, phase) {
            if (!gizmoGroup || !gizmoGroup.visible || gizmoState.mode === 'select') return false;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            gizmoRaycaster.setFromCamera(mouse, camera);
            
            if (phase === 'down') {
                const gizmoObjects = [];
                gizmoGroup.traverse(child => {
                    if (child.isMesh && (child.userData.gizmoType === gizmoState.mode || child.userData.isPicker)) {
                        gizmoObjects.push(child);
                    }
                });
                
                const intersects = gizmoRaycaster.intersectObjects(gizmoObjects);
                
                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    gizmoState.activeAxis = hit.userData.axis;
                    gizmoState.isDragging = true;
                    gizmoState.startPoint.copy(intersects[0].point);
                    
                    // Store starting value
                    if (state.selectedType === 'projector') {
                        const p = state.projectors.find(x => x.id === state.selectedObject);
                        gizmoState.startValue = gizmoState.mode === 'translate' 
                            ? { ...p.position } 
                            : { ...p.rotation };
                    } else if (state.selectedType === 'surface') {
                        const s = state.surfaces.find(x => x.id === state.selectedObject);
                        gizmoState.startValue = gizmoState.mode === 'translate' 
                            ? { ...s.position } 
                            : { ...s.rotation };
                    }
                    
                    // Highlight active axis
                    highlightAxis(gizmoState.activeAxis, true);
                    showGizmoInfo(true);
                    
                    return true;
                }
            } else if (phase === 'move' && gizmoState.isDragging) {
                updateGizmoDrag(event);
                return true;
            } else if (phase === 'up') {
                if (gizmoState.isDragging) {
                    gizmoState.isDragging = false;
                    highlightAxis(gizmoState.activeAxis, false);
                    gizmoState.activeAxis = null;
                    showGizmoInfo(false);
                    calculateCoverage();
                    return true;
                }
            }
            
            return false;
        }
        
        function updateGizmoDrag(event) {
            if (!gizmoState.isDragging || !gizmoState.activeAxis) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            // Get object being transformed
            let obj, data;
            if (state.selectedType === 'projector') {
                obj = projectorGroup.children.find(c => c.userData.projectorId === state.selectedObject);
                data = state.projectors.find(p => p.id === state.selectedObject);
            } else {
                obj = surfaceGroup.children.find(c => c.userData.surfaceId === state.selectedObject);
                data = state.surfaces.find(s => s.id === state.selectedObject);
            }
            
            if (!obj || !data) return;
            
            if (gizmoState.mode === 'translate') {
                updateTranslation(mouse, obj, data);
            } else if (gizmoState.mode === 'rotate') {
                updateRotation(event, mouse, obj, data);
            }
            
            // Update gizmo position
            updateGizmoPosition();
            
            // Update info display
            updateGizmoInfo(data);
            
            // Update properties panel in real-time
            updatePropertiesPanel();
        }
        
        function updateTranslation(mouse, obj, data) {
            const axis = gizmoState.activeAxis;
            
            // Create a plane for intersection based on camera view and axis
            const planeNormal = new THREE.Vector3();
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            if (axis === 'x') {
                planeNormal.set(0, Math.abs(cameraDir.y) > Math.abs(cameraDir.z) ? 0 : 1, Math.abs(cameraDir.y) > Math.abs(cameraDir.z) ? 1 : 0);
            } else if (axis === 'y') {
                planeNormal.set(Math.abs(cameraDir.x) > Math.abs(cameraDir.z) ? 0 : 1, 0, Math.abs(cameraDir.x) > Math.abs(cameraDir.z) ? 1 : 0);
            } else if (axis === 'z') {
                planeNormal.set(Math.abs(cameraDir.x) > Math.abs(cameraDir.y) ? 0 : 1, Math.abs(cameraDir.x) > Math.abs(cameraDir.y) ? 1 : 0, 0);
            } else if (axis === 'xy') {
                planeNormal.set(0, 0, 1);
            } else if (axis === 'xz') {
                planeNormal.set(0, 1, 0);
            } else if (axis === 'yz') {
                planeNormal.set(1, 0, 0);
            }
            
            const plane = new THREE.Plane();
            plane.setFromNormalAndCoplanarPoint(planeNormal, gizmoGroup.position);
            
            const ray = new THREE.Ray();
            gizmoRaycaster.setFromCamera(mouse, camera);
            ray.copy(gizmoRaycaster.ray);
            
            const intersection = new THREE.Vector3();
            ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                let delta = intersection.clone().sub(gizmoState.startPoint);
                
                // Constrain to axis
                if (axis === 'x') {
                    delta.y = 0; delta.z = 0;
                } else if (axis === 'y') {
                    delta.x = 0; delta.z = 0;
                } else if (axis === 'z') {
                    delta.x = 0; delta.y = 0;
                } else if (axis === 'xy') {
                    delta.z = 0;
                } else if (axis === 'xz') {
                    delta.y = 0;
                } else if (axis === 'yz') {
                    delta.x = 0;
                }
                
                // Apply to position
                let newX = gizmoState.startValue.x + delta.x;
                let newY = gizmoState.startValue.y + delta.y;
                let newZ = gizmoState.startValue.z + delta.z;
                
                // Snap
                if (gizmoState.snap.enabled) {
                    const snap = gizmoState.snap.translate;
                    newX = Math.round(newX / snap) * snap;
                    newY = Math.round(newY / snap) * snap;
                    newZ = Math.round(newZ / snap) * snap;
                }
                
                data.position.x = newX;
                data.position.y = newY;
                data.position.z = newZ;
                
                obj.position.set(newX, newY, newZ);
                
                // Update shadow maps when any object moves
                if (state.selectedType === 'projector') {
                    updateProjectorMatrix(data);
                }
                updateAllSurfaceMaterials();
            }
        }
        
        function updateRotation(event, mouse, obj, data) {
            const axis = gizmoState.activeAxis;
            
            // Calculate rotation based on mouse movement around the gizmo center
            const gizmoScreenPos = gizmoGroup.position.clone().project(camera);
            const centerX = (gizmoScreenPos.x + 1) / 2 * renderer.domElement.clientWidth;
            const centerY = (-gizmoScreenPos.y + 1) / 2 * renderer.domElement.clientHeight;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const currentAngle = Math.atan2(
                event.clientY - rect.top - centerY,
                event.clientX - rect.left - centerX
            );
            
            // Store initial angle on first move
            if (!gizmoState.startAngle) {
                gizmoState.startAngle = currentAngle;
            }
            
            let deltaAngle = (currentAngle - gizmoState.startAngle) * (180 / Math.PI);
            
            // Invert based on camera orientation for intuitive rotation
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            if (axis === 'x' && camDir.x < 0) deltaAngle = -deltaAngle;
            if (axis === 'y' && camDir.y > 0) deltaAngle = -deltaAngle;
            if (axis === 'z' && camDir.z < 0) deltaAngle = -deltaAngle;
            
            // Snap
            if (gizmoState.snap.enabled) {
                const snap = gizmoState.snap.rotate;
                deltaAngle = Math.round(deltaAngle / snap) * snap;
            }
            
            // Apply rotation
            if (axis === 'x') {
                data.rotation.x = gizmoState.startValue.x + deltaAngle;
            } else if (axis === 'y') {
                data.rotation.y = gizmoState.startValue.y + deltaAngle;
            } else if (axis === 'z') {
                data.rotation.z = gizmoState.startValue.z + deltaAngle;
            }
            
            obj.rotation.set(
                THREE.MathUtils.degToRad(data.rotation.x),
                THREE.MathUtils.degToRad(data.rotation.y),
                THREE.MathUtils.degToRad(data.rotation.z)
            );
            
            // Update shadow maps when any object rotates
            if (state.selectedType === 'projector') {
                updateProjectorMatrix(data);
            }
            updateAllSurfaceMaterials();
        }
        
        function highlightAxis(axis, highlight) {
            const gizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
            const highlightColor = 0xffff00;
            
            gizmo.traverse(child => {
                if (child.material && child.userData.axis === axis && !child.userData.isPicker) {
                    if (highlight) {
                        child.userData.originalColor = child.material.color.getHex();
                        child.material.color.setHex(highlightColor);
                        if (child.material.opacity !== undefined) {
                            child.userData.originalOpacity = child.material.opacity;
                            child.material.opacity = Math.min(1, child.material.opacity + 0.4);
                        }
                    } else if (child.userData.originalColor !== undefined) {
                        child.material.color.setHex(child.userData.originalColor);
                        if (child.userData.originalOpacity !== undefined) {
                            child.material.opacity = child.userData.originalOpacity;
                        }
                    }
                }
            });
        }
        
        function showGizmoInfo(visible) {
            const info = document.getElementById('gizmo-info');
            info.classList.toggle('visible', visible);
            
            if (visible) {
                document.getElementById('gizmo-info-title').textContent = 
                    gizmoState.mode === 'translate' ? 'Position' : 'Rotation';
            }
        }
        
        function updateGizmoInfo(data) {
            if (gizmoState.mode === 'translate') {
                document.getElementById('gizmo-x').textContent = data.position.x.toFixed(2);
                document.getElementById('gizmo-y').textContent = data.position.y.toFixed(2);
                document.getElementById('gizmo-z').textContent = data.position.z.toFixed(2);
            } else {
                document.getElementById('gizmo-x').textContent = data.rotation.x.toFixed(1) + '°';
                document.getElementById('gizmo-y').textContent = data.rotation.y.toFixed(1) + '°';
                document.getElementById('gizmo-z').textContent = data.rotation.z.toFixed(1) + '°';
            }
        }
        
        // ==========================================
        // END TRANSFORM GIZMO SYSTEM
        // ==========================================
        
        // Projector presets with real-world specifications
        const projectorPresets = {
            'custom': { name: 'Custom', lumens: 10000, throwRatio: 1.5, aspectRatio: 16/9, resolution: '1920×1080' },
            'barco-udx-4k40': { name: 'Barco UDX-4K40', lumens: 40000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840×2160' },
            'barco-udx-4k26': { name: 'Barco UDX-4K26', lumens: 26000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840×2160' },
            'christie-griffyn-4k35': { name: 'Christie Griffyn 4K35', lumens: 36500, throwRatio: 1.38, aspectRatio: 16/9, resolution: '4096×2160' },
            'christie-d4k40': { name: 'Christie D4K40-RGB', lumens: 45000, throwRatio: 1.8, aspectRatio: 1.9, resolution: '4096×2160' },
            'panasonic-pt-rq35k': { name: 'Panasonic PT-RQ35K', lumens: 30500, throwRatio: 1.7, aspectRatio: 16/9, resolution: '5120×3200' },
            'panasonic-pt-rz120': { name: 'Panasonic PT-RZ120', lumens: 12000, throwRatio: 1.7, aspectRatio: 16/10, resolution: '1920×1200' },
            'epson-pro-l30000': { name: 'Epson Pro L30000U', lumens: 30000, throwRatio: 1.57, aspectRatio: 16/10, resolution: '1920×1200' },
            'sony-vpl-gtz380': { name: 'Sony VPL-GTZ380', lumens: 10000, throwRatio: 1.4, aspectRatio: 17/9, resolution: '4096×2160' },
            'digital-projection-titan': { name: 'DP TITAN Laser 37000', lumens: 37000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840×2160' }
        };
        
        // ==========================================
        // SHADERS - With luminance calculation
        // ==========================================
        
        const projectionVertexShader = `
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            void main() {
                vWorldPosition = modelMatrix * vec4(position, 1.0);
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // Fragment shader with shadow mapping for occlusion
        const projectionFragmentShader = `
            uniform sampler2D projTex0;
            uniform sampler2D projTex1;
            uniform sampler2D projTex2;
            uniform sampler2D projTex3;
            uniform sampler2D shadowMap0;
            uniform sampler2D shadowMap1;
            uniform sampler2D shadowMap2;
            uniform sampler2D shadowMap3;
            uniform mat4 projMat0;
            uniform mat4 projMat1;
            uniform mat4 projMat2;
            uniform mat4 projMat3;
            uniform vec3 projPos0;
            uniform vec3 projPos1;
            uniform vec3 projPos2;
            uniform vec3 projPos3;
            uniform float projLumens0;
            uniform float projLumens1;
            uniform float projLumens2;
            uniform float projLumens3;
            uniform float projThrow0;
            uniform float projThrow1;
            uniform float projThrow2;
            uniform float projThrow3;
            uniform float projNear0;
            uniform float projNear1;
            uniform float projNear2;
            uniform float projNear3;
            uniform float projFar0;
            uniform float projFar1;
            uniform float projFar2;
            uniform float projFar3;
            uniform int numProjectors;
            uniform bool showCoverage;
            uniform bool showOverlap;
            uniform bool showHeatmap;
            uniform float surfaceGain;
            uniform vec3 baseColor;
            uniform float heatmapMax;
            
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            // Unpack linear depth from RGBA
            float unpackLinearDepth(vec4 rgbaDepth) {
                const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
                return dot(rgbaDepth, bitShift);
            }
            
            // Linear heatmap color function with white for overflow
            vec3 heatmapColor(float t) {
                if (t > 1.0) {
                    float overflow = min((t - 1.0) * 2.0, 1.0);
                    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), overflow);
                }
                
                t = clamp(t, 0.0, 1.0);
                
                if (t < 0.167) {
                    return mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.27, 0.67), t / 0.167);
                } else if (t < 0.333) {
                    return mix(vec3(0.0, 0.27, 0.67), vec3(0.0, 0.67, 0.27), (t - 0.167) / 0.167);
                } else if (t < 0.5) {
                    return mix(vec3(0.0, 0.67, 0.27), vec3(0.67, 0.67, 0.0), (t - 0.333) / 0.167);
                } else if (t < 0.667) {
                    return mix(vec3(0.67, 0.67, 0.0), vec3(1.0, 0.67, 0.0), (t - 0.5) / 0.167);
                } else if (t < 0.833) {
                    return mix(vec3(1.0, 0.67, 0.0), vec3(1.0, 0.4, 0.0), (t - 0.667) / 0.167);
                } else {
                    return mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.833) / 0.167);
                }
            }
            
            // Sample projector with physically accurate occlusion
            // - Back-face rejection: surfaces facing away from projector receive no light
            // - Shadow occlusion: surfaces behind other geometry receive no light
            vec4 sampleProjector(mat4 projMat, sampler2D projTex, sampler2D shadowMap, vec3 projPos, float lumens, float throwRatio, float nearPlane, float farPlane) {
                vec4 projCoord = projMat * vWorldPosition;
                
                // Behind the projector - no light
                if (projCoord.w <= 0.0) return vec4(0.0);
                
                vec3 ndc = projCoord.xyz / projCoord.w;
                vec2 uv = ndc.xy * 0.5 + 0.5;
                
                // Outside projector frustum - no light
                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec4(0.0);
                if (ndc.z < -1.0 || ndc.z > 1.0) return vec4(0.0);
                
                // Back-face rejection - surface facing away from projector receives no light
                vec3 toProj = normalize(projPos - vWorldPosition.xyz);
                float facing = dot(vWorldNormal, toProj);
                if (facing <= 0.0) return vec4(0.0);
                
                // Shadow occlusion using LINEAR depth for precision at distance
                // Calculate actual distance from projector to this fragment
                float fragDist = length(projPos - vWorldPosition.xyz);
                
                // Normalize to [0,1] using same formula as shadow map
                float fragDepthNormalized = (fragDist - nearPlane) / (farPlane - nearPlane);
                
                // Sample shadow map (contains linear depth)
                vec4 shadowSample = texture2D(shadowMap, uv);
                float shadowDepth = unpackLinearDepth(shadowSample);
                
                // Bias based on surface angle and distance to prevent shadow acne
                float distanceBias = 0.001 + (fragDist * 0.0005); // Scale bias with distance
                float angleBias = 0.002 * (1.0 - facing);
                float bias = distanceBias + angleBias;
                
                // If something is closer to the projector, this point is occluded
                if (fragDepthNormalized > shadowDepth + bias) {
                    return vec4(0.0);
                }
                
                // Calculate illumination using actual distance
                float dist = length(projPos - vWorldPosition.xyz);
                float projWidth = dist / throwRatio;
                float projHeight = projWidth / (16.0/9.0);
                float projArea = projWidth * projHeight;
                
                // Illuminance (lux) and Luminance (cd/m²)
                float lux = lumens / projArea;
                float cdm2 = (lux * surfaceGain / 3.14159) * facing;
                
                // Edge falloff for soft blending at frustum edges
                float edgeDist = max(abs(uv.x - 0.5), abs(uv.y - 0.5)) * 2.0;
                float edgeFalloff = 1.0 - smoothstep(0.85, 1.0, edgeDist);
                cdm2 *= edgeFalloff;
                
                vec4 texColor = texture2D(projTex, uv);
                float displayIntensity = cdm2 / 1500.0;
                
                return vec4(texColor.rgb * displayIntensity * facing, cdm2);
            }
            
            void main() {
                vec3 color = baseColor * 0.02;
                float totalCdm2 = 0.0;
                int hitCount = 0;
                
                if (numProjectors > 0) {
                    vec4 result = sampleProjector(projMat0, projTex0, shadowMap0, projPos0, projLumens0, projThrow0, projNear0, projFar0);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 1) {
                    vec4 result = sampleProjector(projMat1, projTex1, shadowMap1, projPos1, projLumens1, projThrow1, projNear1, projFar1);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 2) {
                    vec4 result = sampleProjector(projMat2, projTex2, shadowMap2, projPos2, projLumens2, projThrow2, projNear2, projFar2);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 3) {
                    vec4 result = sampleProjector(projMat3, projTex3, shadowMap3, projPos3, projLumens3, projThrow3, projNear3, projFar3);
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                
                if (showHeatmap) {
                    if (hitCount == 0) {
                        color = vec3(0.0, 0.0, 0.1);
                    } else {
                        float normalizedLuminance = totalCdm2 / heatmapMax;
                        color = heatmapColor(normalizedLuminance);
                    }
                } else {
                    if (showCoverage && hitCount == 0) {
                        color = vec3(0.25, 0.02, 0.02);
                    }
                    
                    if (showOverlap && hitCount > 1) {
                        float overlapIntensity = float(hitCount - 1) / 3.0;
                        color = mix(color, vec3(1.0, 0.5, 0.0), min(overlapIntensity, 0.7));
                    }
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // ==========================================
        // INITIALIZATION
        // ==========================================
        
        function init() {
            initThreeJS();
            initControls();
            initKeyboardControls();
            animate();
            updateStatus();
        }
        
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0c);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, -18);
            camera.rotation.order = 'YXZ';
            camera.rotation.set(0, Math.PI, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            
            gridHelper = new THREE.GridHelper(50, 50, 0x2a2a32, 0x1a1a20);
            scene.add(gridHelper);
            
            projectorGroup = new THREE.Group();
            surfaceGroup = new THREE.Group();
            distanceHelperGroup = new THREE.Group();
            scene.add(projectorGroup);
            scene.add(surfaceGroup);
            scene.add(distanceHelperGroup);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Custom linear depth material for better precision at distance
            // Standard depth buffers have poor precision at large distances
            const linearDepthVertexShader = `
                varying float vLinearDepth;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vLinearDepth = -mvPosition.z; // Linear view-space depth
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            const linearDepthFragmentShader = `
                varying float vLinearDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                
                // Pack float to RGBA for precision
                vec4 packDepth(float depth) {
                    float normalized = (depth - cameraNear) / (cameraFar - cameraNear);
                    normalized = clamp(normalized, 0.0, 1.0);
                    
                    const vec4 bitShift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
                    const vec4 bitMask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
                    vec4 res = fract(normalized * bitShift);
                    res -= res.xxyz * bitMask;
                    return res;
                }
                
                void main() {
                    gl_FragColor = packDepth(vLinearDepth);
                }
            `;
            
            depthMaterial = new THREE.ShaderMaterial({
                vertexShader: linearDepthVertexShader,
                fragmentShader: linearDepthFragmentShader,
                uniforms: {
                    cameraNear: { value: 0.1 },
                    cameraFar: { value: 100 }
                }
            });
            
            // Create transform gizmos
            createGizmos();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        // Create or update shadow map for a projector
        function updateShadowMap(projector) {
            // Use same vertical FOV calculation as projection matrix
            const verticalFov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom * projector.aspectRatio)) * (180 / Math.PI);
            
            const nearPlane = projector.nearPlane || 0.1;
            const farPlane = projector.farPlane || 100;
            
            let shadowData = shadowMaps.get(projector.id);
            
            if (!shadowData) {
                // Create new render target and camera
                const renderTarget = new THREE.WebGLRenderTarget(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat
                });
                
                const shadowCamera = new THREE.PerspectiveCamera(verticalFov, projector.aspectRatio, nearPlane, farPlane);
                
                shadowData = { renderTarget, camera: shadowCamera };
                shadowMaps.set(projector.id, shadowData);
            }
            
            // Update shadow camera
            const shadowCamera = shadowData.camera;
            shadowCamera.fov = verticalFov;
            shadowCamera.aspect = projector.aspectRatio;
            shadowCamera.near = nearPlane;
            shadowCamera.far = farPlane;
            shadowCamera.position.set(projector.position.x, projector.position.y, projector.position.z);
            
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z),
                'YXZ'
            );
            
            const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
            const target = new THREE.Vector3().copy(shadowCamera.position).add(forward);
            shadowCamera.lookAt(target);
            
            shadowCamera.updateMatrixWorld(true);
            shadowCamera.updateProjectionMatrix();
            
            // Render shadow map
            renderShadowMap(projector.id);
            
            return shadowData;
        }
        
        function renderShadowMap(projectorId) {
            const shadowData = shadowMaps.get(projectorId);
            if (!shadowData || !depthMaterial) return;
            
            const currentBackground = scene.background;
            const currentOverrideMaterial = scene.overrideMaterial;
            
            scene.background = null;
            scene.overrideMaterial = depthMaterial;
            
            // Hide gizmos, projectors, and distance helpers during shadow render
            const gizmoVisible = gizmoGroup ? gizmoGroup.visible : false;
            const projectorVisible = projectorGroup.visible;
            const distanceVisible = distanceHelperGroup ? distanceHelperGroup.visible : false;
            if (gizmoGroup) gizmoGroup.visible = false;
            if (distanceHelperGroup) distanceHelperGroup.visible = false;
            projectorGroup.visible = false;
            gridHelper.visible = false;
            
            renderer.setRenderTarget(shadowData.renderTarget);
            renderer.setClearColor(0xffffff, 1); // White = max depth (nothing there)
            renderer.clear();
            renderer.render(scene, shadowData.camera);
            renderer.setRenderTarget(null);
            renderer.setClearColor(0x0d0d12, 1); // Restore scene clear color
            
            // Restore
            scene.background = currentBackground;
            scene.overrideMaterial = currentOverrideMaterial;
            if (gizmoGroup) gizmoGroup.visible = gizmoVisible;
            if (distanceHelperGroup) distanceHelperGroup.visible = distanceVisible;
            projectorGroup.visible = projectorVisible;
            gridHelper.visible = state.displayOptions.grid;
        }
        
        function renderAllShadowMaps() {
            state.projectors.filter(p => p.enabled).forEach(p => {
                updateShadowMap(p);
            });
        }
        
        function initControls() {
            let isMouseDown = false;
            let prevMouseX = 0, prevMouseY = 0;
            let mouseDownX = 0, mouseDownY = 0;
            let isDragging = false;
            let isGizmoActive = false;
            
            renderer.domElement.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    // Check if clicking on gizmo first
                    if (handleGizmoInteraction(e, 'down')) {
                        isGizmoActive = true;
                        return;
                    }
                }
                
                if (e.button === 0 || e.button === 2) {
                    isMouseDown = true;
                    isDragging = false;
                    prevMouseX = e.clientX;
                    prevMouseY = e.clientY;
                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('mouseup', e => {
                if (isGizmoActive) {
                    handleGizmoInteraction(e, 'up');
                    isGizmoActive = false;
                    gizmoState.startAngle = null;
                    return;
                }
                
                if (!isDragging && e.button === 0) {
                    handleCanvasClick(e);
                }
                isMouseDown = false;
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => { 
                isMouseDown = false; 
                isDragging = false;
                if (isGizmoActive) {
                    handleGizmoInteraction(null, 'up');
                    isGizmoActive = false;
                    gizmoState.startAngle = null;
                }
            });
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            renderer.domElement.addEventListener('mousemove', e => {
                // Handle gizmo dragging
                if (isGizmoActive) {
                    handleGizmoInteraction(e, 'move');
                    return;
                }
                
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                
                const totalMovement = Math.abs(e.clientX - mouseDownX) + Math.abs(e.clientY - mouseDownY);
                if (totalMovement > 5) isDragging = true;
                
                camera.rotation.order = 'YXZ';
                camera.rotation.y -= deltaX * 0.003;
                camera.rotation.x -= deltaY * 0.003;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
            
            // Gizmo hover effect
            renderer.domElement.addEventListener('mousemove', e => {
                if (isGizmoActive || !gizmoGroup || !gizmoGroup.visible) return;
                
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );
                
                gizmoRaycaster.setFromCamera(mouse, camera);
                
                const gizmoObjects = [];
                gizmoGroup.traverse(child => {
                    if (child.isMesh && child.userData.gizmoType) {
                        gizmoObjects.push(child);
                    }
                });
                
                const intersects = gizmoRaycaster.intersectObjects(gizmoObjects);
                
                // Reset cursor
                renderer.domElement.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
            });
        }
        
        function initKeyboardControls() {
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                const tag = document.activeElement.tagName;
                const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement.isContentEditable;
                
                // Skip all hotkeys if user is typing in an input field
                if (isTyping) {
                    // Only allow Escape to blur the input
                    if (key === 'escape') {
                        document.activeElement.blur();
                        e.preventDefault();
                    }
                    return; // Don't capture any other keys while typing
                }
                
                // WASD movement keys (only when not typing)
                if (keys.hasOwnProperty(key)) { 
                    keys[key] = true; 
                    e.preventDefault(); 
                }
                
                // Transform mode shortcuts
                if (key === 'g' && state.selectedObject) {
                    setTransformMode('translate');
                    e.preventDefault();
                } else if (key === 'r' && state.selectedObject) {
                    setTransformMode('rotate');
                    e.preventDefault();
                } else if (key === 'v') {
                    setTransformMode('select');
                    e.preventDefault();
                } else if (key === 'escape') {
                    // Cancel current operation or deselect
                    if (gizmoState.isDragging) {
                        gizmoState.isDragging = false;
                        gizmoState.activeAxis = null;
                        showGizmoInfo(false);
                    } else {
                        state.selectedObject = null;
                        state.selectedType = null;
                        updateProjectorList();
                        updateSurfaceList();
                        updatePropertiesPanel();
                        enableTransformTools(false);
                        updateGizmoPosition();
                    }
                    e.preventDefault();
                } else if (key === 'delete' || key === 'backspace') {
                    // Delete selected object
                    if (state.selectedObject) {
                        if (state.selectedType === 'projector') {
                            removeProjector(state.selectedObject);
                        } else if (state.selectedType === 'surface') {
                            removeSurface(state.selectedObject);
                        }
                        e.preventDefault();
                    }
                }
            });
            window.addEventListener('keyup', e => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
            });
        }
        
        function updateCameraMovement() {
            const speed = 0.15;
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            const right = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();
            
            const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
            const rightHoriz = new THREE.Vector3(right.x, 0, right.z).normalize();
            
            if (keys.w) camera.position.addScaledVector(forward, speed);
            if (keys.s) camera.position.addScaledVector(forward, -speed);
            if (keys.a) camera.position.addScaledVector(rightHoriz, -speed);
            if (keys.d) camera.position.addScaledVector(rightHoriz, speed);
            if (keys.e) camera.position.y += speed;
            if (keys.q) camera.position.y -= speed;
        }
        
        function handleCanvasClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const projMeshes = [];
            projectorGroup.traverse(c => { if (c.isMesh && c.userData.isProjector) projMeshes.push(c); });
            let hits = raycaster.intersectObjects(projMeshes);
            if (hits.length > 0) { selectObject('projector', hits[0].object.userData.projectorId); return; }
            
            hits = raycaster.intersectObjects(surfaceGroup.children);
            if (hits.length > 0 && hits[0].object.userData.surfaceId) {
                selectObject('surface', hits[0].object.userData.surfaceId);
            }
        }
        
        // ==========================================
        // TEXTURE GENERATION
        // ==========================================
        
        function createPatternTexture(pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            switch(pattern) {
                case 'none':
                    ctx.fillStyle = '#999';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'grid':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 512; i += 32) {
                        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
                    }
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(4, 4, 504, 504);
                    break;
                case 'checker':
                    for (let y = 0; y < 512; y += 32)
                        for (let x = 0; x < 512; x += 32) {
                            ctx.fillStyle = ((x + y) / 32) % 2 === 0 ? '#fff' : '#000';
                            ctx.fillRect(x, y, 32, 32);
                        }
                    break;
                case 'gradient':
                    const grad = ctx.createLinearGradient(0, 0, 512, 0);
                    grad.addColorStop(0, '#000'); grad.addColorStop(1, '#fff');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'colorbars':
                    ['#fff','#ff0','#0ff','#0f0','#f0f','#f00','#00f'].forEach((c, i) => {
                        ctx.fillStyle = c;
                        ctx.fillRect(i * 512/7, 0, 512/7 + 1, 512);
                    });
                    break;
                case 'cross':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(256, 0); ctx.lineTo(256, 512);
                    ctx.moveTo(0, 256); ctx.lineTo(512, 256);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(256, 256, 100, 0, Math.PI * 2);
                    ctx.arc(256, 256, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 3;
                    [[10,10],[452,10],[10,452],[452,452]].forEach(([x,y]) => ctx.strokeRect(x, y, 50, 50));
                    break;
                case 'white':
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'blend':
                    ctx.fillStyle = '#888';
                    ctx.fillRect(0, 0, 512, 512);
                    const lg = ctx.createLinearGradient(0, 0, 120, 0);
                    lg.addColorStop(0, 'rgba(255,0,0,1)'); lg.addColorStop(1, 'transparent');
                    ctx.fillStyle = lg; ctx.fillRect(0, 0, 120, 512);
                    const rg = ctx.createLinearGradient(392, 0, 512, 0);
                    rg.addColorStop(0, 'transparent'); rg.addColorStop(1, 'rgba(0,255,0,1)');
                    ctx.fillStyle = rg; ctx.fillRect(392, 0, 120, 512);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // ==========================================
        // PROJECTOR
        // ==========================================
        
        function addProjector(presetKey = 'custom') {
            const preset = projectorPresets[presetKey] || projectorPresets['custom'];
            const id = Date.now();
            const projector = {
                id,
                name: `Projector ${state.projectors.length + 1}`,
                preset: presetKey,
                position: { x: 0, y: 4, z: -8 },
                rotation: { x: -10, y: 0, z: 0 },
                lumens: preset.lumens,
                throwRatio: preset.throwRatio,
                aspectRatio: preset.aspectRatio,
                resolution: preset.resolution,
                zoom: 1.0,
                enabled: true,
                customTextureUrl: null,
                nearPlane: 0.1,
                farPlane: 100,
                frustumDistance: 20
            };
            
            state.projectors.push(projector);
            createProjectorMesh(projector);
            updateProjectorMatrix(projector);
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', id);
            calculateCoverage();
        }
        
        function createProjectorMesh(projector) {
            const group = new THREE.Group();
            group.userData.projectorId = projector.id;
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.2, 0.5),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            body.userData.isProjector = true;
            body.userData.projectorId = projector.id;
            group.add(body);
            
            // Direction indicator above projector
            const indicator = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.2, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            indicator.rotation.x = Math.PI / 2;
            indicator.position.y = 0.25;
            indicator.position.z = 0.15;
            group.add(indicator);
            
            group.add(createFrustum(projector));
            
            group.position.set(projector.position.x, projector.position.y, projector.position.z);
            group.rotation.set(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z)
            );
            
            projectorGroup.add(group);
        }
        
        function createFrustum(projector) {
            const group = new THREE.Group();
            group.userData.isFrustum = true;
            
            const dist = projector.frustumDistance || 20;
            // Calculate frustum dimensions at the target distance
            const w = (dist / projector.throwRatio) / projector.zoom;
            const h = w / projector.aspectRatio;
            
            const mat = new THREE.LineBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.5 });
            
            // Frustum edge lines from projector to far plane
            const pts = [
                [0,0,0], [-w/2,-h/2,dist], [0,0,0], [w/2,-h/2,dist],
                [0,0,0], [w/2,h/2,dist], [0,0,0], [-w/2,h/2,dist]
            ].map(p => new THREE.Vector3(...p));
            group.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), mat));
            
            // Rectangle at frustum end
            const rect = [[-w/2,-h/2,dist], [w/2,-h/2,dist], [w/2,h/2,dist], [-w/2,h/2,dist], [-w/2,-h/2,dist]]
                .map(p => new THREE.Vector3(...p));
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rect), mat));
            
            group.visible = state.displayOptions.frustums;
            return group;
        }
        
        function updateProjectorMatrix(projector) {
            // Calculate VERTICAL FOV from throw ratio
            // Throw ratio = distance / width, so horizontal half-angle = atan(1 / (2 * throwRatio * zoom))
            // Vertical half-angle = horizontal half-angle / aspectRatio
            // PerspectiveCamera expects vertical FOV
            const verticalFov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom * projector.aspectRatio)) * (180 / Math.PI);
            
            const nearPlane = projector.nearPlane || 0.1;
            const farPlane = projector.farPlane || 100;
            
            const projCam = new THREE.PerspectiveCamera(verticalFov, projector.aspectRatio, nearPlane, farPlane);
            projCam.position.set(projector.position.x, projector.position.y, projector.position.z);
            
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(projector.rotation.x),
                THREE.MathUtils.degToRad(projector.rotation.y),
                THREE.MathUtils.degToRad(projector.rotation.z),
                'YXZ'
            );
            
            const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
            const target = new THREE.Vector3().copy(projCam.position).add(forward);
            projCam.lookAt(target);
            
            projCam.updateMatrixWorld(true);
            projCam.updateProjectionMatrix();
            
            const vpMatrix = new THREE.Matrix4();
            vpMatrix.multiplyMatrices(projCam.projectionMatrix, projCam.matrixWorldInverse);
            
            projectorMatrixData.set(projector.id, {
                matrix: vpMatrix,
                position: new THREE.Vector3(projector.position.x, projector.position.y, projector.position.z),
                lumens: projector.lumens,
                throwRatio: projector.throwRatio * projector.zoom, // Effective throw ratio
                nearPlane: nearPlane,
                farPlane: farPlane
            });
            
            if (projector.customTextureUrl && customTextureData.has(projector.id)) {
                projectionTextures.set(projector.id, customTextureData.get(projector.id));
            } else {
                projectionTextures.set(projector.id, createPatternTexture(state.currentPattern));
            }
        }
        
        function updateProjectorMesh(projector) {
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === projector.id);
            if (mesh) {
                mesh.position.set(projector.position.x, projector.position.y, projector.position.z);
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(projector.rotation.x),
                    THREE.MathUtils.degToRad(projector.rotation.y),
                    THREE.MathUtils.degToRad(projector.rotation.z)
                );
                
                const oldF = mesh.children.find(c => c.userData.isFrustum);
                if (oldF) {
                    // Dispose old frustum geometry and materials
                    oldF.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    mesh.remove(oldF);
                }
                mesh.add(createFrustum(projector));
            }
            
            updateProjectorMatrix(projector);
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function applyPreset(projectorId, presetKey) {
            const projector = state.projectors.find(p => p.id === projectorId);
            const preset = projectorPresets[presetKey];
            if (!projector || !preset) return;
            
            projector.preset = presetKey;
            projector.lumens = preset.lumens;
            projector.throwRatio = preset.throwRatio;
            projector.aspectRatio = preset.aspectRatio;
            projector.resolution = preset.resolution;
            
            updateProjectorMesh(projector);
            updateProjectorList();
            updatePropertiesPanel();
        }
        
        function removeProjector(id) {
            state.projectors = state.projectors.filter(p => p.id !== id);
            
            // Clean up mesh and all its children
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
            if (mesh) {
                mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                projectorGroup.remove(mesh);
            }
            
            // Clean up shadow map render target
            const shadowData = shadowMaps.get(id);
            if (shadowData) {
                shadowData.renderTarget.dispose();
                shadowMaps.delete(id);
            }
            
            // Clean up textures
            const tex = projectionTextures.get(id);
            if (tex && !customTextureData.has(id)) {
                tex.dispose(); // Only dispose if not a custom texture
            }
            projectorMatrixData.delete(id);
            projectionTextures.delete(id);
            customTextureData.delete(id);
            
            if (state.selectedType === 'projector' && state.selectedObject === id) {
                state.selectedObject = null;
                state.selectedType = null;
                updatePropertiesPanel();
            }
            
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            calculateCoverage();
        }
        
        function loadCustomTexture(projectorId, file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    
                    const projector = state.projectors.find(p => p.id === projectorId);
                    if (projector) {
                        projector.customTextureUrl = e.target.result;
                        customTextureData.set(projectorId, texture);
                        projectionTextures.set(projectorId, texture);
                        updateAllSurfaceMaterials();
                        updatePropertiesPanel();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function clearCustomTexture(projectorId) {
            const projector = state.projectors.find(p => p.id === projectorId);
            if (projector) {
                projector.customTextureUrl = null;
                customTextureData.delete(projectorId);
                projectionTextures.set(projectorId, createPatternTexture(state.currentPattern));
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
            }
        }
        
        function updateProjectorList() {
            const list = document.getElementById('projector-list');
            document.getElementById('projector-count').textContent = state.projectors.length;
            
            if (state.projectors.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No projectors yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.projectors.map(p => `
                <div class="object-item ${state.selectedType === 'projector' && state.selectedObject === p.id ? 'selected' : ''}" onclick="selectObject('projector', ${p.id})">
                    <div class="object-icon projector"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                    <div class="object-info">
                        <div class="object-name">${p.name}</div>
                        <div class="object-type">${(p.lumens/1000).toFixed(0)}K lm${p.customTextureUrl ? ' • Custom' : ''}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn" onclick="event.stopPropagation(); duplicateProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>
            `).join('');
        }
        
        function duplicateProjector(id) {
            const orig = state.projectors.find(p => p.id === id);
            if (!orig) return;
            const dup = { ...JSON.parse(JSON.stringify(orig)), id: Date.now(), name: orig.name + ' (Copy)', position: { ...orig.position, x: orig.position.x + 2 }, customTextureUrl: null };
            state.projectors.push(dup);
            createProjectorMesh(dup);
            updateProjectorMatrix(dup);
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', dup.id);
            calculateCoverage();
        }
        
        // ==========================================
        // SURFACE
        // ==========================================
        
        function addSurface() {
            const id = Date.now();
            const surface = {
                id,
                name: `Surface ${state.surfaces.length + 1}`,
                type: 'flat',
                position: { x: 0, y: 3, z: 5 },
                rotation: { x: 0, y: 180, z: 0 },
                dimensions: { width: 8, height: 4.5 },
                curvature: 30,
                color: '#555555',
                gain: 1.0
            };
            
            state.surfaces.push(surface);
            createSurfaceMesh(surface);
            // Re-render shadow maps to include new surface, then update all materials
            updateAllSurfaceMaterials();
            updateSurfaceList();
            updateStatus();
            selectObject('surface', id);
            calculateCoverage();
        }
        
        function importOBJSurface(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(e.target.result);
                    
                    // Calculate bounding box to determine size and center
                    const box = new THREE.Box3().setFromObject(obj);
                    const size = new THREE.Vector3();
                    const center = new THREE.Vector3();
                    box.getSize(size);
                    box.getCenter(center);
                    
                    const id = Date.now();
                    const surface = {
                        id,
                        name: file.name.replace('.obj', ''),
                        type: 'custom',
                        position: { x: 0, y: size.y / 2, z: 5 },
                        rotation: { x: 0, y: 0, z: 0 },
                        dimensions: { width: size.x, height: size.y },
                        curvature: 0,
                        color: '#555555',
                        gain: 1.0,
                        scale: 1.0,
                        objData: e.target.result // Store OBJ data for export
                    };
                    
                    state.surfaces.push(surface);
                    
                    // Create mesh from OBJ with projection material
                    createOBJSurfaceMesh(surface, obj, center);
                    
                    // Re-render shadow maps to include new surface, then update all materials
                    updateAllSurfaceMaterials();
                    updateSurfaceList();
                    updateStatus();
                    selectObject('surface', id);
                    calculateCoverage();
                    
                    showToast(`Imported "${surface.name}" successfully`);
                } catch (err) {
                    console.error('OBJ import error:', err);
                    showToast('Failed to import OBJ file', 'error');
                }
            };
            
            reader.onerror = function() {
                showToast('Failed to read OBJ file', 'error');
            };
            
            reader.readAsText(file);
            
            // Reset file input
            document.getElementById('obj-import').value = '';
        }
        
        function createOBJSurfaceMesh(surface, obj, center) {
            // Merge all geometries from the OBJ
            const geometries = [];
            obj.traverse(child => {
                if (child.isMesh && child.geometry) {
                    // Clone and transform geometry
                    const geom = child.geometry.clone();
                    
                    // Center the geometry
                    geom.translate(-center.x, -center.y, -center.z);
                    
                    // Ensure normals exist
                    if (!geom.attributes.normal) {
                        geom.computeVertexNormals();
                    }
                    
                    geometries.push(geom);
                }
            });
            
            if (geometries.length === 0) {
                showToast('No valid geometry found in OBJ', 'error');
                return;
            }
            
            // Merge geometries if multiple
            let finalGeom;
            if (geometries.length === 1) {
                finalGeom = geometries[0];
            } else {
                // Simple merge - combine all buffer attributes
                const positions = [];
                const normals = [];
                const uvs = [];
                
                geometries.forEach(geom => {
                    const pos = geom.attributes.position;
                    const norm = geom.attributes.normal;
                    const uv = geom.attributes.uv;
                    
                    for (let i = 0; i < pos.count; i++) {
                        positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        if (norm) normals.push(norm.getX(i), norm.getY(i), norm.getZ(i));
                        if (uv) uvs.push(uv.getX(i), uv.getY(i));
                    }
                });
                
                finalGeom = new THREE.BufferGeometry();
                finalGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                if (normals.length > 0) {
                    finalGeom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                } else {
                    finalGeom.computeVertexNormals();
                }
                if (uvs.length > 0) {
                    finalGeom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                }
            }
            
            const mesh = new THREE.Mesh(finalGeom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface;
            mesh.userData.isCustomOBJ = true;
            
            mesh.position.set(surface.position.x, surface.position.y, surface.position.z);
            mesh.rotation.set(
                THREE.MathUtils.degToRad(surface.rotation.x),
                THREE.MathUtils.degToRad(surface.rotation.y),
                THREE.MathUtils.degToRad(surface.rotation.z)
            );
            
            // Apply scale
            const scale = surface.scale || 1.0;
            mesh.scale.setScalar(scale);
            
            surfaceGroup.add(mesh);
        }
        
        function createSurfaceMaterial(surface) {
            const defaultTex = createPatternTexture('none');
            const defaultShadowTex = new THREE.DataTexture(new Uint8Array([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat);
            defaultShadowTex.needsUpdate = true;
            
            const uniforms = {
                projTex0: { value: defaultTex }, projTex1: { value: defaultTex },
                projTex2: { value: defaultTex }, projTex3: { value: defaultTex },
                shadowMap0: { value: defaultShadowTex }, shadowMap1: { value: defaultShadowTex },
                shadowMap2: { value: defaultShadowTex }, shadowMap3: { value: defaultShadowTex },
                projMat0: { value: new THREE.Matrix4() }, projMat1: { value: new THREE.Matrix4() },
                projMat2: { value: new THREE.Matrix4() }, projMat3: { value: new THREE.Matrix4() },
                projPos0: { value: new THREE.Vector3() }, projPos1: { value: new THREE.Vector3() },
                projPos2: { value: new THREE.Vector3() }, projPos3: { value: new THREE.Vector3() },
                projLumens0: { value: 0 }, projLumens1: { value: 0 },
                projLumens2: { value: 0 }, projLumens3: { value: 0 },
                projThrow0: { value: 1.5 }, projThrow1: { value: 1.5 },
                projThrow2: { value: 1.5 }, projThrow3: { value: 1.5 },
                projNear0: { value: 0.1 }, projNear1: { value: 0.1 },
                projNear2: { value: 0.1 }, projNear3: { value: 0.1 },
                projFar0: { value: 100 }, projFar1: { value: 100 },
                projFar2: { value: 100 }, projFar3: { value: 100 },
                numProjectors: { value: 0 },
                showCoverage: { value: state.displayOptions.coverage },
                showOverlap: { value: state.displayOptions.overlap },
                showHeatmap: { value: state.displayOptions.heatmap },
                surfaceGain: { value: surface.gain },
                baseColor: { value: new THREE.Color(surface.color) },
                heatmapMax: { value: state.heatmapMax }
            };
            
            const enabled = state.projectors.filter(p => p.enabled);
            uniforms.numProjectors.value = enabled.length;
            
            enabled.slice(0, 4).forEach((proj, i) => {
                const data = projectorMatrixData.get(proj.id);
                const tex = projectionTextures.get(proj.id);
                const shadow = shadowMaps.get(proj.id);
                if (data) {
                    uniforms[`projMat${i}`].value.copy(data.matrix);
                    uniforms[`projPos${i}`].value.copy(data.position);
                    uniforms[`projLumens${i}`].value = data.lumens;
                    uniforms[`projThrow${i}`].value = data.throwRatio;
                    uniforms[`projNear${i}`].value = data.nearPlane || 0.1;
                    uniforms[`projFar${i}`].value = data.farPlane || 100;
                }
                if (tex) uniforms[`projTex${i}`].value = tex;
                if (shadow) uniforms[`shadowMap${i}`].value = shadow.renderTarget.texture;
            });
            
            return new THREE.ShaderMaterial({
                uniforms,
                vertexShader: projectionVertexShader,
                fragmentShader: projectionFragmentShader,
                side: THREE.DoubleSide
            });
        }
        
        function createSurfaceMesh(surface) {
            // Skip custom OBJ surfaces - they're handled by createOBJSurfaceMesh
            if (surface.type === 'custom') {
                // Re-parse OBJ data if available
                if (surface.objData) {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(surface.objData);
                    const box = new THREE.Box3().setFromObject(obj);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    createOBJSurfaceMesh(surface, obj, center);
                }
                return;
            }
            
            let geom;
            if (surface.type === 'curved' && surface.curvature > 0) {
                const angle = surface.curvature * Math.PI / 180;
                const radius = surface.dimensions.width / Math.max(angle, 0.01);
                geom = new THREE.CylinderGeometry(radius, radius, surface.dimensions.height, 64, 1, true, Math.PI - angle/2, angle);
            } else {
                geom = new THREE.PlaneGeometry(surface.dimensions.width, surface.dimensions.height, 32, 32);
            }
            
            const mesh = new THREE.Mesh(geom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface; // Store reference for coverage calculation
            mesh.position.set(surface.position.x, surface.position.y, surface.position.z);
            mesh.rotation.set(
                THREE.MathUtils.degToRad(surface.rotation.x),
                THREE.MathUtils.degToRad(surface.rotation.y),
                THREE.MathUtils.degToRad(surface.rotation.z)
            );
            surfaceGroup.add(mesh);
        }
        
        function updateSurfaceMesh(surface) {
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
            if (mesh) {
                mesh.material.dispose();
                mesh.geometry.dispose();
                surfaceGroup.remove(mesh);
                createSurfaceMesh(surface);
            }
            // Re-render shadow maps since surface geometry/position changed
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function updateAllSurfaceMaterials() {
            state.projectors.forEach(p => {
                if (!p.customTextureUrl) {
                    projectionTextures.set(p.id, createPatternTexture(state.currentPattern));
                }
            });
            
            // Always render shadow maps for physically accurate occlusion
            renderAllShadowMaps();
            
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (mesh) {
                    mesh.material.dispose();
                    mesh.material = createSurfaceMaterial(surface);
                }
            });
            
            // Update distance helpers if enabled
            if (state.displayOptions.distance) {
                updateDistanceHelpers();
            }
        }
        
        function removeSurface(id) {
            state.surfaces = state.surfaces.filter(s => s.id !== id);
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
            if (mesh) { mesh.material.dispose(); mesh.geometry.dispose(); surfaceGroup.remove(mesh); }
            if (state.selectedType === 'surface' && state.selectedObject === id) {
                state.selectedObject = null; state.selectedType = null; updatePropertiesPanel();
            }
            // Re-render shadow maps since surface no longer blocks light
            updateAllSurfaceMaterials();
            updateSurfaceList(); updateStatus(); calculateCoverage();
        }
        
        function updateSurfaceList() {
            const list = document.getElementById('surface-list');
            document.getElementById('surface-count').textContent = state.surfaces.length;
            
            if (state.surfaces.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No surfaces yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.surfaces.map(s => {
                const typeInfo = s.type === 'custom' 
                    ? `Custom OBJ • Scale ${(s.scale || 1.0).toFixed(1)}×`
                    : `${s.dimensions.width.toFixed(1)}m × ${s.dimensions.height.toFixed(1)}m • Gain ${s.gain}`;
                const icon = s.type === 'custom'
                    ? `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>`
                    : `<svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>`;
                return `
                <div class="object-item ${state.selectedType === 'surface' && state.selectedObject === s.id ? 'selected' : ''}" onclick="selectObject('surface', ${s.id})">
                    <div class="object-icon surface">${icon}</div>
                    <div class="object-info">
                        <div class="object-name">${s.name}</div>
                        <div class="object-type">${typeInfo}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeSurface(${s.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>`;
            }).join('');
        }
        
        // ==========================================
        // COVERAGE CALCULATION - PROPER IMPLEMENTATION
        // ==========================================
        
        function calculateCoverage() {
            if (state.surfaces.length === 0 || state.projectors.filter(p => p.enabled).length === 0) {
                updateCoverageDisplay(0, 0, 0, 0);
                return;
            }
            
            let totalSamples = 0;
            let coveredSamples = 0;
            let totalCdm2 = 0;
            let minCdm2 = Infinity;
            let maxCdm2 = 0;
            let cdm2Samples = [];
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            
            // Sample each surface using actual geometry
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (!mesh || !mesh.geometry) return;
                
                // Update matrix world to ensure accurate transforms
                mesh.updateMatrixWorld(true);
                
                const geometry = mesh.geometry;
                const positionAttr = geometry.attributes.position;
                const normalAttr = geometry.attributes.normal;
                
                if (!positionAttr) return;
                
                // For accuracy, sample at vertex positions and face centers
                const sampledPoints = [];
                
                // Sample vertices
                const vertexStride = Math.max(1, Math.floor(positionAttr.count / 200)); // Limit to ~200 vertices
                for (let i = 0; i < positionAttr.count; i += vertexStride) {
                    const localPos = new THREE.Vector3(
                        positionAttr.getX(i),
                        positionAttr.getY(i),
                        positionAttr.getZ(i)
                    );
                    
                    let localNormal;
                    if (normalAttr) {
                        localNormal = new THREE.Vector3(
                            normalAttr.getX(i),
                            normalAttr.getY(i),
                            normalAttr.getZ(i)
                        );
                    } else {
                        localNormal = new THREE.Vector3(0, 0, 1);
                    }
                    
                    sampledPoints.push({ pos: localPos, normal: localNormal });
                }
                
                // Also sample face centers for indexed geometry
                if (geometry.index) {
                    const indices = geometry.index.array;
                    const faceStride = Math.max(3, Math.floor(indices.length / 300) * 3); // Limit to ~100 faces
                    
                    for (let i = 0; i < indices.length; i += faceStride) {
                        if (i + 2 >= indices.length) break;
                        
                        const i0 = indices[i], i1 = indices[i + 1], i2 = indices[i + 2];
                        
                        const p0 = new THREE.Vector3(positionAttr.getX(i0), positionAttr.getY(i0), positionAttr.getZ(i0));
                        const p1 = new THREE.Vector3(positionAttr.getX(i1), positionAttr.getY(i1), positionAttr.getZ(i1));
                        const p2 = new THREE.Vector3(positionAttr.getX(i2), positionAttr.getY(i2), positionAttr.getZ(i2));
                        
                        // Face center
                        const center = new THREE.Vector3().addVectors(p0, p1).add(p2).divideScalar(3);
                        
                        // Face normal (computed from vertices)
                        const edge1 = new THREE.Vector3().subVectors(p1, p0);
                        const edge2 = new THREE.Vector3().subVectors(p2, p0);
                        const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                        
                        sampledPoints.push({ pos: center, normal: faceNormal });
                    }
                }
                
                // Process each sample point
                sampledPoints.forEach(sample => {
                    // Transform to world space
                    const worldPos = sample.pos.clone().applyMatrix4(mesh.matrixWorld);
                    
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    const worldNormal = sample.normal.clone().applyMatrix3(normalMatrix).normalize();
                    
                    totalSamples++;
                    let sampleCdm2 = 0;
                    let isHit = false;
                    
                    enabledProjectors.forEach(proj => {
                        const data = projectorMatrixData.get(proj.id);
                        const shadowData = shadowMaps.get(proj.id);
                        if (!data) return;
                        
                        // Check if point is within projector frustum
                        const projCoord = new THREE.Vector4(worldPos.x, worldPos.y, worldPos.z, 1);
                        projCoord.applyMatrix4(data.matrix);
                        
                        if (projCoord.w <= 0) return;
                        
                        const ndc = new THREE.Vector3(
                            projCoord.x / projCoord.w,
                            projCoord.y / projCoord.w,
                            projCoord.z / projCoord.w
                        );
                        
                        const uv = new THREE.Vector2(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
                        
                        if (uv.x < 0 || uv.x > 1 || uv.y < 0 || uv.y > 1) return;
                        if (ndc.z < -1 || ndc.z > 1) return;
                        
                        // Check facing - surface must face the projector
                        const toProj = new THREE.Vector3().subVectors(data.position, worldPos).normalize();
                        const facing = worldNormal.dot(toProj);
                        if (facing <= 0) return;
                        
                        // Shadow occlusion check - sample shadow map
                        // This mirrors the shader logic
                        if (shadowData && shadowData.renderTarget) {
                            const fragDepthNormalized = ndc.z * 0.5 + 0.5;
                            
                            // Read shadow map at this UV (approximation - we use a raycast instead for CPU accuracy)
                            // For better accuracy, cast a ray from projector to point and check for intersections
                            const rayOrigin = data.position.clone();
                            const rayDir = new THREE.Vector3().subVectors(worldPos, rayOrigin).normalize();
                            const distToPoint = data.position.distanceTo(worldPos);
                            
                            const shadowRay = new THREE.Raycaster(rayOrigin, rayDir, 0.01, distToPoint - 0.01);
                            const intersects = shadowRay.intersectObjects(surfaceGroup.children, false);
                            
                            // If ray hits something before reaching this point, it's occluded
                            if (intersects.length > 0) {
                                const hitDist = intersects[0].distance;
                                if (hitDist < distToPoint - 0.05) {
                                    return; // Occluded by another surface
                                }
                            }
                        }
                        
                        isHit = true;
                        
                        // Calculate luminance in cd/m²
                        const dist = data.position.distanceTo(worldPos);
                        const projWidth = dist / data.throwRatio;
                        const projHeight = projWidth / proj.aspectRatio;
                        const projArea = projWidth * projHeight;
                        const lux = data.lumens / projArea;
                        const cdm2 = (lux * surface.gain / Math.PI) * facing;
                        
                        sampleCdm2 += cdm2;
                    });
                    
                    if (isHit) {
                        coveredSamples++;
                        cdm2Samples.push(sampleCdm2);
                        totalCdm2 += sampleCdm2;
                        minCdm2 = Math.min(minCdm2, sampleCdm2);
                        maxCdm2 = Math.max(maxCdm2, sampleCdm2);
                    }
                });
            });
            
            const coverage = totalSamples > 0 ? (coveredSamples / totalSamples) * 100 : 0;
            const avgCdm2 = cdm2Samples.length > 0 ? totalCdm2 / cdm2Samples.length : 0;
            
            updateCoverageDisplay(
                coverage,
                avgCdm2,
                minCdm2 === Infinity ? 0 : minCdm2,
                maxCdm2
            );
        }
        
        function updateCoverageDisplay(coverage, avgCdm2, minCdm2, maxCdm2) {
            document.getElementById('coverage-fill').style.width = coverage + '%';
            document.getElementById('coverage-percent').textContent = coverage.toFixed(1) + '%';
            document.getElementById('avg-cdm2').textContent = Math.round(avgCdm2).toLocaleString();
            document.getElementById('min-cdm2').textContent = Math.round(minCdm2).toLocaleString();
            document.getElementById('max-cdm2').textContent = Math.round(maxCdm2).toLocaleString();
        }
        
        // ==========================================
        // SELECTION & PROPERTIES
        // ==========================================
        
        function selectObject(type, id) {
            state.selectedType = type;
            state.selectedObject = id;
            updateProjectorList();
            updateSurfaceList();
            updatePropertiesPanel();
            
            // Enable/disable transform tools based on selection
            enableTransformTools(!!id);
            
            // Update gizmo position
            updateGizmoPosition();
            
            // Default to translate mode when selecting
            if (id && gizmoState.mode === 'select') {
                setTransformMode('translate');
            }
        }
        
        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-panel');
            
            if (!state.selectedObject) {
                panel.innerHTML = `<div class="no-selection"><div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div><h3>No Selection</h3><p>Select an object to edit.</p></div>`;
                return;
            }
            
            if (state.selectedType === 'projector') {
                const p = state.projectors.find(x => x.id === state.selectedObject);
                if (!p) return;
                
                const presetOptions = Object.entries(projectorPresets).map(([key, val]) => 
                    `<option value="${key}" ${p.preset === key ? 'selected' : ''}>${val.name}</option>`
                ).join('');
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Projector</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${p.name}" onchange="updateProjectorProp(${p.id}, 'name', this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Preset</span><div class="single-input"><select onchange="applyPreset(${p.id}, this.value)">${presetOptions}</select></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${p.position.x}" onchange="updateProjectorPos(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${p.position.y}" onchange="updateProjectorPos(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${p.position.z}" onchange="updateProjectorPos(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${p.rotation.x}" onchange="updateProjectorRot(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${p.rotation.y}" onchange="updateProjectorRot(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${p.rotation.z}" onchange="updateProjectorRot(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Optics</div>
                            <div class="slider-row"><span class="slider-label">Throw Ratio</span><div class="slider-container"><input type="range" class="slider" min="0.3" max="3" step="0.05" value="${p.throwRatio}" oninput="updateProjectorProp(${p.id}, 'throwRatio', +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(2)"><span class="slider-value">${p.throwRatio.toFixed(2)}</span></div></div>
                            <div class="slider-row"><span class="slider-label">Zoom</span><div class="slider-container"><input type="range" class="slider" min="0.8" max="1.5" step="0.01" value="${p.zoom}" oninput="updateProjectorProp(${p.id}, 'zoom', +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(2)+'x'"><span class="slider-value">${p.zoom.toFixed(2)}x</span></div></div>
                            <div class="property-row"><span class="property-label">Lumens</span><div class="single-input"><input type="number" step="1000" value="${p.lumens}" onchange="updateProjectorProp(${p.id}, 'lumens', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Resolution</span><div class="single-input"><input type="text" value="${p.resolution || '1920×1080'}" readonly style="opacity: 0.6;"></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Custom Texture</div>
                            ${p.customTextureUrl ? `
                                <div class="texture-preview" style="background-image: url('${p.customTextureUrl}')"></div>
                                <button class="btn clear-texture-btn" onclick="clearCustomTexture(${p.id})">Clear Custom Texture</button>
                            ` : `
                                <div class="texture-upload" onclick="document.getElementById('tex-upload-${p.id}').click()">
                                    <input type="file" id="tex-upload-${p.id}" accept="image/*" onchange="loadCustomTexture(${p.id}, this.files[0])">
                                    <p>Click to upload image</p>
                                </div>
                            `}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Range</div>
                            <div class="slider-row"><span class="slider-label">Max Distance</span><div class="slider-container"><input type="range" class="slider" min="10" max="500" step="5" value="${p.farPlane || 100}" oninput="updateProjectorProp(${p.id}, 'farPlane', +this.value); this.nextElementSibling.textContent=this.value+'m'"><span class="slider-value">${(p.farPlane || 100)}m</span></div></div>
                            <div class="slider-row"><span class="slider-label">Frustum Display</span><div class="slider-container"><input type="range" class="slider" min="5" max="100" step="1" value="${p.frustumDistance || 20}" oninput="updateProjectorProp(${p.id}, 'frustumDistance', +this.value); this.nextElementSibling.textContent=this.value+'m'"><span class="slider-value">${(p.frustumDistance || 20)}m</span></div></div>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Max Distance affects shadow occlusion range</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Display</div>
                            <div class="toggle-row"><span class="toggle-label">Enabled</span><div class="toggle ${p.enabled ? 'active' : ''}" onclick="toggleProjectorEnabled(${p.id})"></div></div>
                        </div>
                    </div></div>`;
            } else if (state.selectedType === 'surface') {
                const s = state.surfaces.find(x => x.id === state.selectedObject);
                if (!s) return;
                
                const isCustomOBJ = s.type === 'custom';
                
                // Build type selector HTML (hidden for custom OBJ)
                const typeHtml = isCustomOBJ 
                    ? `<div class="property-row"><span class="property-label">Type</span><div class="single-input"><input type="text" value="Custom OBJ" disabled style="opacity: 0.6"></div></div>`
                    : `<div class="property-row"><span class="property-label">Type</span><div class="single-input"><select onchange="updateSurfaceProp(${s.id}, 'type', this.value)"><option value="flat" ${s.type==='flat'?'selected':''}>Flat</option><option value="curved" ${s.type==='curved'?'selected':''}>Curved</option></select></div></div>`;
                
                // Build dimensions HTML (scale for OBJ, width/height for others)
                let dimensionsHtml;
                if (isCustomOBJ) {
                    const scale = s.scale || 1.0;
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Scale</div>
                            <div class="slider-row"><span class="slider-label">Uniform Scale</span><div class="slider-container"><input type="range" class="slider" min="0.1" max="5" step="0.1" value="${scale}" oninput="updateSurfaceScale(${s.id}, +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(1)+'×'"><span class="slider-value">${scale.toFixed(1)}×</span></div></div>
                            <div class="property-row" style="opacity: 0.6"><span class="property-label">Original Size</span><div class="single-input"><input type="text" value="${s.dimensions.width.toFixed(1)}m × ${s.dimensions.height.toFixed(1)}m" disabled></div></div>
                        </div>`;
                } else {
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Width (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'width', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Height (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.height}" onchange="updateSurfaceDim(${s.id}, 'height', +this.value)"></div></div>
                            ${s.type === 'curved' ? `<div class="slider-row"><span class="slider-label">Curvature</span><div class="slider-container"><input type="range" class="slider" min="5" max="180" value="${s.curvature}" oninput="updateSurfaceProp(${s.id}, 'curvature', +this.value); this.nextElementSibling.textContent=this.value+'°'"><span class="slider-value">${s.curvature}°</span></div></div>` : ''}
                        </div>`;
                }
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Surface</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${s.name}" onchange="updateSurfaceProp(${s.id}, 'name', this.value)"></div></div>
                            ${typeHtml}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${s.position.x}" onchange="updateSurfacePos(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${s.position.y}" onchange="updateSurfacePos(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${s.position.z}" onchange="updateSurfacePos(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${s.rotation.x}" onchange="updateSurfaceRot(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${s.rotation.y}" onchange="updateSurfaceRot(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${s.rotation.z}" onchange="updateSurfaceRot(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        ${dimensionsHtml}
                        <div class="property-group">
                            <div class="property-group-title">Screen Properties</div>
                            <div class="slider-row"><span class="slider-label">Screen Gain</span><div class="slider-container"><input type="range" class="slider" min="0.5" max="2.5" step="0.1" value="${s.gain}" oninput="updateSurfaceProp(${s.id}, 'gain', +this.value); this.nextElementSibling.textContent=Number(this.value).toFixed(1)"><span class="slider-value">${s.gain.toFixed(1)}</span></div></div>
                        </div>
                    </div></div>`;
            }
        }
        
        // ==========================================
        // PROPERTY HANDLERS
        // ==========================================
        // PROPERTY HANDLERS WITH VALIDATION
        // ==========================================
        
        function updateProjectorProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Validate numeric properties
                if (prop === 'lumens') val = Math.max(100, Math.min(100000, val));
                if (prop === 'throwRatio') val = Math.max(0.3, Math.min(10, val));
                if (prop === 'zoom') val = Math.max(0.5, Math.min(2, val));
                
                p[prop] = val;
                if (prop !== 'name') p.preset = 'custom';
                updateProjectorMesh(p);
                updateProjectorList();
            }
        }
        
        function updateProjectorPos(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) { p.position[axis] = val; updateProjectorMesh(p); }
        }
        
        function updateProjectorRot(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) { p.rotation[axis] = val; updateProjectorMesh(p); }
        }
        
        function toggleProjectorEnabled(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p.enabled = !p.enabled;
                const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
                if (mesh) mesh.visible = p.enabled;
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
                calculateCoverage();
            }
        }
        
        function updateSurfaceProp(id, prop, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                // Validate gain
                if (prop === 'gain') val = Math.max(0.1, Math.min(5, val));
                if (prop === 'curvature') val = Math.max(0, Math.min(180, val));
                
                s[prop] = val;
                updateSurfaceMesh(s);
                updateSurfaceList();
                updatePropertiesPanel();
            }
        }
        
        function updateSurfacePos(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) { s.position[axis] = val; updateSurfaceMesh(s); }
        }
        
        function updateSurfaceRot(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) { s.rotation[axis] = val; updateSurfaceMesh(s); }
        }
        
        function updateSurfaceDim(id, dim, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                // Validate dimensions - must be positive
                val = Math.max(0.1, Math.min(100, val));
                s.dimensions[dim] = val;
                updateSurfaceMesh(s);
            }
        }
        
        function updateSurfaceScale(id, scale) {
            const s = state.surfaces.find(x => x.id === id);
            if (s && s.type === 'custom') {
                // Validate scale
                scale = Math.max(0.1, Math.min(10, scale));
                s.scale = scale;
                // Update the mesh scale
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
                if (mesh) {
                    mesh.scale.setScalar(scale);
                }
                updateAllSurfaceMaterials();
                debouncedCalculateCoverage();
            }
        }
        
        // Debounced coverage calculation for better performance
        let coverageTimeout = null;
        function debouncedCalculateCoverage() {
            if (coverageTimeout) clearTimeout(coverageTimeout);
            coverageTimeout = setTimeout(calculateCoverage, 150);
        }
        
        // ==========================================
        // VIEW & OPTIONS
        // ==========================================
        
        function setView(view) {
            state.currentView = view;
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            const views = {
                perspective: () => { camera.position.set(0, 8, -18); camera.rotation.set(0, Math.PI, 0); },
                top: () => { camera.position.set(0, 25, 0.01); camera.rotation.set(-Math.PI/2, 0, 0); },
                front: () => { camera.position.set(0, 3, -20); camera.rotation.set(0, Math.PI, 0); },
                side: () => { camera.position.set(-20, 3, 0); camera.rotation.set(0, Math.PI/2, 0); },
                projector: () => {
                    let p = null;
                    if (state.selectedType === 'projector' && state.selectedObject) {
                        p = state.projectors.find(x => x.id === state.selectedObject);
                    }
                    if (!p && state.projectors.length) p = state.projectors[0];
                    if (p) {
                        camera.position.set(p.position.x, p.position.y, p.position.z);
                        const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(
                            THREE.MathUtils.degToRad(p.rotation.x),
                            THREE.MathUtils.degToRad(p.rotation.y),
                            THREE.MathUtils.degToRad(p.rotation.z), 'YXZ'
                        ));
                        camera.lookAt(p.position.x + forward.x * 10, p.position.y + forward.y * 10, p.position.z + forward.z * 10);
                    }
                }
            };
            views[view]?.();
            document.getElementById('camera-info').textContent = view.charAt(0).toUpperCase() + view.slice(1);
        }
        
        function toggleOption(opt) {
            state.displayOptions[opt] = !state.displayOptions[opt];
            document.getElementById(`toggle-${opt}`).classList.toggle('active', state.displayOptions[opt]);
            
            if (opt === 'frustums') projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
            else if (opt === 'grid') gridHelper.visible = state.displayOptions.grid;
            else if (opt === 'wireframe') surfaceGroup.children.forEach(m => { if (m.material) m.material.wireframe = state.displayOptions.wireframe; });
            else if (opt === 'heatmap') {
                document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) m.material.uniforms.showHeatmap.value = state.displayOptions.heatmap;
                });
            }
            else if (opt === 'coverage' || opt === 'overlap') {
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) {
                        m.material.uniforms.showCoverage.value = state.displayOptions.coverage;
                        m.material.uniforms.showOverlap.value = state.displayOptions.overlap;
                    }
                });
            }
            else if (opt === 'distance') {
                updateDistanceHelpers();
            }
        }
        
        function updateDistanceHelpers() {
            // Clear existing helpers
            while (distanceHelperGroup.children.length > 0) {
                const child = distanceHelperGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                distanceHelperGroup.remove(child);
            }
            
            // Remove any existing labels
            document.querySelectorAll('.distance-label').forEach(el => el.remove());
            
            if (!state.displayOptions.distance) return;
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            if (enabledProjectors.length === 0 || surfaceGroup.children.length === 0) return;
            
            enabledProjectors.forEach(proj => {
                // Get projector world position and direction
                const projMesh = projectorGroup.children.find(c => c.userData.projectorId === proj.id);
                if (!projMesh) return;
                
                const projPos = new THREE.Vector3(proj.position.x, proj.position.y, proj.position.z);
                
                // Calculate forward direction from rotation
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(proj.rotation.x),
                    THREE.MathUtils.degToRad(proj.rotation.y),
                    THREE.MathUtils.degToRad(proj.rotation.z),
                    'YXZ'
                );
                const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                
                // Raycast from projector center to find nearest surface
                const raycaster = new THREE.Raycaster(projPos, forward, 0.1, proj.farPlane || 100);
                const intersects = raycaster.intersectObjects(surfaceGroup.children, false);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const distance = hit.distance;
                    
                    // Create line from projector to hit point
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([projPos, hit.point]);
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00, 
                        transparent: true, 
                        opacity: 0.8,
                        depthTest: false
                    });
                    const line = new THREE.Line(lineGeom, lineMat);
                    line.renderOrder = 999;
                    distanceHelperGroup.add(line);
                    
                    // Create a small sphere at the hit point
                    const sphereGeom = new THREE.SphereGeometry(0.05, 8, 8);
                    const sphereMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
                    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                    sphere.position.copy(hit.point);
                    sphere.renderOrder = 999;
                    distanceHelperGroup.add(sphere);
                    
                    // Create HTML label for distance
                    const label = document.createElement('div');
                    label.className = 'distance-label';
                    label.innerHTML = `
                        <strong>${proj.name}</strong><br>
                        ${distance.toFixed(2)}m
                    `;
                    label.dataset.projectorId = proj.id;
                    document.querySelector('.viewport').appendChild(label);
                    
                    // Store hit point for label positioning in animate loop
                    label.hitPoint = hit.point.clone();
                    label.midPoint = projPos.clone().add(hit.point).multiplyScalar(0.5);
                }
            });
        }
        
        function updateHeatmapMax(value) {
            state.heatmapMax = value;
            document.getElementById('legend-mid').textContent = Math.round(value / 2);
            document.getElementById('legend-max').textContent = value + '+';
            
            // Update all surface materials with new heatmap max
            surfaceGroup.children.forEach(m => {
                if (m.material?.uniforms?.heatmapMax) {
                    m.material.uniforms.heatmapMax.value = value;
                }
            });
        }
        
        function setPattern(pattern) {
            state.currentPattern = pattern;
            document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            updateAllSurfaceMaterials();
        }
        
        // ==========================================
        // UTILITY
        // ==========================================
        
        function updateStatus() {
            document.getElementById('projector-status').textContent = state.projectors.length + ' Projector' + (state.projectors.length !== 1 ? 's' : '');
            document.getElementById('surface-status').textContent = state.surfaces.length + ' Surface' + (state.surfaces.length !== 1 ? 's' : '');
        }
        
        function resetScene() {
            while (projectorGroup.children.length) projectorGroup.remove(projectorGroup.children[0]);
            while (surfaceGroup.children.length) { const m = surfaceGroup.children[0]; m.material?.dispose(); m.geometry?.dispose(); surfaceGroup.remove(m); }
            state.projectors = []; state.surfaces = []; state.selectedObject = null; state.selectedType = null;
            projectorMatrixData.clear(); projectionTextures.clear(); customTextureData.clear();
            updateProjectorList(); updateSurfaceList(); updatePropertiesPanel(); updateStatus();
            updateCoverageDisplay(0, 0, 0, 0);
            
            // Reset transform tools
            enableTransformTools(false);
            setTransformMode('select');
            if (gizmoGroup) gizmoGroup.visible = false;
        }
        
        // ==========================================
        // IMPORT / EXPORT
        // ==========================================
        
        const exportOptions = {
            projectors: true,
            surfaces: true,
            settings: true,
            textures: false
        };
        
        const importOptions = {
            replace: true,
            merge: false
        };
        
        let pendingImportData = null;
        
        function showExportModal() {
            // Check if session is valid, otherwise request authentication
            if (!isSessionValid()) {
                requestAuthentication(_showExportModalInternal);
                return;
            }
            _showExportModalInternal();
        }
        
        function _showExportModalInternal() {
            // Update counts
            document.getElementById('export-projector-count').textContent = 
                `${state.projectors.length} projector${state.projectors.length !== 1 ? 's' : ''} with settings`;
            document.getElementById('export-surface-count').textContent = 
                `${state.surfaces.length} surface${state.surfaces.length !== 1 ? 's' : ''} with settings`;
            
            const textureCount = state.projectors.filter(p => p.customTextureUrl).length;
            document.getElementById('export-texture-count').textContent = 
                textureCount > 0 ? `${textureCount} custom texture${textureCount !== 1 ? 's' : ''} (increases file size)` : 'No custom textures';
            
            // Set default filename with timestamp
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`;
            document.getElementById('export-filename').value = `projection-config-${timestamp}`;
            
            document.getElementById('export-modal').classList.add('active');
        }
        
        function toggleExportOption(option) {
            exportOptions[option] = !exportOptions[option];
            const checkbox = document.getElementById(`export-check-${option}`);
            checkbox.classList.toggle('checked', exportOptions[option]);
        }
        
        function toggleImportOption(option) {
            // Radio-button behavior for replace/merge
            if (option === 'replace') {
                importOptions.replace = true;
                importOptions.merge = false;
            } else if (option === 'merge') {
                importOptions.replace = false;
                importOptions.merge = true;
            }
            
            document.getElementById('import-check-replace').classList.toggle('checked', importOptions.replace);
            document.getElementById('import-check-merge').classList.toggle('checked', importOptions.merge);
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            if (id === 'import-modal') {
                pendingImportData = null;
            }
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            
            toastMessage.textContent = message;
            toast.className = `toast ${type} active`;
            
            // Update icon based on type
            const svg = toast.querySelector('svg');
            if (type === 'success') {
                svg.innerHTML = '<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>';
            } else if (type === 'error') {
                svg.innerHTML = '<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>';
            }
            
            setTimeout(() => {
                toast.classList.remove('active');
            }, 3000);
        }
        
        function doExport() {
            const filename = document.getElementById('export-filename').value.trim() || 'projection-config';
            
            const config = {
                version: '2.4',
                exportDate: new Date().toISOString(),
                metadata: {
                    projectorCount: state.projectors.length,
                    surfaceCount: state.surfaces.length
                }
            };
            
            if (exportOptions.projectors) {
                config.projectors = state.projectors.map(p => {
                    const proj = { ...p };
                    if (!exportOptions.textures) {
                        proj.customTextureUrl = null;
                    }
                    return proj;
                });
            }
            
            if (exportOptions.surfaces) {
                config.surfaces = [...state.surfaces];
            }
            
            if (exportOptions.settings) {
                config.settings = {
                    currentPattern: state.currentPattern,
                    displayOptions: { ...state.displayOptions },
                    heatmapMax: state.heatmapMax,
                    currentView: state.currentView
                };
            }
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeModal('export-modal');
            showToast(`Exported "${filename}.json" successfully`);
        }
        
        function importConfig(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    pendingImportData = data;
                    
                    // Update preview
                    document.getElementById('import-version').textContent = data.version || 'Unknown';
                    document.getElementById('import-projectors').textContent = 
                        data.projectors ? `${data.projectors.length} projector${data.projectors.length !== 1 ? 's' : ''}` : 'None';
                    document.getElementById('import-surfaces').textContent = 
                        data.surfaces ? `${data.surfaces.length} surface${data.surfaces.length !== 1 ? 's' : ''}` : 'None';
                    
                    const textureCount = data.projectors ? data.projectors.filter(p => p.customTextureUrl).length : 0;
                    document.getElementById('import-textures').textContent = 
                        textureCount > 0 ? `${textureCount} embedded` : 'None';
                    
                    document.getElementById('import-settings').textContent = 
                        data.settings ? 'Included' : 'Not included';
                    
                    // Show modal
                    document.getElementById('import-modal').classList.add('active');
                    
                    // Clear file input so same file can be selected again
                    document.getElementById('import-file').value = '';
                    
                } catch (err) {
                    showToast('Error parsing file: Invalid JSON format', 'error');
                    console.error('Import error:', err);
                }
            };
            reader.onerror = function() {
                showToast('Error reading file', 'error');
            };
            reader.readAsText(file);
        }
        
        function doImport() {
            if (!pendingImportData) {
                showToast('No import data available', 'error');
                return;
            }
            
            const data = pendingImportData;
            
            // Clear scene if replacing
            if (importOptions.replace) {
                resetScene();
            }
            
            let importedProjectors = 0;
            let importedSurfaces = 0;
            
            // Import projectors
            if (data.projectors && Array.isArray(data.projectors)) {
                data.projectors.forEach(projData => {
                    const id = Date.now() + Math.random() * 1000;
                    const projector = {
                        id,
                        name: projData.name || `Projector ${state.projectors.length + 1}`,
                        preset: projData.preset || 'custom',
                        position: projData.position || { x: 0, y: 4, z: -8 },
                        rotation: projData.rotation || { x: -10, y: 0, z: 0 },
                        lumens: projData.lumens || 10000,
                        throwRatio: projData.throwRatio || 1.5,
                        aspectRatio: projData.aspectRatio || 16/9,
                        resolution: projData.resolution || '1920×1080',
                        zoom: projData.zoom || 1.0,
                        enabled: projData.enabled !== false,
                        customTextureUrl: projData.customTextureUrl || null,
                        nearPlane: projData.nearPlane || 0.1,
                        farPlane: projData.farPlane || 100,
                        frustumDistance: projData.frustumDistance || 20
                    };
                    
                    state.projectors.push(projector);
                    createProjectorMesh(projector);
                    
                    // Load custom texture if present
                    if (projector.customTextureUrl) {
                        const img = new Image();
                        img.onload = function() {
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            customTextureData.set(projector.id, texture);
                            projectionTextures.set(projector.id, texture);
                            updateAllSurfaceMaterials();
                        };
                        img.src = projector.customTextureUrl;
                    }
                    
                    updateProjectorMatrix(projector);
                    importedProjectors++;
                });
            }
            
            // Import surfaces
            if (data.surfaces && Array.isArray(data.surfaces)) {
                data.surfaces.forEach(surfData => {
                    const id = Date.now() + Math.random() * 1000;
                    const surface = {
                        id,
                        name: surfData.name || `Surface ${state.surfaces.length + 1}`,
                        type: surfData.type || 'flat',
                        position: surfData.position || { x: 0, y: 3, z: 5 },
                        rotation: surfData.rotation || { x: 0, y: 180, z: 0 },
                        dimensions: surfData.dimensions || { width: 8, height: 4.5 },
                        curvature: surfData.curvature || 30,
                        color: surfData.color || '#555555',
                        gain: surfData.gain || 1.0
                    };
                    
                    state.surfaces.push(surface);
                    createSurfaceMesh(surface);
                    importedSurfaces++;
                });
            }
            
            // Import settings
            if (data.settings) {
                if (data.settings.currentPattern) {
                    state.currentPattern = data.settings.currentPattern;
                    document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                    // Try to activate the right pattern button
                    const patternBtns = document.querySelectorAll('.pattern-btn');
                    const patterns = ['none', 'grid', 'checker', 'gradient', 'colorbars', 'cross', 'white', 'blend'];
                    const idx = patterns.indexOf(data.settings.currentPattern);
                    if (idx >= 0 && patternBtns[idx]) patternBtns[idx].classList.add('active');
                }
                
                if (data.settings.displayOptions) {
                    Object.keys(data.settings.displayOptions).forEach(key => {
                        if (state.displayOptions.hasOwnProperty(key)) {
                            state.displayOptions[key] = data.settings.displayOptions[key];
                            const toggle = document.getElementById(`toggle-${key}`);
                            if (toggle) toggle.classList.toggle('active', state.displayOptions[key]);
                        }
                    });
                    
                    // Apply display options
                    projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
                    gridHelper.visible = state.displayOptions.grid;
                    document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                }
                
                if (data.settings.heatmapMax) {
                    state.heatmapMax = data.settings.heatmapMax;
                    document.getElementById('heatmap-max-slider').value = data.settings.heatmapMax;
                    document.getElementById('heatmap-max-value').textContent = data.settings.heatmapMax;
                    document.getElementById('legend-mid').textContent = Math.round(data.settings.heatmapMax / 2);
                    document.getElementById('legend-max').textContent = data.settings.heatmapMax + '+';
                }
            }
            
            // Update UI
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateSurfaceList();
            updateStatus();
            calculateCoverage();
            
            closeModal('import-modal');
            
            const message = `Imported ${importedProjectors} projector${importedProjectors !== 1 ? 's' : ''} and ${importedSurfaces} surface${importedSurfaces !== 1 ? 's' : ''}`;
            showToast(message);
        }
        
        function quickSave() {
            // Check if session is valid, otherwise request authentication
            if (!isSessionValid()) {
                requestAuthentication(_quickSaveInternal);
                return;
            }
            _quickSaveInternal();
        }
        
        function _quickSaveInternal() {
            // Quick save with current timestamp
            const date = new Date();
            const timestamp = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}_${String(date.getHours()).padStart(2,'0')}-${String(date.getMinutes()).padStart(2,'0')}`;
            
            const config = {
                version: '2.4',
                exportDate: date.toISOString(),
                metadata: {
                    projectorCount: state.projectors.length,
                    surfaceCount: state.surfaces.length
                },
                projectors: state.projectors.map(p => ({ ...p })),
                surfaces: [...state.surfaces],
                settings: {
                    currentPattern: state.currentPattern,
                    displayOptions: { ...state.displayOptions },
                    heatmapMax: state.heatmapMax,
                    currentView: state.currentView
                }
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `projection-autosave-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Project saved successfully');
        }
        
        function confirmNewProject() {
            if (state.projectors.length === 0 && state.surfaces.length === 0) {
                // Nothing to lose, just reset
                resetScene();
                showToast('New project created');
                return;
            }
            
            if (confirm('Start a new project? All unsaved changes will be lost.')) {
                resetScene();
                showToast('New project created');
            }
        }
        
        // ==========================================
        // ANIMATION
        // ==========================================
        
        let lastTime = performance.now(), frames = 0;
        function animate() {
            requestAnimationFrame(animate);
            updateCameraMovement();
            
            // Update gizmo scale based on camera distance (only if not dragging)
            if (gizmoGroup && gizmoGroup.visible && !gizmoState.isDragging) {
                const dist = camera.position.distanceTo(gizmoGroup.position);
                const scale = dist * 0.15;
                gizmoGroup.scale.setScalar(Math.max(0.5, Math.min(scale, 2)));
            }
            
            // Update distance label positions in screen space
            if (state.displayOptions.distance) {
                const container = document.querySelector('.viewport');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    
                    document.querySelectorAll('.distance-label').forEach(label => {
                        if (label.midPoint) {
                            const screenPos = label.midPoint.clone().project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * rect.width;
                            const y = (-screenPos.y * 0.5 + 0.5) * rect.height;
                            
                            // Only show if in front of camera
                            if (screenPos.z < 1) {
                                label.style.left = x + 'px';
                                label.style.top = y + 'px';
                                label.style.display = 'block';
                            } else {
                                label.style.display = 'none';
                            }
                        }
                    });
                }
            }
            
            frames++;
            if (performance.now() - lastTime >= 1000) {
                document.getElementById('fps-counter').textContent = frames + ' FPS';
                frames = 0; lastTime = performance.now();
            }
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
