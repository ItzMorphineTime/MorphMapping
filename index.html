<!DOCTYPE html>
<!-- Projection Studio - GitHub Pages Demo (Export disabled - Visit morph-mapping-vercel.vercel.app for full features) -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta author="Joe Loe">
    <title>Projection Studio - Demo</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0c;
            --bg-secondary: #111114;
            --bg-tertiary: #18181c;
            --bg-panel: #141418;
            --border-color: #2a2a32;
            --border-hover: #3a3a44;
            --text-primary: #e8e8ec;
            --text-secondary: #9898a4;
            --text-muted: #5c5c68;
            --accent-primary: #00d4aa;
            --accent-secondary: #00a888;
            --accent-glow: rgba(0, 212, 170, 0.15);
            --warning: #ffaa00;
            --danger: #ff4466;
            --projector-color: #00aaff;
            --surface-color: #8844ff;
        }
        
        body { font-family: 'Outfit', sans-serif; background: var(--bg-primary); color: var(--text-primary); height: 100vh; overflow: hidden; }
        .app-container { display: grid; grid-template-columns: 320px 1fr 360px; grid-template-rows: 56px 1fr 48px; height: 100vh; }
        
        .header { grid-column: 1 / -1; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent-primary), var(--projector-color)); border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .logo-icon svg { width: 18px; height: 18px; fill: var(--bg-primary); }
        .logo-text { font-weight: 600; font-size: 16px; letter-spacing: -0.02em; }
        .logo-text span { color: var(--text-secondary); font-weight: 400; }
        .header-actions { display: flex; gap: 8px; }
        
        .btn { font-family: 'Outfit', sans-serif; padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; align-items: center; gap: 6px; }
        .btn:hover { background: var(--bg-panel); border-color: var(--border-hover); }
        .btn-primary { background: var(--accent-primary); border-color: var(--accent-primary); color: var(--bg-primary); }
        .btn-primary:hover { background: var(--accent-secondary); border-color: var(--accent-secondary); }
        .btn svg { width: 14px; height: 14px; }
        
        .sidebar-left, .sidebar-right { background: var(--bg-secondary); overflow-y: auto; }
        .sidebar-left { border-right: 1px solid var(--border-color); display: flex; flex-direction: column; }
        .sidebar-right { border-left: 1px solid var(--border-color); }
        
        .panel-section { border-bottom: 1px solid var(--border-color); }
        .panel-header { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; }
        .panel-header:hover { background: var(--bg-tertiary); }
        .panel-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-secondary); }
        .panel-content { padding: 0 16px 16px; }
        .panel-badge { background: var(--bg-tertiary); padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 500; color: var(--text-muted); }
        
        .object-list { display: flex; flex-direction: column; gap: 4px; }
        .object-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; cursor: pointer; transition: all 0.15s ease; border: 1px solid transparent; }
        .object-item:hover { background: var(--bg-panel); }
        .object-item.selected { border-color: var(--accent-primary); background: var(--accent-glow); }
        .object-icon { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; }
        .object-icon.projector { background: rgba(0, 170, 255, 0.15); }
        .object-icon.projector svg { fill: var(--projector-color); }
        .object-icon.surface { background: rgba(136, 68, 255, 0.15); }
        .object-icon.surface svg { fill: var(--surface-color); }
        .object-icon svg { width: 14px; height: 14px; }
        .object-info { flex: 1; min-width: 0; }
        .object-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .object-type { font-size: 11px; color: var(--text-muted); }
        .object-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s ease; }
        .object-item:hover .object-actions { opacity: 1; }
        
        .icon-btn { width: 24px; height: 24px; border-radius: 4px; border: none; background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .icon-btn:hover { background: var(--border-color); color: var(--text-primary); }
        .icon-btn.danger:hover { background: rgba(255, 68, 102, 0.2); color: var(--danger); }
        .icon-btn svg { width: 12px; height: 12px; fill: currentColor; }
        
        .add-buttons { display: flex; gap: 8px; padding: 16px; border-top: 1px solid var(--border-color); margin-top: auto; }
        .add-btn { flex: 1; padding: 10px; border-radius: 6px; border: 1px dashed var(--border-color); background: transparent; color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .add-btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); background: var(--accent-glow); }
        .add-btn svg { width: 18px; height: 18px; fill: currentColor; }
        
        .property-group { margin-bottom: 16px; }
        .property-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 10px; }
        .property-row { display: flex; align-items: center; margin-bottom: 8px; }
        .property-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .property-inputs { display: flex; gap: 4px; flex: 1; }
        .input-group { flex: 1; position: relative; }
        .input-group label { position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-size: 10px; font-weight: 600; color: var(--text-muted); pointer-events: none; }
        .input-group input { width: 100%; padding: 8px 8px 8px 22px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .input-group input:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        .single-input { flex: 1; }
        .single-input input, .single-input select { width: 100%; padding: 8px 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 11px; transition: all 0.15s ease; }
        .single-input select { font-family: 'Outfit', sans-serif; cursor: pointer; }
        .single-input input:focus, .single-input select:focus { outline: none; border-color: var(--accent-primary); background: var(--bg-panel); }
        
        .slider-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .slider-label { width: 80px; font-size: 12px; color: var(--text-secondary); flex-shrink: 0; }
        .slider-container { flex: 1; display: flex; align-items: center; gap: 10px; }
        .slider { flex: 1; -webkit-appearance: none; height: 4px; border-radius: 2px; background: var(--border-color); outline: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; }
        .slider-value { width: 50px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-secondary); text-align: right; }
        .slider-input { width: 55px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-primary); background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 3px; }
        .slider-input:focus { outline: none; border-color: var(--accent-color); }
        .slider-input::-webkit-inner-spin-button, .slider-input::-webkit-outer-spin-button { opacity: 0.5; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .toggle-label { font-size: 12px; color: var(--text-secondary); }
        .toggle { width: 36px; height: 20px; border-radius: 10px; background: var(--border-color); cursor: pointer; position: relative; transition: background 0.2s ease; }
        .toggle.active { background: var(--accent-primary); }
        .toggle::after { content: ''; position: absolute; width: 16px; height: 16px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: transform 0.2s ease; }
        .toggle.active::after { transform: translateX(16px); }
        
        .viewport { background: var(--bg-primary); position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; }
        #canvas-container canvas { display: block; }
        
        .viewport-overlay { position: absolute; top: 12px; left: 12px; display: flex; gap: 8px; }
        .view-btn { padding: 6px 12px; border-radius: 4px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); font-family: 'Outfit', sans-serif; font-size: 11px; font-weight: 500; cursor: pointer; transition: all 0.15s ease; }
        .view-btn:hover, .view-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); }
        .view-btn.pilot-btn { margin-left: 8px; border-color: #e67e22; color: #e67e22; }
        .view-btn.pilot-btn.active { background: #e67e22; color: #111114; border-color: #e67e22; }
        .view-btn.pilot-btn:hover { background: rgba(230, 126, 34, 0.2); }
        
        .transform-tools { position: absolute; top: 12px; right: 12px; display: flex; gap: 4px; }
        .tool-btn { width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-color); background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .tool-btn:hover:not(:disabled) { border-color: var(--border-hover); color: var(--text-primary); }
        .tool-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); background: rgba(0, 212, 170, 0.1); }
        .tool-btn svg { width: 18px; height: 18px; fill: currentColor; }
        .tool-btn.disabled, .tool-btn:disabled { opacity: 0.4; pointer-events: none; cursor: not-allowed; }
        .tool-divider { width: 1px; background: var(--border-color); margin: 4px 4px; }
        
        .gizmo-info { position: absolute; top: 60px; right: 12px; background: rgba(17, 17, 20, 0.95); backdrop-filter: blur(12px); padding: 12px 16px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 11px; display: none; min-width: 180px; box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
        .gizmo-info.visible { display: block; animation: gizmoInfoSlide 0.2s ease-out; }
        @keyframes gizmoInfoSlide { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }
        .gizmo-info-title { color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; font-size: 9px; letter-spacing: 0.08em; display: flex; align-items: center; gap: 6px; }
        .gizmo-info-title::before { content: ''; width: 8px; height: 8px; border-radius: 50%; background: var(--accent-primary); animation: gizmoPulse 1.5s ease-in-out infinite; }
        @keyframes gizmoPulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.2); } }
        .gizmo-info-value { font-family: 'JetBrains Mono', monospace; color: var(--text-primary); }
        .gizmo-info-row { display: flex; gap: 16px; margin-top: 6px; }
        .gizmo-info-axis { display: flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 4px; transition: all 0.15s ease; }
        .gizmo-info-axis.x { color: #ff5555; }
        .gizmo-info-axis.y { color: #55ff55; }
        .gizmo-info-axis.z { color: #55aaff; }
        .gizmo-info-axis.active { background: rgba(255,255,255,0.1); transform: scale(1.05); }
        .gizmo-info-axis.active.x { background: rgba(255,85,85,0.2); box-shadow: 0 0 8px rgba(255,85,85,0.3); }
        .gizmo-info-axis.active.y { background: rgba(85,255,85,0.2); box-shadow: 0 0 8px rgba(85,255,85,0.3); }
        .gizmo-info-axis.active.z { background: rgba(85,170,255,0.2); box-shadow: 0 0 8px rgba(85,170,255,0.3); }
        .gizmo-info-delta { font-size: 10px; color: var(--text-muted); margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color); }
        .gizmo-info-delta span { color: var(--accent-primary); font-weight: 600; }
        
        .distance-label { position: absolute; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px); color: #00ff00; padding: 6px 10px; border-radius: 4px; font-size: 11px; font-family: 'JetBrains Mono', monospace; pointer-events: none; white-space: nowrap; border: 1px solid rgba(0, 255, 0, 0.3); z-index: 100; transform: translate(-50%, -50%); }
        .distance-label strong { color: #fff; font-weight: 500; }
        
        .snap-controls { position: absolute; bottom: 60px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); display: flex; align-items: center; gap: 10px; }
        .snap-label { font-size: 10px; color: var(--text-muted); }
        .snap-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .snap-toggle input { display: none; }
        .snap-checkbox { width: 14px; height: 14px; border-radius: 3px; border: 1px solid var(--border-color); background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; }
        .snap-toggle input:checked + .snap-checkbox { background: var(--accent-primary); border-color: var(--accent-primary); }
        .snap-checkbox svg { width: 10px; height: 10px; fill: var(--bg-primary); opacity: 0; }
        .snap-toggle input:checked + .snap-checkbox svg { opacity: 1; }
        .snap-value { width: 50px; padding: 4px 6px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 10px; text-align: center; }
        .snap-value:focus { outline: none; border-color: var(--accent-primary); }
        
        .viewport-info { position: absolute; bottom: 12px; left: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 10px 14px; border-radius: 6px; border: 1px solid var(--border-color); }
        .viewport-info-row { display: flex; gap: 16px; font-size: 11px; }
        .viewport-info-item { display: flex; align-items: center; gap: 6px; }
        .viewport-info-item span:first-child { color: var(--text-muted); }
        .viewport-info-item span:last-child { font-family: 'JetBrains Mono', monospace; color: var(--text-secondary); }
        
        .controls-hint { position: absolute; bottom: 110px; right: 12px; background: rgba(17, 17, 20, 0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 10px; color: var(--text-muted); }
        .controls-hint kbd { background: var(--bg-tertiary); padding: 2px 5px; border-radius: 3px; font-family: 'JetBrains Mono', monospace; margin: 0 2px; }
        
        .pattern-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .pattern-btn { aspect-ratio: 1; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); cursor: pointer; transition: all 0.15s ease; overflow: hidden; }
        .pattern-btn:hover { border-color: var(--border-hover); }
        .pattern-btn.active { border-color: var(--accent-primary); box-shadow: 0 0 0 1px var(--accent-primary); }
        .pattern-preview { width: 100%; height: 100%; }
        .pattern-grid-lines { background: linear-gradient(var(--text-muted) 1px, transparent 1px), linear-gradient(90deg, var(--text-muted) 1px, transparent 1px); background-size: 8px 8px; }
        .pattern-checker { background: repeating-conic-gradient(var(--text-muted) 0% 25%, var(--bg-tertiary) 0% 50%) 50% / 12px 12px; }
        .pattern-gradient { background: linear-gradient(90deg, #000, #fff); }
        .pattern-colorbars { background: linear-gradient(90deg, #fff 0% 14.28%, #ff0 14.28% 28.56%, #0ff 28.56% 42.84%, #0f0 42.84% 57.12%, #f0f 57.12% 71.4%, #f00 71.4% 85.68%, #00f 85.68% 100%); }
        .pattern-cross { background: var(--bg-tertiary); position: relative; }
        .pattern-cross::before, .pattern-cross::after { content: ''; position: absolute; background: var(--text-muted); }
        .pattern-cross::before { width: 1px; height: 100%; left: 50%; }
        .pattern-cross::after { height: 1px; width: 100%; top: 50%; }
        .pattern-white { background: #1a1a1a; background-image: linear-gradient(#444 1px, transparent 1px), linear-gradient(90deg, #444 1px, transparent 1px); background-size: 25% 33.33%; }
        .pattern-none { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--text-muted); }
        .pattern-blend { background: linear-gradient(90deg, rgba(255,0,0,0.5) 0% 20%, transparent 20% 80%, rgba(0,255,0,0.5) 80% 100%); }
        
        .status-bar { grid-column: 1 / -1; background: var(--bg-tertiary); border-top: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; font-size: 11px; }
        .status-left, .status-right { display: flex; align-items: center; gap: 16px; }
        .status-item { display: flex; align-items: center; gap: 6px; color: var(--text-muted); }
        .status-item svg { width: 12px; height: 12px; fill: currentColor; }
        .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent-primary); }
        
        .empty-state { padding: 24px 16px; text-align: center; }
        .empty-state p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        
        .no-selection { padding: 40px 20px; text-align: center; }
        .no-selection-icon { width: 48px; height: 48px; margin: 0 auto 16px; background: var(--bg-tertiary); border-radius: 12px; display: flex; align-items: center; justify-content: center; }
        .no-selection-icon svg { width: 24px; height: 24px; fill: var(--text-muted); }
        .no-selection h3 { font-size: 14px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary); }
        .no-selection p { font-size: 12px; color: var(--text-muted); line-height: 1.5; }
        
        .coverage-display { margin-top: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; border: 1px solid var(--border-color); }
        .coverage-bar { height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; margin-top: 8px; }
        .coverage-fill { height: 100%; background: var(--accent-primary); border-radius: 3px; transition: width 0.3s ease; }
        .coverage-stats { display: flex; justify-content: space-between; font-size: 11px; margin-top: 8px; }
        .coverage-stat { color: var(--text-muted); }
        .coverage-stat span { color: var(--text-secondary); font-family: 'JetBrains Mono', monospace; }
        
        .texture-upload { margin-top: 8px; padding: 16px; border: 2px dashed var(--border-color); border-radius: 6px; text-align: center; cursor: pointer; transition: all 0.15s ease; }
        .texture-upload:hover { border-color: var(--accent-primary); background: var(--accent-glow); }
        .texture-upload input { display: none; }
        .texture-upload p { font-size: 11px; color: var(--text-muted); margin: 0; }
        .texture-preview { width: 100%; height: 80px; border-radius: 4px; background-size: contain; background-repeat: no-repeat; background-position: center; background-color: var(--bg-primary); margin-bottom: 8px; border: 1px solid var(--border-color); }
        
        /* Video controls */
        .video-preview { background: var(--bg-primary); border-radius: 6px; padding: 10px; border: 1px solid var(--border-color); margin-bottom: 8px; }
        .video-info { display: flex; align-items: center; gap: 6px; color: var(--accent-primary); font-size: 11px; margin-bottom: 8px; }
        .video-controls { display: flex; gap: 4px; margin-bottom: 8px; }
        .video-btn { width: 32px; height: 28px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .video-btn:hover { border-color: var(--accent-primary); color: var(--text-primary); }
        .video-btn.active { border-color: var(--accent-primary); color: var(--accent-primary); background: rgba(0, 212, 170, 0.1); }
        .video-seek { margin-bottom: 4px; }
        .video-seek input[type="range"] { width: 100%; height: 4px; -webkit-appearance: none; background: var(--border-color); border-radius: 2px; outline: none; }
        .video-seek input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--accent-primary); cursor: pointer; }
        .video-time { font-size: 10px; color: var(--text-muted); text-align: center; margin-top: 4px; }
        
        /* Pattern scroll controls */
        .scroll-controls { background: var(--bg-primary); border-radius: 6px; padding: 10px; border: 1px solid var(--border-color); margin-top: 8px; }
        .scroll-controls-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .scroll-controls-title { font-size: 11px; color: var(--text-secondary); font-weight: 500; }
        .clear-texture-btn { margin-top: 8px; width: 100%; padding: 6px; font-size: 11px; }
        
        .luminance-legend { 
            margin-top: 12px; 
            padding: 12px; 
            background: var(--bg-primary); 
            border-radius: 6px; 
            border: 1px solid var(--border-color);
        }
        .legend-gradient { 
            height: 20px; 
            border-radius: 4px; 
            background: linear-gradient(90deg, 
                #000033 0%, 
                #0044aa 20%, 
                #00aa44 40%, 
                #aaaa00 60%, 
                #ff6600 80%, 
                #ff0000 95%,
                #ffffff 100%
            ); 
            margin-bottom: 6px;
        }
        .legend-labels { 
            display: flex; 
            justify-content: space-between; 
            font-size: 10px; 
            color: var(--text-secondary); 
            font-family: 'JetBrains Mono', monospace;
        }
        .legend-unit {
            text-align: center;
            font-size: 9px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 480px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.2s ease;
        }
        .modal-overlay.active .modal {
            transform: scale(1);
        }
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .modal-title {
            font-size: 16px;
            font-weight: 600;
        }
        .modal-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .modal-close svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 50vh;
        }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .export-option {
            display: flex;
            align-items: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }
        .export-option:hover {
            background: var(--bg-panel);
            border-color: var(--border-hover);
        }
        .export-option.selected {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
        }
        .export-option-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        .export-option-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--accent-primary);
        }
        .export-option-info h4 {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 2px;
        }
        .export-option-info p {
            font-size: 11px;
            color: var(--text-muted);
            margin: 0;
        }
        .export-checkbox {
            margin-left: auto;
        }
        .checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .checkbox.checked {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        .checkbox svg {
            width: 12px;
            height: 12px;
            fill: var(--bg-primary);
            opacity: 0;
        }
        .checkbox.checked svg {
            opacity: 1;
        }
        .import-preview {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .import-preview h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .import-stat {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        .import-stat:last-child {
            border-bottom: none;
        }
        .import-stat span:first-child {
            color: var(--text-muted);
        }
        .import-stat span:last-child {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        .import-warning {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 6px;
            margin-top: 12px;
        }
        .import-warning svg {
            width: 16px;
            height: 16px;
            fill: var(--warning);
            flex-shrink: 0;
            margin-top: 1px;
        }
        .import-warning p {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 0;
            line-height: 1.4;
        }
        .filename-input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            margin-bottom: 16px;
        }
        .filename-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-primary);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        .toast.success {
            border-color: var(--accent-primary);
        }
        .toast.error {
            border-color: var(--danger);
        }
        .toast svg {
            width: 18px;
            height: 18px;
        }
        .toast.success svg {
            fill: var(--accent-primary);
        }
        .toast.error svg {
            fill: var(--danger);
        }
        
        /* Contact Me Button & Panel */
        .contact-wrapper {
            position: relative;
            display: flex;
        }
        .contact-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(138, 43, 226, 0.1));
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .contact-btn:hover {
            border-color: #ff6b6b;
            color: #ff6b6b;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(138, 43, 226, 0.2));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.2);
        }
        .contact-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        .contact-btn .heart {
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .contact-panel {
            position: absolute;
            top: calc(100% + 12px);
            right: 0;
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.95);
            transform-origin: top right;
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        .contact-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }
        .contact-panel-gradient {
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #a55eea);
            animation: gradientSlide 3s linear infinite;
            background-size: 200% 100%;
        }
        @keyframes gradientSlide {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        .contact-panel-content {
            padding: 20px;
        }
        .contact-panel-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .contact-panel-title svg {
            width: 18px;
            height: 18px;
            fill: #feca57;
        }
        .contact-panel-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }
        .contact-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .contact-link {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-radius: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .contact-link:hover {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
            color: var(--text-primary);
            transform: translateX(4px);
        }
        .contact-link svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        .contact-link.github svg { fill: #f0f0f0; }
        .contact-link.discord svg { fill: #5865F2; }
        .contact-link.github:hover svg { fill: #fff; }
        .contact-link.discord:hover svg { fill: #7289da; }
        .contact-link-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .contact-link-label {
            font-size: 11px;
            color: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                <span class="logo-text">Projection Studio <span>v4.2</span></span>
            </div>
            <div class="header-actions">
                <button class="btn" onclick="confirmNewProject()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>New</button>
                <button class="btn" onclick="document.getElementById('import-file').click()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>Import</button>
                <input type="file" id="import-file" accept=".json,.csv" style="display:none" onchange="importConfig(this.files[0])">
                <button class="btn" onclick="showExportModal()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>Export</button>
                <button class="btn btn-primary" onclick="quickSave()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>Save</button>
                <div class="contact-wrapper">
                    <button class="contact-btn" onclick="toggleContactPanel()">
                        <svg class="heart" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        Support
                    </button>
                    <div class="contact-panel" id="contact-panel">
                        <div class="contact-panel-gradient"></div>
                        <div class="contact-panel-content">
                            <div class="contact-panel-title">
                                <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                                Hey there!
                            </div>
                            <div class="contact-panel-message">
                                Please consider buying me a Coffee if you want to export/import your projects! Your support helps keep this tool free and improving.
                            </div>
                            <div class="contact-links">
                                <a href="https://github.com/ItzMorphineTime/MorphMapping/issues" target="_blank" class="contact-link github">
                                    <svg viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
                                    <div class="contact-link-text">
                                        <span class="contact-link-label">ItzMorphineTime</span>
                                        GitHub
                                    </div>
                                </a>
                                <a href="https://discord.com/users/211604375380951050" target="_blank" class="contact-link discord">
                                    <svg viewBox="0 0 24 24"><path d="M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189z"/></svg>
                                    <div class="contact-link-text">
                                        <span class="contact-link-label">morph_remembers</span>
                                        Discord
                                    </div>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        
        <aside class="sidebar-left">
            <div class="panel-section">
                <div class="panel-header" title="Maximum 8 simultaneous projectors supported"><span class="panel-title">Projectors</span><span class="panel-badge" id="projector-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="projector-list"><div class="empty-state"><p>No projectors added yet.</p></div></div></div>
            </div>
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Surfaces</span><span class="panel-badge" id="surface-count">0</span></div>
                <div class="panel-content"><div class="object-list" id="surface-list"><div class="empty-state"><p>No surfaces added yet.</p></div></div></div>
            </div>
            <div class="add-buttons">
                <button class="add-btn" onclick="addProjector()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Projector</button>
                <button class="add-btn" onclick="addSurface()"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>Surface</button>
                <button class="add-btn" onclick="document.getElementById('obj-import').click()"><svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>OBJ</button>
                <input type="file" id="obj-import" accept=".obj" style="display:none" onchange="importOBJSurface(this.files[0])">
            </div>
        </aside>
        
        <main class="viewport">
            <div id="canvas-container"></div>
            <div class="viewport-overlay">
                <button class="view-btn active" onclick="setView('perspective')">Perspective</button>
                <button class="view-btn" onclick="setView('top')">Top</button>
                <button class="view-btn" onclick="setView('front')">Front</button>
                <button class="view-btn" onclick="setView('side')">Side</button>
                <button class="view-btn" onclick="setView('projector')">Projector POV</button>
                <button class="view-btn pilot-btn" id="pilot-mode-btn" onclick="togglePilotMode()" style="display: none;" title="When enabled, camera movement controls projector position/rotation">ðŸŽ® Pilot</button>
            </div>
            
            <div class="transform-tools">
                <button class="tool-btn disabled" id="tool-select" onclick="setTransformMode('select')" title="Select (V)">
                    <svg viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-6.39 6.39-2.51L3 3zm10.57 10.57l-1.12 2.85-3.03-7.27 7.27 3.03-2.85 1.12l3.88 3.88-1.41 1.41-3.74-3.87z"/></svg>
                </button>
                <button class="tool-btn disabled" id="tool-translate" onclick="setTransformMode('translate')" title="Move (G)">
                    <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
                </button>
                <button class="tool-btn disabled" id="tool-rotate" onclick="setTransformMode('rotate')" title="Rotate (R)">
                    <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                </button>
                <div class="tool-divider"></div>
                <button class="tool-btn" id="undo-btn" onclick="undo()" title="Nothing to undo (Ctrl+Z)" disabled>
                    <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
                </button>
                <button class="tool-btn" id="tool-local" onclick="toggleCoordSpace()" title="World Space (click for Local)">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                </button>
            </div>
            
            <div class="gizmo-info" id="gizmo-info">
                <div class="gizmo-info-title" id="gizmo-info-title">Position</div>
                <div class="gizmo-info-row">
                    <span class="gizmo-info-axis x" id="gizmo-axis-x">X: <span id="gizmo-x">0.00</span></span>
                    <span class="gizmo-info-axis y" id="gizmo-axis-y">Y: <span id="gizmo-y">0.00</span></span>
                    <span class="gizmo-info-axis z" id="gizmo-axis-z">Z: <span id="gizmo-z">0.00</span></span>
                </div>
                <div class="gizmo-info-delta" id="gizmo-delta">Change: <span id="gizmo-delta-value">0.00</span></div>
            </div>
            
            <div class="snap-controls">
                <span class="snap-label">Snap:</span>
                <label class="snap-toggle">
                    <input type="checkbox" id="snap-enabled" onchange="updateSnapSettings()">
                    <div class="snap-checkbox"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg></div>
                </label>
                <input type="number" class="snap-value" id="snap-translate" value="0.5" step="0.1" min="0.1" title="Translation snap" onchange="updateSnapSettings()">
                <span class="snap-label">m</span>
                <input type="number" class="snap-value" id="snap-rotate" value="15" step="5" min="1" title="Rotation snap" onchange="updateSnapSettings()">
                <span class="snap-label">Â°</span>
            </div>
            <div class="viewport-info">
                <div class="viewport-info-row">
                    <div class="viewport-info-item"><span>Camera:</span><span id="camera-info">Perspective</span></div>
                    <div class="viewport-info-item"><span>Units:</span><span>Meters</span></div>
                </div>
            </div>
            <div class="controls-hint">
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;
                <kbd>Q</kbd><kbd>E</kbd> Up/Down &nbsp;
                <kbd>Drag</kbd> Look &nbsp;|&nbsp;
                <kbd>G</kbd> Translate &nbsp;
                <kbd>R</kbd> Rotate &nbsp;
                <kbd>Ctrl+Z</kbd> Undo &nbsp;
                <kbd>Esc</kbd> Deselect &nbsp;
                <kbd>Del</kbd> Delete
            </div>
        </main>
        
        <aside class="sidebar-right">
            <div id="properties-panel">
                <div class="no-selection">
                    <div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div>
                    <h3>No Selection</h3>
                    <p>Select an object to edit.</p>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Test Patterns</span></div>
                <div class="panel-content">
                    <div class="pattern-grid">
                        <button class="pattern-btn active" onclick="setPattern('none')" title="None"><div class="pattern-preview pattern-none">OFF</div></button>
                        <button class="pattern-btn" onclick="setPattern('grid')" title="Grid"><div class="pattern-preview pattern-grid-lines"></div></button>
                        <button class="pattern-btn" onclick="setPattern('checker')" title="Checkerboard"><div class="pattern-preview pattern-checker"></div></button>
                        <button class="pattern-btn" onclick="setPattern('gradient')" title="Gradient"><div class="pattern-preview pattern-gradient"></div></button>
                        <button class="pattern-btn" onclick="setPattern('colorbars')" title="Color Bars"><div class="pattern-preview pattern-colorbars"></div></button>
                        <button class="pattern-btn" onclick="setPattern('cross')" title="Focus Cross"><div class="pattern-preview pattern-cross"></div></button>
                        <button class="pattern-btn" onclick="setPattern('white')" title="Grid ID (16:9)"><div class="pattern-preview pattern-white"></div></button>
                        <button class="pattern-btn" onclick="setPattern('blend')" title="Blend Zones"><div class="pattern-preview pattern-blend"></div></button>
                    </div>
                    <div class="scroll-controls" id="pattern-scroll-controls">
                        <div class="scroll-controls-header">
                            <span class="scroll-controls-title">Pattern Animation</span>
                            <div class="toggle" id="toggle-pattern-scroll" onclick="togglePatternScroll()"></div>
                        </div>
                        <div class="slider-row" style="margin-top: 8px;">
                            <span class="slider-label">Speed</span>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0.1" max="2" step="0.1" value="0.5" id="pattern-scroll-speed" oninput="updatePatternScrollSpeed(+this.value); this.nextElementSibling.value=Number(this.value).toFixed(1)">
                                <input type="number" class="slider-input" step="0.1" min="0.1" max="5" value="0.5" onchange="updatePatternScrollSpeed(+this.value); document.getElementById('pattern-scroll-speed').value=this.value">x
                            </div>
                        </div>
                        <div class="property-row" style="margin-top: 8px;">
                            <span class="property-label">Direction</span>
                            <div class="single-input">
                                <select id="pattern-scroll-direction" onchange="updatePatternScrollDirection(this.value)">
                                    <option value="horizontal">Horizontal â†’</option>
                                    <option value="vertical">Vertical â†‘</option>
                                    <option value="diagonal">Diagonal â†—</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Scene Settings</span></div>
                <div class="panel-content">
                    <div class="slider-row">
                        <span class="slider-label">Ambient Light</span>
                        <div class="slider-container">
                            <input type="range" class="slider" min="0" max="100" step="5" value="10" id="ambient-light-slider" oninput="updateAmbientLight(+this.value); document.getElementById('ambient-light-input').value=this.value">
                            <input type="number" class="slider-input" id="ambient-light-input" step="5" min="0" max="100" value="10" onchange="updateAmbientLight(+this.value); document.getElementById('ambient-light-slider').value=this.value">%
                        </div>
                    </div>
                    <div class="property-row" style="margin-top: 8px;">
                        <span class="property-label">Surface Color</span>
                        <div class="single-input" style="display: flex; gap: 8px; align-items: center;">
                            <input type="color" id="default-surface-color" value="#808080" onchange="updateDefaultSurfaceColor(this.value)" style="width: 40px; height: 24px; padding: 0; border: 1px solid var(--border-color); cursor: pointer;">
                            <button class="btn btn-sm" onclick="applyColorToAllSurfaces()" style="font-size: 10px;">Apply to All</button>
                        </div>
                    </div>
                    <button class="btn btn-sm" onclick="resetSceneSettings()" style="width: 100%; margin-top: 12px; font-size: 10px;">Reset to Defaults</button>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Display Options</span></div>
                <div class="panel-content">
                    <div class="toggle-row"><span class="toggle-label">Show Frustums</span><div class="toggle active" id="toggle-frustums" onclick="toggleOption('frustums')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Grid</span><div class="toggle active" id="toggle-grid" onclick="toggleOption('grid')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Coverage</span><div class="toggle active" id="toggle-coverage" onclick="toggleOption('coverage')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Overlap</span><div class="toggle" id="toggle-overlap" onclick="toggleOption('overlap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Show Distance</span><div class="toggle" id="toggle-distance" onclick="toggleOption('distance')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Luminance Heatmap</span><div class="toggle" id="toggle-heatmap" onclick="toggleOption('heatmap')"></div></div>
                    <div class="toggle-row"><span class="toggle-label">Wireframe</span><div class="toggle" id="toggle-wireframe" onclick="toggleOption('wireframe')"></div></div>
                </div>
            </div>
            
            <div class="panel-section" id="heatmap-panel" style="display: none;">
                <div class="panel-header"><span class="panel-title">Luminance Heatmap</span></div>
                <div class="panel-content">
                    <div class="property-group">
                        <div class="property-group-title">Scale (cd/mÂ²)</div>
                        <div class="slider-row">
                            <span class="slider-label">Max Value</span>
                            <div class="slider-container">
                                <input type="range" class="slider" min="100" max="10000" step="100" value="2000" id="heatmap-max-slider" oninput="updateHeatmapMax(+this.value); document.getElementById('heatmap-max-input').value=this.value">
                                <input type="number" class="slider-input" id="heatmap-max-input" step="100" min="100" max="20000" value="2000" onchange="updateHeatmapMax(+this.value); document.getElementById('heatmap-max-slider').value=this.value">
                            </div>
                        </div>
                    </div>
                    <div class="luminance-legend">
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>0</span>
                            <span id="legend-mid">1000</span>
                            <span id="legend-max">2000+</span>
                        </div>
                        <div class="legend-unit">cd/mÂ² (nits)</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-header"><span class="panel-title">Coverage Analysis</span></div>
                <div class="panel-content">
                    <div class="coverage-display">
                        <div class="property-group-title">Surface Coverage</div>
                        <div class="coverage-bar"><div class="coverage-fill" id="coverage-fill" style="width: 0%"></div></div>
                        <div class="coverage-stats">
                            <div class="coverage-stat">Covered: <span id="coverage-percent">0%</span></div>
                            <div class="coverage-stat">Avg: <span id="avg-cdm2">0</span> cd/mÂ²</div>
                        </div>
                        <div class="coverage-stats" style="margin-top: 4px;">
                            <div class="coverage-stat">Min: <span id="min-cdm2">0</span> cd/mÂ²</div>
                            <div class="coverage-stat">Max: <span id="max-cdm2">0</span> cd/mÂ²</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
        
        <footer class="status-bar">
            <div class="status-left">
                <div class="status-item"><div class="status-dot"></div>Ready</div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg><span id="projector-status">0 Projectors</span></div>
                <div class="status-item"><svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg><span id="surface-status">0 Surfaces</span></div>
            </div>
            <div class="status-center" style="color: var(--text-muted); font-size: 10px;">
                <span>Left-drag: Look â€¢ Right-drag: Pan â€¢ Scroll: Zoom â€¢ WASD/QE: Move</span>
            </div>
            <div class="status-right"><div class="status-item"><span id="fps-counter">60 FPS</span></div></div>
        </footer>
    </div>
    
    <!-- Project Moved Modal -->
    <div class="modal-overlay" id="export-modal">
        <div class="modal" style="max-width: 420px;">
            <div class="modal-header">
                <span class="modal-title">Feature Moved</span>
                <button class="modal-close" onclick="closeModal('export-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body" style="text-align: center; padding: 24px;">
                <div style="width: 64px; height: 64px; background: linear-gradient(135deg, var(--accent-primary), var(--projector-color)); border-radius: 16px; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
                    <svg viewBox="0 0 24 24" fill="var(--bg-primary)" style="width: 32px; height: 32px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
                </div>
                <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">Export &amp; Save for Pro Users</h3>
                <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.6; margin-bottom: 20px;">
                    Export and Save functionality is now available exclusively for registered users on our new hosted platform.
                </p>
                <p style="font-size: 13px; color: var(--text-muted); line-height: 1.5; margin-bottom: 24px;">
                    The latest updates, new features, and full export capabilities have moved to our new home. Sign up for a Pro account to unlock all features!
                </p>
                <a href="https://morph-mapping-vercel.vercel.app/" target="_blank" style="text-decoration: none;">
                    <button class="btn btn-primary" style="width: 100%; padding: 14px 20px; font-size: 14px; justify-content: center;">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 18px; height: 18px; margin-right: 8px;"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                        Go to Projection Studio Pro
                    </button>
                </a>
            </div>
        </div>
    </div>
    
    <!-- Import Modal -->
    <div class="modal-overlay" id="import-modal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Import Project</span>
                <button class="modal-close" onclick="closeModal('import-modal')">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="import-preview">
                    <h4>File Contents</h4>
                    <div class="import-stat">
                        <span>Version</span>
                        <span id="import-version">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Projectors</span>
                        <span id="import-projectors">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Surfaces</span>
                        <span id="import-surfaces">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Custom Textures</span>
                        <span id="import-textures">-</span>
                    </div>
                    <div class="import-stat">
                        <span>Settings</span>
                        <span id="import-settings">-</span>
                    </div>
                </div>
                
                <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 10px;">Import options:</label>
                
                <div class="export-option" onclick="toggleImportOption('replace')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Replace Current Scene</h4>
                        <p>Clear existing objects before importing</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox checked" id="import-check-replace">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="export-option" onclick="toggleImportOption('merge')">
                    <div class="export-option-icon">
                        <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </div>
                    <div class="export-option-info">
                        <h4>Merge with Current</h4>
                        <p>Add imported objects to existing scene</p>
                    </div>
                    <div class="export-checkbox">
                        <div class="checkbox" id="import-check-merge">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
                        </div>
                    </div>
                </div>
                
                <div class="import-warning">
                    <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    <p>This will modify your current scene. Make sure to export your work first if you want to keep it.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('import-modal')">Cancel</button>
                <button class="btn btn-primary" onclick="doImport()">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px;margin-right:4px;"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
                    Import
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
        <span id="toast-message">Success!</span>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // OBJLoader for Three.js r128
    THREE.OBJLoader = function(manager) {
        this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        this.materials = null;
    };
    
    THREE.OBJLoader.prototype = {
        constructor: THREE.OBJLoader,
        
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
                onLoad(scope.parse(text));
            }, onProgress, onError);
        },
        
        setPath: function(value) {
            this.path = value;
            return this;
        },
        
        setMaterials: function(materials) {
            this.materials = materials;
            return this;
        },
        
        parse: function(text) {
            var state = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materialLibraries: [],
                startObject: function(name, fromDeclaration) {
                    if (this.object && this.object.fromDeclaration === false) {
                        this.object.name = name;
                        this.object.fromDeclaration = (fromDeclaration !== false);
                        return;
                    }
                    var previousMaterial = (this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined);
                    if (this.object && typeof this.object._finalize === 'function') {
                        this.object._finalize(true);
                    }
                    this.object = {
                        name: name || '',
                        fromDeclaration: (fromDeclaration !== false),
                        geometry: { vertices: [], normals: [], colors: [], uvs: [] },
                        materials: [],
                        smooth: true,
                        startMaterial: function(name, libraries) {
                            var previous = this._finalize(false);
                            if (previous && (previous.inherited || previous.groupCount <= 0)) {
                                this.materials.splice(previous.index, 1);
                            }
                            var material = { index: this.materials.length, name: name || '', mtllib: (Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : ''), smooth: (previous !== undefined ? previous.smooth : this.smooth), groupStart: (previous !== undefined ? previous.groupEnd : 0), groupEnd: -1, groupCount: -1, inherited: false };
                            this.materials.push(material);
                            return material;
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0) return this.materials[this.materials.length - 1];
                            return undefined;
                        },
                        _finalize: function(end) {
                            var lastMultiMaterial = this.currentMaterial();
                            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                                lastMultiMaterial.inherited = false;
                            }
                            if (end && this.materials.length > 1) {
                                for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                                    if (this.materials[mi].groupCount <= 0) {
                                        this.materials.splice(mi, 1);
                                    }
                                }
                            }
                            if (end && this.materials.length === 0) {
                                this.materials.push({ name: '', smooth: this.smooth });
                            }
                            return lastMultiMaterial;
                        }
                    };
                    if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
                        var declared = previousMaterial.clone(0);
                        declared.inherited = true;
                        this.object.materials.push(declared);
                    }
                    this.objects.push(this.object);
                },
                finalize: function() {
                    if (this.object && typeof this.object._finalize === 'function') {
                        this.object._finalize(true);
                    }
                },
                parseVertexIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseNormalIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 3) * 3;
                },
                parseUVIndex: function(value, len) {
                    var index = parseInt(value, 10);
                    return (index >= 0 ? index - 1 : index + len / 2) * 2;
                },
                addVertex: function(a, b, c) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                    dst.push(src[b + 0], src[b + 1], src[b + 2]);
                    dst.push(src[c + 0], src[c + 1], src[c + 2]);
                },
                addVertexPoint: function(a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                },
                addVertexLine: function(a) {
                    var src = this.vertices;
                    var dst = this.object.geometry.vertices;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                },
                addNormal: function(a, b, c) {
                    var src = this.normals;
                    var dst = this.object.geometry.normals;
                    dst.push(src[a + 0], src[a + 1], src[a + 2]);
                    dst.push(src[b + 0], src[b + 1], src[b + 2]);
                    dst.push(src[c + 0], src[c + 1], src[c + 2]);
                },
                addUV: function(a, b, c) {
                    var src = this.uvs;
                    var dst = this.object.geometry.uvs;
                    dst.push(src[a + 0], src[a + 1]);
                    dst.push(src[b + 0], src[b + 1]);
                    dst.push(src[c + 0], src[c + 1]);
                },
                addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
                    var vLen = this.vertices.length;
                    var ia = this.parseVertexIndex(a, vLen);
                    var ib = this.parseVertexIndex(b, vLen);
                    var ic = this.parseVertexIndex(c, vLen);
                    this.addVertex(ia, ib, ic);
                    if (na !== undefined && na !== '') {
                        var nLen = this.normals.length;
                        ia = this.parseNormalIndex(na, nLen);
                        ib = this.parseNormalIndex(nb, nLen);
                        ic = this.parseNormalIndex(nc, nLen);
                        this.addNormal(ia, ib, ic);
                    }
                    if (ua !== undefined && ua !== '') {
                        var uvLen = this.uvs.length;
                        ia = this.parseUVIndex(ua, uvLen);
                        ib = this.parseUVIndex(ub, uvLen);
                        ic = this.parseUVIndex(uc, uvLen);
                        this.addUV(ia, ib, ic);
                    }
                }
            };
            
            state.startObject('', false);
            var lines = text.split('\n');
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line.length === 0 || line.charAt(0) === '#') continue;
                var lineFirstChar = line.charAt(0);
                var data = line.split(/\s+/);
                var keyword = data[0];
                
                if (lineFirstChar === 'v') {
                    if (keyword === 'v') {
                        state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                    } else if (keyword === 'vn') {
                        state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                    } else if (keyword === 'vt') {
                        state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                    }
                } else if (lineFirstChar === 'f') {
                    var vertices = [];
                    for (var j = 1; j < data.length; j++) {
                        var vertex = data[j].split('/');
                        vertices.push(vertex);
                    }
                    for (var j = 1; j < vertices.length - 1; j++) {
                        var v1 = vertices[0], v2 = vertices[j], v3 = vertices[j + 1];
                        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                } else if (keyword === 'o' || keyword === 'g') {
                    state.startObject(data[1]);
                } else if (keyword === 'usemtl') {
                    state.object.startMaterial(data[1], state.materialLibraries);
                } else if (keyword === 's') {
                    if (data[1] === 'off' || data[1] === '0') {
                        state.object.smooth = false;
                    } else {
                        state.object.smooth = true;
                    }
                    var material = state.object.currentMaterial();
                    if (material) material.smooth = state.object.smooth;
                }
            }
            
            state.finalize();
            
            var container = new THREE.Group();
            for (var i = 0; i < state.objects.length; i++) {
                var object = state.objects[i];
                var geometry = object.geometry;
                if (geometry.vertices.length === 0) continue;
                
                var buffergeometry = new THREE.BufferGeometry();
                buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));
                if (geometry.normals.length > 0) {
                    buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
                } else {
                    buffergeometry.computeVertexNormals();
                }
                if (geometry.uvs.length > 0) {
                    buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
                }
                
                var material = new THREE.MeshBasicMaterial({ color: 0x888888 });
                var mesh = new THREE.Mesh(buffergeometry, material);
                mesh.name = object.name;
                container.add(mesh);
            }
            
            return container;
        }
    };
    </script>
    <script>
        // ==========================================
        // PROJECTION STUDIO v2.3
        // Fixed coverage, frustum zoom, presets, luminance heatmap
        // ==========================================
        
        const state = {
            projectors: [],
            surfaces: [],
            selectedObject: null,
            selectedType: null,
            currentPattern: 'none',
            displayOptions: { frustums: true, grid: true, coverage: true, overlap: false, distance: false, heatmap: false, wireframe: false },
            currentView: 'perspective',
            heatmapMax: 2000, // cd/mÂ² maximum for heatmap scale
            sceneSettings: {
                ambientLight: 10,          // Ambient light intensity (0-100%)
                defaultSurfaceColor: '#808080'  // Default color for new surfaces
            }
        };
        
        // Undo history system
        const undoHistory = [];
        const MAX_UNDO_HISTORY = 50;
        
        function saveStateForUndo(description = 'Change') {
            // Deep clone current projector and surface transforms
            const snapshot = {
                description,
                timestamp: Date.now(),
                projectors: state.projectors.map(p => ({
                    id: p.id,
                    position: { ...p.position },
                    rotation: { ...p.rotation }
                })),
                surfaces: state.surfaces.map(s => ({
                    id: s.id,
                    position: { ...s.position },
                    rotation: { ...s.rotation },
                    dimensions: { ...s.dimensions },
                    scale: s.scale
                }))
            };
            
            undoHistory.push(snapshot);
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        function undo() {
            if (undoHistory.length === 0) {
                showToast('Nothing to undo', 'error');
                return;
            }
            
            const snapshot = undoHistory.pop();
            
            // Restore projector transforms
            snapshot.projectors.forEach(snapProj => {
                const proj = state.projectors.find(p => p.id === snapProj.id);
                if (proj) {
                    proj.position = { ...snapProj.position };
                    proj.rotation = { ...snapProj.rotation };
                    updateProjectorMesh(proj);
                }
            });
            
            // Restore surface transforms
            snapshot.surfaces.forEach(snapSurf => {
                const surf = state.surfaces.find(s => s.id === snapSurf.id);
                if (surf) {
                    surf.position = { ...snapSurf.position };
                    surf.rotation = { ...snapSurf.rotation };
                    surf.dimensions = { ...snapSurf.dimensions };
                    if (snapSurf.scale !== undefined) surf.scale = snapSurf.scale;
                    updateSurfaceMesh(surf);
                }
            });
            
            // Update UI
            updatePropertiesPanel();
            updateGizmoPosition();
            updateUndoButton();
            showToast(`Undid: ${snapshot.description}`);
        }
        
        function updateUndoButton() {
            const btn = document.getElementById('undo-btn');
            if (btn) {
                btn.disabled = undoHistory.length === 0;
                btn.title = undoHistory.length > 0 
                    ? `Undo: ${undoHistory[undoHistory.length - 1].description} (Ctrl+Z)`
                    : 'Nothing to undo (Ctrl+Z)';
            }
        }
        
        // ==========================================
        // LEGACY SECURITY STUBS
        // ==========================================
        // These functions are kept as stubs for compatibility
        // Export functionality has moved to the hosted version
        
        function requestAuthentication(callback) {
            // No longer used - show the "project moved" modal instead
            showExportModal();
        }
        
        function isSessionValid() {
            // Always return false to trigger the "project moved" modal
            return false;
        }
        
        // ==========================================
        // END LEGACY STUBS
        // ==========================================
        
        let scene, camera, renderer, gridHelper, projectorGroup, surfaceGroup, distanceHelperGroup, raycaster, mouse;
        const projectionTextures = new Map();
        const projectorMatrixData = new Map();
        const customTextureData = new Map();
        const videoTextureData = new Map(); // projector ID -> { video, texture, playing, loop, resolution }
        
        // Pattern scroll animation state
        const patternScrollState = {
            enabled: false,
            speed: 0.5,
            direction: 'horizontal', // 'horizontal', 'vertical', 'diagonal'
            offset: { x: 0, y: 0 }
        };
        
        // Shadow map system for occlusion
        const shadowMaps = new Map(); // projector ID -> { renderTarget, camera }
        const SHADOW_MAP_SIZE = 1024;
        let depthMaterial = null;
        
        // Accumulation system for visualization modes (coverage, overlap, heatmap)
        let accumulationTarget = null;  // Render target for hit count + luminance
        let colorTarget = null;         // Render target for color before visualization
        let compositeScene = null;      // Scene with full-screen quad for compositing
        let compositeCamera = null;     // Orthographic camera for compositing
        let compositeMaterial = null;   // Material for composite pass
        let accumulationMaterials = new Map(); // surfaceId -> accumulation material
        
        // Keyboard state for WASD controls
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false };
        
        // Pilot mode - when true, camera movement controls the projector
        let pilotMode = {
            enabled: false,
            projectorId: null
        };
        
        // ==========================================
        // TRANSFORM GIZMO SYSTEM
        // ==========================================
        
        const gizmoState = {
            mode: 'select', // 'select', 'translate', 'rotate'
            activeAxis: null, // 'x', 'y', 'z', 'xy', 'xz', 'yz'
            isDragging: false,
            startPoint: new THREE.Vector3(),
            startValue: null, // World position/rotation at drag start
            startLocalValue: null, // Local position/rotation at drag start
            localSpace: false,
            snap: {
                enabled: false,
                translate: 0.5,
                rotate: 15
            }
        };
        
        let gizmoGroup = null;
        let translateGizmo = null;
        let rotateGizmo = null;
        let dragGuideLine = null;
        let rotationArcLine = null;
        const gizmoRaycaster = new THREE.Raycaster();
        gizmoRaycaster.params.Line.threshold = 0.15;
        
        function createGizmos() {
            gizmoGroup = new THREE.Group();
            gizmoGroup.visible = false;
            gizmoGroup.renderOrder = 999;
            scene.add(gizmoGroup);
            
            createTranslateGizmo();
            createRotateGizmo();
            createDragGuides();
        }
        
        function createDragGuides() {
            // Create drag guide line for translation
            const lineGeom = new THREE.BufferGeometry();
            lineGeom.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            const lineMat = new THREE.LineDashedMaterial({
                color: 0xffff00,
                dashSize: 0.1,
                gapSize: 0.05,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });
            dragGuideLine = new THREE.Line(lineGeom, lineMat);
            dragGuideLine.visible = false;
            dragGuideLine.computeLineDistances();
            dragGuideLine.renderOrder = 998;
            scene.add(dragGuideLine);
            
            // Create rotation arc indicator
            const arcGeom = new THREE.BufferGeometry();
            const arcPoints = [];
            for (let i = 0; i <= 32; i++) {
                arcPoints.push(new THREE.Vector3());
            }
            arcGeom.setFromPoints(arcPoints);
            const arcMat = new THREE.LineBasicMaterial({
                color: 0xffff00,
                depthTest: false,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            rotationArcLine = new THREE.Line(arcGeom, arcMat);
            rotationArcLine.visible = false;
            rotationArcLine.renderOrder = 998;
            scene.add(rotationArcLine);
        }
        
        function updateDragGuide(startPos, endPos, axis) {
            if (!dragGuideLine) return;
            
            const positions = dragGuideLine.geometry.attributes.position;
            positions.setXYZ(0, startPos.x, startPos.y, startPos.z);
            positions.setXYZ(1, endPos.x, endPos.y, endPos.z);
            positions.needsUpdate = true;
            
            // Update color based on axis
            const axisColors = {
                x: 0xff5555, y: 0x55ff55, z: 0x55aaff,
                xy: 0xffff55, xz: 0xff55ff, yz: 0x55ffff
            };
            dragGuideLine.material.color.setHex(axisColors[axis] || 0xffff00);
            
            dragGuideLine.computeLineDistances();
            dragGuideLine.visible = true;
        }
        
        function updateRotationArc(center, axis, startAngle, endAngle, radius) {
            if (!rotationArcLine) return;
            
            const positions = rotationArcLine.geometry.attributes.position;
            const segments = 32;
            const angleRange = endAngle - startAngle;
            
            for (let i = 0; i <= segments; i++) {
                const angle = startAngle + (angleRange * i / segments);
                let x, y, z;
                
                if (axis === 'y') {
                    x = center.x + Math.cos(angle) * radius;
                    y = center.y;
                    z = center.z + Math.sin(angle) * radius;
                } else if (axis === 'x') {
                    x = center.x;
                    y = center.y + Math.cos(angle) * radius;
                    z = center.z + Math.sin(angle) * radius;
                } else { // z
                    x = center.x + Math.cos(angle) * radius;
                    y = center.y + Math.sin(angle) * radius;
                    z = center.z;
                }
                
                positions.setXYZ(i, x, y, z);
            }
            positions.needsUpdate = true;
            
            // Update color based on axis
            const axisColors = { x: 0xff5555, y: 0x55ff55, z: 0x55aaff };
            rotationArcLine.material.color.setHex(axisColors[axis] || 0xffff00);
            rotationArcLine.visible = true;
        }
        
        function hideDragGuides() {
            if (dragGuideLine) dragGuideLine.visible = false;
            if (rotationArcLine) rotationArcLine.visible = false;
        }
        
        function createTranslateGizmo() {
            translateGizmo = new THREE.Group();
            translateGizmo.name = 'translateGizmo';
            
            const axisLength = 1.5;
            const coneHeight = 0.3;
            const coneRadius = 0.1;
            const lineRadius = 0.025;
            
            // More vibrant, distinct colors
            const colors = {
                x: 0xff3333, // Red
                y: 0x33ff33, // Green  
                z: 0x3399ff  // Blue
            };
            
            const hoverColors = {
                x: 0xff6666,
                y: 0x66ff66,
                z: 0x66bbff
            };
            
            // Center sphere for reference
            const centerGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                depthTest: false,
                transparent: true,
                opacity: 0.5
            });
            const centerSphere = new THREE.Mesh(centerGeom, centerMat);
            centerSphere.userData.isCenter = true;
            translateGizmo.add(centerSphere);
            
            // Create axes with cylinder bodies (thicker than lines)
            ['x', 'y', 'z'].forEach(axis => {
                const group = new THREE.Group();
                group.userData.axis = axis;
                group.userData.gizmoType = 'translate';
                
                // Cylinder body (instead of thin line)
                const bodyGeom = new THREE.CylinderGeometry(lineRadius, lineRadius, axisLength - coneHeight * 0.5, 8);
                const bodyMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true,
                    opacity: 0.5
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.userData.axis = axis;
                body.userData.gizmoType = 'translate';
                body.userData.originalColor = colors[axis];
                body.userData.hoverColor = hoverColors[axis];
                body.userData.originalOpacity = 0.5;
                
                // Position body
                const halfLength = (axisLength - coneHeight * 0.5) / 2;
                if (axis === 'x') {
                    body.rotation.z = -Math.PI / 2;
                    body.position.x = halfLength;
                } else if (axis === 'y') {
                    body.position.y = halfLength;
                } else if (axis === 'z') {
                    body.rotation.x = Math.PI / 2;
                    body.position.z = halfLength;
                }
                group.add(body);
                
                // Cone (arrow head) - larger and more visible
                const coneGeom = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
                const coneMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true,
                    opacity: 0.6
                });
                const cone = new THREE.Mesh(coneGeom, coneMat);
                cone.userData.axis = axis;
                cone.userData.gizmoType = 'translate';
                cone.userData.originalColor = colors[axis];
                cone.userData.hoverColor = hoverColors[axis];
                cone.userData.originalOpacity = 0.6;
                
                // Position and rotate cone
                if (axis === 'x') {
                    cone.position.x = axisLength - coneHeight / 2;
                    cone.rotation.z = -Math.PI / 2;
                } else if (axis === 'y') {
                    cone.position.y = axisLength - coneHeight / 2;
                } else if (axis === 'z') {
                    cone.position.z = axisLength - coneHeight / 2;
                    cone.rotation.x = Math.PI / 2;
                }
                group.add(cone);
                
                // Invisible cylinder for easier picking (larger hit area)
                const pickGeom = new THREE.CylinderGeometry(0.12, 0.12, axisLength + 0.2, 8);
                const pickMat = new THREE.MeshBasicMaterial({ visible: false });
                const picker = new THREE.Mesh(pickGeom, pickMat);
                picker.userData.axis = axis;
                picker.userData.gizmoType = 'translate';
                picker.userData.isPicker = true;
                
                if (axis === 'x') {
                    picker.rotation.z = -Math.PI / 2;
                    picker.position.x = axisLength / 2;
                } else if (axis === 'y') {
                    picker.position.y = axisLength / 2;
                } else if (axis === 'z') {
                    picker.rotation.x = Math.PI / 2;
                    picker.position.z = axisLength / 2;
                }
                group.add(picker);
                
                translateGizmo.add(group);
            });
            
            // Plane handles for 2-axis movement (improved with border)
            const planeSize = 0.4;
            const planeOffset = 0.55;
            
            [['xy', 'z'], ['xz', 'y'], ['yz', 'x']].forEach(([plane, normal]) => {
                const planeGroup = new THREE.Group();
                planeGroup.userData.axis = plane;
                planeGroup.userData.gizmoType = 'translate';
                
                // Filled plane
                const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
                const planeColor = plane === 'xy' ? 0x3399ff : plane === 'xz' ? 0x33ff33 : 0xff3333;
                const planeMat = new THREE.MeshBasicMaterial({ 
                    color: planeColor,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    depthTest: false
                });
                const planeMesh = new THREE.Mesh(planeGeom, planeMat);
                planeMesh.userData.axis = plane;
                planeMesh.userData.gizmoType = 'translate';
                planeMesh.userData.originalOpacity = 0.15;
                planeMesh.userData.hoverOpacity = 0.45;
                planeMesh.userData.originalColor = planeColor;
                planeGroup.add(planeMesh);
                
                // Border lines for the plane
                const borderGeom = new THREE.BufferGeometry();
                const s = planeSize / 2;
                borderGeom.setFromPoints([
                    new THREE.Vector3(-s, -s, 0),
                    new THREE.Vector3(s, -s, 0),
                    new THREE.Vector3(s, s, 0),
                    new THREE.Vector3(-s, s, 0),
                    new THREE.Vector3(-s, -s, 0)
                ]);
                const borderMat = new THREE.LineBasicMaterial({
                    color: planeColor,
                    depthTest: false,
                    transparent: true,
                    opacity: 0.3
                });
                const border = new THREE.Line(borderGeom, borderMat);
                border.userData.axis = plane;
                border.userData.gizmoType = 'translate';
                border.userData.originalOpacity = 0.3;
                border.userData.originalColor = planeColor;
                planeGroup.add(border);
                
                if (plane === 'xy') {
                    planeGroup.position.set(planeOffset, planeOffset, 0);
                } else if (plane === 'xz') {
                    planeGroup.position.set(planeOffset, 0, planeOffset);
                    planeGroup.rotation.x = Math.PI / 2;
                } else if (plane === 'yz') {
                    planeGroup.position.set(0, planeOffset, planeOffset);
                    planeGroup.rotation.y = Math.PI / 2;
                }
                
                translateGizmo.add(planeGroup);
            });
            
            // Add axis text labels
            const labelOffset = axisLength + 0.35;
            const labelColors = { x: '#ff5555', y: '#55ff55', z: '#55aaff' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const label = createAxisLabel(axis.toUpperCase(), labelColors[axis]);
                label.userData.axis = axis;
                label.userData.gizmoType = 'translate';
                label.userData.isLabel = true;
                
                if (axis === 'x') label.position.set(labelOffset, 0, 0);
                else if (axis === 'y') label.position.set(0, labelOffset, 0);
                else label.position.set(0, 0, labelOffset);
                
                translateGizmo.add(label);
            });
            
            gizmoGroup.add(translateGizmo);
        }
        
        // Helper function to create axis text label sprites
        function createAxisLabel(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Draw circle background
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(17, 17, 20, 0.85)';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw text
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = color;
            ctx.fillText(text, 32, 34);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({
                map: texture,
                depthTest: false,
                transparent: true,
                opacity: 0.5
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.35, 0.35, 1);
            sprite.renderOrder = 1000;
            sprite.userData.originalOpacity = 0.5;
            
            return sprite;
        }
        
        function createRotateGizmo() {
            rotateGizmo = new THREE.Group();
            rotateGizmo.name = 'rotateGizmo';
            rotateGizmo.visible = false;
            
            const ringRadius = 1.3;
            const tubeRadius = 0.035;
            const segments = 64;
            
            // More vibrant colors matching translate gizmo
            const colors = {
                x: 0xff3333,
                y: 0x33ff33,
                z: 0x3399ff
            };
            
            const hoverColors = {
                x: 0xff6666,
                y: 0x66ff66,
                z: 0x66bbff
            };
            
            // Center sphere for reference
            const centerGeom = new THREE.SphereGeometry(0.06, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                depthTest: false,
                transparent: true,
                opacity: 0.4
            });
            const centerSphere = new THREE.Mesh(centerGeom, centerMat);
            centerSphere.userData.isCenter = true;
            rotateGizmo.add(centerSphere);
            
            ['x', 'y', 'z'].forEach(axis => {
                const axisGroup = new THREE.Group();
                axisGroup.userData.axis = axis;
                axisGroup.userData.gizmoType = 'rotate';
                
                // Main torus ring - thicker tube for better visibility
                const torusGeom = new THREE.TorusGeometry(ringRadius, tubeRadius, 12, segments);
                const torusMat = new THREE.MeshBasicMaterial({ 
                    color: colors[axis],
                    depthTest: false,
                    transparent: true,
                    opacity: 0.5
                });
                const torus = new THREE.Mesh(torusGeom, torusMat);
                torus.userData.axis = axis;
                torus.userData.gizmoType = 'rotate';
                torus.userData.originalColor = colors[axis];
                torus.userData.hoverColor = hoverColors[axis];
                torus.userData.originalOpacity = 0.5;
                
                // Add small spheres at cardinal points for visual reference
                const markerRadius = 0.06;
                const markerPositions = [0, Math.PI/2, Math.PI, Math.PI * 1.5];
                markerPositions.forEach(angle => {
                    const markerGeom = new THREE.SphereGeometry(markerRadius, 8, 8);
                    const markerMat = new THREE.MeshBasicMaterial({
                        color: colors[axis],
                        depthTest: false,
                        transparent: true,
                        opacity: 0.5
                    });
                    const marker = new THREE.Mesh(markerGeom, markerMat);
                    marker.position.x = Math.cos(angle) * ringRadius;
                    marker.position.y = Math.sin(angle) * ringRadius;
                    marker.userData.axis = axis;
                    marker.userData.gizmoType = 'rotate';
                    marker.userData.originalColor = colors[axis];
                    marker.userData.hoverColor = hoverColors[axis];
                    marker.userData.originalOpacity = 0.5;
                    torus.add(marker);
                });
                
                axisGroup.add(torus);
                
                // Invisible torus for easier picking (wider hit area)
                const pickGeom = new THREE.TorusGeometry(ringRadius, 0.1, 8, segments);
                const pickMat = new THREE.MeshBasicMaterial({ visible: false });
                const picker = new THREE.Mesh(pickGeom, pickMat);
                picker.userData.axis = axis;
                picker.userData.gizmoType = 'rotate';
                picker.userData.isPicker = true;
                axisGroup.add(picker);
                
                // Rotate the group to align with the correct axis
                if (axis === 'x') {
                    axisGroup.rotation.y = Math.PI / 2;
                } else if (axis === 'y') {
                    axisGroup.rotation.x = Math.PI / 2;
                }
                // z axis is default orientation
                
                rotateGizmo.add(axisGroup);
            });
            
            // Add axis text labels for rotate gizmo
            const labelOffset = ringRadius + 0.35;
            const labelColors = { x: '#ff5555', y: '#55ff55', z: '#55aaff' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const label = createAxisLabel(axis.toUpperCase(), labelColors[axis]);
                label.userData.axis = axis;
                label.userData.gizmoType = 'rotate';
                label.userData.isLabel = true;
                
                if (axis === 'x') label.position.set(labelOffset, 0, 0);
                else if (axis === 'y') label.position.set(0, labelOffset, 0);
                else label.position.set(0, 0, labelOffset);
                
                rotateGizmo.add(label);
            });
            
            gizmoGroup.add(rotateGizmo);
        }
        
        function updateGizmoPosition() {
            if (!gizmoGroup || !state.selectedObject) {
                if (gizmoGroup) gizmoGroup.visible = false;
                return;
            }
            
            let targetObject = null;
            let objectData = null;
            
            if (state.selectedType === 'projector') {
                targetObject = projectorGroup.children.find(c => c.userData.projectorId === state.selectedObject);
                objectData = state.projectors.find(p => p.id === state.selectedObject);
            } else if (state.selectedType === 'surface') {
                targetObject = surfaceGroup.children.find(c => c.userData.surfaceId === state.selectedObject);
                objectData = state.surfaces.find(s => s.id === state.selectedObject);
            }
            
            if (!targetObject || !objectData) {
                gizmoGroup.visible = false;
                return;
            }
            
            gizmoGroup.visible = gizmoState.mode !== 'select';
            gizmoGroup.position.copy(targetObject.position);
            
            // Apply rotation in local space mode
            if (gizmoState.localSpace) {
                gizmoGroup.rotation.copy(targetObject.rotation);
            } else {
                gizmoGroup.rotation.set(0, 0, 0);
            }
            
            // Scale gizmo based on camera distance
            const dist = camera.position.distanceTo(gizmoGroup.position);
            const scale = dist * 0.15;
            gizmoGroup.scale.setScalar(Math.max(0.5, Math.min(scale, 2)));
            
            // Show appropriate gizmo
            translateGizmo.visible = gizmoState.mode === 'translate';
            rotateGizmo.visible = gizmoState.mode === 'rotate';
        }
        
        function setTransformMode(mode) {
            gizmoState.mode = mode;
            
            // Update transform mode buttons only (not undo or local space)
            const transformBtns = ['tool-select', 'tool-translate', 'tool-rotate'];
            transformBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('active');
                    btn.classList.toggle('disabled', !state.selectedObject);
                }
            });
            
            // Also update local space button disabled state
            const localBtn = document.getElementById('tool-local');
            if (localBtn) {
                localBtn.classList.toggle('disabled', !state.selectedObject);
            }
            
            const activeBtn = document.getElementById(`tool-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            updateGizmoPosition();
        }
        
        function toggleCoordSpace() {
            gizmoState.localSpace = !gizmoState.localSpace;
            const btn = document.getElementById('tool-local');
            btn.classList.toggle('active', gizmoState.localSpace);
            btn.title = gizmoState.localSpace ? 'Local Space (click for World)' : 'World Space (click for Local)';
            updateGizmoPosition();
        }
        
        function updateSnapSettings() {
            gizmoState.snap.enabled = document.getElementById('snap-enabled').checked;
            gizmoState.snap.translate = parseFloat(document.getElementById('snap-translate').value) || 0.5;
            gizmoState.snap.rotate = parseFloat(document.getElementById('snap-rotate').value) || 15;
        }
        
        function enableTransformTools(enabled) {
            const tools = ['tool-select', 'tool-translate', 'tool-rotate', 'tool-local'];
            tools.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.toggle('disabled', !enabled);
                }
            });
            // Undo button uses disabled attribute, not class - don't disable it based on selection
            // It should only be disabled when there's nothing to undo
            updateUndoButton();
        }
        
        function handleGizmoInteraction(event, phase) {
            if (!gizmoGroup || !gizmoGroup.visible || gizmoState.mode === 'select') return false;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            gizmoRaycaster.setFromCamera(mouse, camera);
            
            if (phase === 'down') {
                // Only allow grabbing if we're already hovering over an axis
                // This ensures you can only grab handles you can visually see highlighted
                if (!hoveredAxis) {
                    return false;
                }
                
                const gizmoObjects = [];
                const currentGizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
                currentGizmo.traverse(child => {
                    if (child.isMesh && (child.userData.gizmoType === gizmoState.mode || child.userData.isPicker)) {
                        gizmoObjects.push(child);
                    }
                });
                
                const intersects = gizmoRaycaster.intersectObjects(gizmoObjects);
                
                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    
                    // Only grab if the hit axis matches what we're hovering over
                    if (hit.userData.axis !== hoveredAxis) {
                        return false;
                    }
                    
                    // Clear hover state before starting drag
                    highlightAxis(hoveredAxis, false);
                    hideAxisLabel();
                    
                    gizmoState.activeAxis = hit.userData.axis;
                    gizmoState.isDragging = true;
                    gizmoState.startPoint.copy(intersects[0].point);
                    hoveredAxis = null;
                    
                    // Save state for undo before making changes
                    const actionType = gizmoState.mode === 'translate' ? 'Move' : 'Rotate';
                    const objectName = state.selectedType === 'projector' 
                        ? state.projectors.find(x => x.id === state.selectedObject)?.name 
                        : state.surfaces.find(x => x.id === state.selectedObject)?.name;
                    saveStateForUndo(`${actionType} ${objectName || 'object'}`);
                    
                    // Store starting value - use WORLD position/rotation for dragging
                    if (state.selectedType === 'projector') {
                        const p = state.projectors.find(x => x.id === state.selectedObject);
                        const worldTransform = getWorldTransform(p);
                        gizmoState.startValue = gizmoState.mode === 'translate' 
                            ? { ...worldTransform.position } 
                            : { ...worldTransform.rotation };
                        gizmoState.startLocalValue = gizmoState.mode === 'translate'
                            ? { ...p.position }
                            : { ...p.rotation };
                    } else if (state.selectedType === 'surface') {
                        const s = state.surfaces.find(x => x.id === state.selectedObject);
                        const worldTransform = getWorldTransform(s);
                        gizmoState.startValue = gizmoState.mode === 'translate' 
                            ? { ...worldTransform.position } 
                            : { ...worldTransform.rotation };
                        gizmoState.startLocalValue = gizmoState.mode === 'translate'
                            ? { ...s.position }
                            : { ...s.rotation };
                    }
                    
                    // Highlight active axis (not hover, but drag state)
                    highlightAxis(gizmoState.activeAxis, true, false);
                    renderer.domElement.style.cursor = 'grabbing';
                    showGizmoInfo(true);
                    
                    return true;
                }
            } else if (phase === 'move' && gizmoState.isDragging) {
                updateGizmoDrag(event);
                return true;
            } else if (phase === 'up') {
                if (gizmoState.isDragging) {
                    gizmoState.isDragging = false;
                    highlightAxis(gizmoState.activeAxis, false);
                    gizmoState.activeAxis = null;
                    gizmoState.startAngle = null; // Clear rotation start angle
                    renderer.domElement.style.cursor = 'default';
                    showGizmoInfo(false);
                    hideAxisLabel();
                    hideDragGuides();
                    calculateCoverage();
                    return true;
                }
            }
            
            return false;
        }
        
        function updateGizmoDrag(event) {
            if (!gizmoState.isDragging || !gizmoState.activeAxis) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            // Get object being transformed
            let obj, data;
            if (state.selectedType === 'projector') {
                obj = projectorGroup.children.find(c => c.userData.projectorId === state.selectedObject);
                data = state.projectors.find(p => p.id === state.selectedObject);
            } else {
                obj = surfaceGroup.children.find(c => c.userData.surfaceId === state.selectedObject);
                data = state.surfaces.find(s => s.id === state.selectedObject);
            }
            
            if (!obj || !data) return;
            
            if (gizmoState.mode === 'translate') {
                updateTranslation(mouse, obj, data);
            } else if (gizmoState.mode === 'rotate') {
                updateRotation(event, mouse, obj, data);
            }
            
            // Update gizmo position
            updateGizmoPosition();
            
            // Update info display
            updateGizmoInfo(data);
            
            // Update properties panel in real-time
            updatePropertiesPanel();
        }
        
        function updateTranslation(mouse, obj, data) {
            const axis = gizmoState.activeAxis;
            
            // Get the object's world matrix for local space transformations
            const objectQuaternion = obj.quaternion.clone();
            
            // Define axis directions (will be transformed if in local space)
            let axisX = new THREE.Vector3(1, 0, 0);
            let axisY = new THREE.Vector3(0, 1, 0);
            let axisZ = new THREE.Vector3(0, 0, 1);
            
            if (gizmoState.localSpace) {
                axisX.applyQuaternion(objectQuaternion);
                axisY.applyQuaternion(objectQuaternion);
                axisZ.applyQuaternion(objectQuaternion);
            }
            
            // Create a plane for intersection based on camera view and axis
            const planeNormal = new THREE.Vector3();
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            // Get the primary axis direction for this drag
            let primaryAxis;
            if (axis === 'x') primaryAxis = axisX;
            else if (axis === 'y') primaryAxis = axisY;
            else if (axis === 'z') primaryAxis = axisZ;
            
            if (axis === 'x' || axis === 'y' || axis === 'z') {
                // For single-axis movement, create a plane that contains the axis
                // Choose the plane normal to be perpendicular to both the axis and camera direction
                planeNormal.crossVectors(primaryAxis, cameraDir);
                if (planeNormal.lengthSq() < 0.001) {
                    // Axis is parallel to camera, use alternative
                    planeNormal.crossVectors(primaryAxis, camera.up);
                }
                planeNormal.crossVectors(planeNormal, primaryAxis).normalize();
            } else if (axis === 'xy') {
                planeNormal.copy(axisZ);
            } else if (axis === 'xz') {
                planeNormal.copy(axisY);
            } else if (axis === 'yz') {
                planeNormal.copy(axisX);
            }
            
            const plane = new THREE.Plane();
            plane.setFromNormalAndCoplanarPoint(planeNormal, gizmoGroup.position);
            
            const ray = new THREE.Ray();
            gizmoRaycaster.setFromCamera(mouse, camera);
            ray.copy(gizmoRaycaster.ray);
            
            const intersection = new THREE.Vector3();
            ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                let delta = intersection.clone().sub(gizmoState.startPoint);
                
                // Project delta onto the allowed axes
                if (axis === 'x') {
                    const proj = delta.dot(axisX);
                    delta.copy(axisX).multiplyScalar(proj);
                } else if (axis === 'y') {
                    const proj = delta.dot(axisY);
                    delta.copy(axisY).multiplyScalar(proj);
                } else if (axis === 'z') {
                    const proj = delta.dot(axisZ);
                    delta.copy(axisZ).multiplyScalar(proj);
                } else if (axis === 'xy') {
                    // Remove Z component in local space
                    const projZ = delta.dot(axisZ);
                    delta.sub(axisZ.clone().multiplyScalar(projZ));
                } else if (axis === 'xz') {
                    // Remove Y component in local space
                    const projY = delta.dot(axisY);
                    delta.sub(axisY.clone().multiplyScalar(projY));
                } else if (axis === 'yz') {
                    // Remove X component in local space
                    const projX = delta.dot(axisX);
                    delta.sub(axisX.clone().multiplyScalar(projX));
                }
                
                // Apply to position (delta is now in world space)
                // startValue is WORLD position, so newX/Y/Z are WORLD coordinates
                let newWorldX = gizmoState.startValue.x + delta.x;
                let newWorldY = gizmoState.startValue.y + delta.y;
                let newWorldZ = gizmoState.startValue.z + delta.z;
                
                // Snap in world space
                if (gizmoState.snap.enabled) {
                    const snap = gizmoState.snap.translate;
                    newWorldX = Math.round(newWorldX / snap) * snap;
                    newWorldY = Math.round(newWorldY / snap) * snap;
                    newWorldZ = Math.round(newWorldZ / snap) * snap;
                }
                
                // Convert world position to local position for storage
                const newWorldPos = { x: newWorldX, y: newWorldY, z: newWorldZ };
                let newLocalPos;
                
                if (data.parentId) {
                    // Has parent - convert world to local
                    const parent = getObjectById(data.parentId);
                    if (parent) {
                        const parentWorld = getWorldTransform(parent.obj);
                        // Use the same rotation as current (only position changed)
                        const currentWorldTransform = getWorldTransform(data);
                        const worldTransformForConversion = {
                            position: newWorldPos,
                            rotation: currentWorldTransform.rotation
                        };
                        newLocalPos = worldToLocalTransform(worldTransformForConversion, parentWorld).position;
                    } else {
                        newLocalPos = newWorldPos;
                    }
                } else {
                    // No parent - local = world
                    newLocalPos = newWorldPos;
                }
                
                // Update stored LOCAL position
                data.position.x = newLocalPos.x;
                data.position.y = newLocalPos.y;
                data.position.z = newLocalPos.z;
                
                // Set mesh to WORLD position
                obj.position.set(newWorldX, newWorldY, newWorldZ);
                
                // Update drag guide line (in world space)
                const startPos = new THREE.Vector3(gizmoState.startValue.x, gizmoState.startValue.y, gizmoState.startValue.z);
                const endPos = new THREE.Vector3(newWorldX, newWorldY, newWorldZ);
                updateDragGuide(startPos, endPos, axis);
                
                // Update projector/surface and all children
                if (state.selectedType === 'projector') {
                    updateProjectorMatrix(data);
                    updateProjectorMeshWithArray(data);
                }
                
                // Update all children recursively (lightweight version for drag)
                updateChildrenWorldPositions(data.id);
                
                updateAllSurfaceMaterials();
            }
        }
        
        // Lightweight function to update child positions during drag without full mesh recreation
        function updateChildrenWorldPositions(parentId) {
            const children = getChildren(parentId);
            children.forEach(child => {
                const worldTransform = getWorldTransform(child.obj);
                
                if (child.type === 'projector') {
                    // Update projector mesh position
                    const mesh = projectorGroup.children.find(c => c.userData.projectorId === child.obj.id && !c.userData.isArrayInstance);
                    if (mesh) {
                        mesh.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
                        mesh.rotation.order = 'YXZ';
                        mesh.rotation.set(
                            THREE.MathUtils.degToRad(worldTransform.rotation.x),
                            THREE.MathUtils.degToRad(worldTransform.rotation.y),
                            THREE.MathUtils.degToRad(worldTransform.rotation.z)
                        );
                    }
                    // Update array instances
                    updateProjectorMeshWithArray(child.obj);
                    // Update projection matrix
                    updateProjectorMatrix(child.obj);
                } else if (child.type === 'surface') {
                    // Update surface mesh position
                    const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === child.obj.id);
                    if (mesh) {
                        mesh.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
                        mesh.rotation.order = 'YXZ';
                        mesh.rotation.set(
                            THREE.MathUtils.degToRad(worldTransform.rotation.x),
                            THREE.MathUtils.degToRad(worldTransform.rotation.y),
                            THREE.MathUtils.degToRad(worldTransform.rotation.z)
                        );
                    }
                }
                
                // Recursively update this child's children
                updateChildrenWorldPositions(child.obj.id);
            });
        }
        
        function updateRotation(event, mouse, obj, data) {
            const axis = gizmoState.activeAxis;
            
            // Calculate rotation based on mouse movement around the gizmo center
            const gizmoScreenPos = gizmoGroup.position.clone().project(camera);
            const centerX = (gizmoScreenPos.x + 1) / 2 * renderer.domElement.clientWidth;
            const centerY = (-gizmoScreenPos.y + 1) / 2 * renderer.domElement.clientHeight;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const currentAngle = Math.atan2(
                event.clientY - rect.top - centerY,
                event.clientX - rect.left - centerX
            );
            
            // Store initial angle on first move
            if (!gizmoState.startAngle) {
                gizmoState.startAngle = currentAngle;
            }
            
            let deltaAngle = (currentAngle - gizmoState.startAngle) * (180 / Math.PI);
            
            // Get the actual axis direction (local or world)
            let axisDir = new THREE.Vector3();
            if (axis === 'x') axisDir.set(1, 0, 0);
            else if (axis === 'y') axisDir.set(0, 1, 0);
            else if (axis === 'z') axisDir.set(0, 0, 1);
            
            // Transform axis to world space for camera comparison (in local mode)
            let worldAxisDir = axisDir.clone();
            if (gizmoState.localSpace) {
                worldAxisDir.applyQuaternion(obj.quaternion);
            }
            
            // Invert based on camera orientation for intuitive rotation
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const dotProduct = camDir.dot(worldAxisDir);
            if (dotProduct < 0) deltaAngle = -deltaAngle;
            
            // Snap
            if (gizmoState.snap.enabled) {
                const snap = gizmoState.snap.rotate;
                deltaAngle = Math.round(deltaAngle / snap) * snap;
            }
            
            const deltaRad = THREE.MathUtils.degToRad(deltaAngle);
            
            // Create start quaternion from initial WORLD rotation values
            const startQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(
                THREE.MathUtils.degToRad(gizmoState.startValue.x),
                THREE.MathUtils.degToRad(gizmoState.startValue.y),
                THREE.MathUtils.degToRad(gizmoState.startValue.z),
                'YXZ'
            ));
            
            let resultQuat;
            
            if (gizmoState.localSpace) {
                // Local space: post-multiply (result = startQuat * deltaQuat)
                // This applies rotation in the object's local coordinate system
                const deltaQuat = new THREE.Quaternion().setFromAxisAngle(axisDir, deltaRad);
                resultQuat = startQuat.clone().multiply(deltaQuat);
            } else {
                // World space: pre-multiply (result = deltaQuat * startQuat)
                // This applies rotation in the world coordinate system
                const deltaQuat = new THREE.Quaternion().setFromAxisAngle(axisDir, deltaRad);
                resultQuat = deltaQuat.clone().multiply(startQuat);
            }
            
            // Convert back to Euler angles - this is the new WORLD rotation
            const resultEuler = new THREE.Euler().setFromQuaternion(resultQuat, 'YXZ');
            const newWorldRotation = {
                x: THREE.MathUtils.radToDeg(resultEuler.x),
                y: THREE.MathUtils.radToDeg(resultEuler.y),
                z: THREE.MathUtils.radToDeg(resultEuler.z)
            };
            
            // Convert world rotation to local rotation for storage
            let newLocalRotation;
            if (data.parentId) {
                const parent = getObjectById(data.parentId);
                if (parent) {
                    const parentWorld = getWorldTransform(parent.obj);
                    const parentEuler = new THREE.Euler(
                        THREE.MathUtils.degToRad(parentWorld.rotation.x),
                        THREE.MathUtils.degToRad(parentWorld.rotation.y),
                        THREE.MathUtils.degToRad(parentWorld.rotation.z),
                        'YXZ'
                    );
                    const parentQuat = new THREE.Quaternion().setFromEuler(parentEuler);
                    const parentQuatInverse = parentQuat.clone().invert();
                    const localQuat = parentQuatInverse.clone().multiply(resultQuat);
                    const localEuler = new THREE.Euler().setFromQuaternion(localQuat, 'YXZ');
                    newLocalRotation = {
                        x: THREE.MathUtils.radToDeg(localEuler.x),
                        y: THREE.MathUtils.radToDeg(localEuler.y),
                        z: THREE.MathUtils.radToDeg(localEuler.z)
                    };
                } else {
                    newLocalRotation = newWorldRotation;
                }
            } else {
                newLocalRotation = newWorldRotation;
            }
            
            // Store LOCAL rotation
            data.rotation.x = newLocalRotation.x;
            data.rotation.y = newLocalRotation.y;
            data.rotation.z = newLocalRotation.z;
            
            // Set mesh to WORLD rotation
            obj.rotation.order = 'YXZ';
            obj.rotation.set(
                THREE.MathUtils.degToRad(newWorldRotation.x),
                THREE.MathUtils.degToRad(newWorldRotation.y),
                THREE.MathUtils.degToRad(newWorldRotation.z)
            );
            
            // Update projector/surface
            if (state.selectedType === 'projector') {
                updateProjectorMatrix(data);
                updateProjectorMeshWithArray(data);
            }
            
            // Update all children recursively
            updateChildrenWorldPositions(data.id);
            
            updateAllSurfaceMaterials();
        }
        
        function highlightAxis(axis, highlight, isHover = false) {
            const gizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
            const highlightColor = 0xffff00; // Yellow for active drag
            
            gizmo.traverse(child => {
                if (child.userData.axis === axis && !child.userData.isPicker && !child.userData.isCenter) {
                    // Handle labels (sprites) - only change opacity, no scale
                    if (child.userData.isLabel && child.material) {
                        child.material.opacity = highlight ? 1.0 : (child.userData.originalOpacity || 0.5);
                        return;
                    }
                    
                    if (highlight) {
                        // Store original values if not already stored
                        if (child.userData.originalColor === undefined && child.material) {
                            child.userData.originalColor = child.material.color.getHex();
                        }
                        if (child.userData.originalOpacity === undefined && child.material && child.material.opacity !== undefined) {
                            child.userData.originalOpacity = child.material.opacity;
                        }
                        
                        // Apply highlight - brightness only, no scale
                        if (child.material) {
                            if (isHover && child.userData.hoverColor) {
                                // Hover: use brighter version of axis color
                                child.material.color.setHex(child.userData.hoverColor);
                            } else {
                                // Active drag: yellow highlight
                                child.material.color.setHex(highlightColor);
                            }
                            
                            // Use hoverOpacity if defined (for planes), otherwise full opacity
                            if (isHover && child.userData.hoverOpacity !== undefined) {
                                child.material.opacity = child.userData.hoverOpacity;
                            } else {
                                child.material.opacity = 1.0;
                            }
                        }
                    } else {
                        // Restore original values
                        if (child.material && child.userData.originalColor !== undefined) {
                            child.material.color.setHex(child.userData.originalColor);
                        }
                        if (child.material && child.userData.originalOpacity !== undefined) {
                            child.material.opacity = child.userData.originalOpacity;
                        }
                    }
                }
            });
            
            // Update cursor
            if (highlight) {
                renderer.domElement.style.cursor = 'grab';
            }
        }
        
        // Track currently hovered axis for hover effects
        let hoveredAxis = null;
        
        function updateGizmoHover(mouse) {
            if (!gizmoGroup || !gizmoGroup.visible || gizmoState.isDragging) return;
            
            gizmoRaycaster.setFromCamera(mouse, camera);
            
            const gizmoObjects = [];
            const currentGizmo = gizmoState.mode === 'translate' ? translateGizmo : rotateGizmo;
            currentGizmo.traverse(child => {
                if (child.isMesh && (child.userData.gizmoType === gizmoState.mode || child.userData.isPicker)) {
                    gizmoObjects.push(child);
                }
            });
            
            const intersects = gizmoRaycaster.intersectObjects(gizmoObjects);
            
            let newHoveredAxis = null;
            if (intersects.length > 0) {
                newHoveredAxis = intersects[0].object.userData.axis;
            }
            
            // Update hover state if changed
            if (newHoveredAxis !== hoveredAxis) {
                // Remove old hover
                if (hoveredAxis) {
                    highlightAxis(hoveredAxis, false);
                }
                
                // Apply new hover
                if (newHoveredAxis) {
                    highlightAxis(newHoveredAxis, true, true);
                    renderer.domElement.style.cursor = 'grab';
                    showAxisLabel(newHoveredAxis);
                } else {
                    renderer.domElement.style.cursor = 'default';
                    hideAxisLabel();
                }
                
                hoveredAxis = newHoveredAxis;
            }
        }
        
        function showAxisLabel(axis) {
            let label = document.getElementById('gizmo-axis-label');
            if (!label) {
                label = document.createElement('div');
                label.id = 'gizmo-axis-label';
                label.style.cssText = `
                    position: absolute;
                    padding: 4px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: 600;
                    pointer-events: none;
                    z-index: 1000;
                    transition: opacity 0.15s ease;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                `;
                document.querySelector('.viewport').appendChild(label);
            }
            
            // Set label text and color based on axis
            const axisNames = {
                'x': 'X Axis',
                'y': 'Y Axis', 
                'z': 'Z Axis',
                'xy': 'XY Plane',
                'xz': 'XZ Plane',
                'yz': 'YZ Plane'
            };
            
            const axisColors = {
                'x': { bg: '#ff3333', text: '#fff' },
                'y': { bg: '#33ff33', text: '#000' },
                'z': { bg: '#3399ff', text: '#fff' },
                'xy': { bg: '#3399ff', text: '#fff' },
                'xz': { bg: '#33ff33', text: '#000' },
                'yz': { bg: '#ff3333', text: '#fff' }
            };
            
            const colors = axisColors[axis] || { bg: '#666', text: '#fff' };
            label.textContent = axisNames[axis] || axis.toUpperCase();
            label.style.backgroundColor = colors.bg;
            label.style.color = colors.text;
            label.style.opacity = '1';
            
            // Position near the gizmo
            const gizmoScreenPos = gizmoGroup.position.clone().project(camera);
            const container = document.querySelector('.viewport');
            const rect = container.getBoundingClientRect();
            const x = (gizmoScreenPos.x * 0.5 + 0.5) * rect.width + 30;
            const y = (-gizmoScreenPos.y * 0.5 + 0.5) * rect.height - 20;
            
            label.style.left = x + 'px';
            label.style.top = y + 'px';
        }
        
        function hideAxisLabel() {
            const label = document.getElementById('gizmo-axis-label');
            if (label) {
                label.style.opacity = '0';
            }
        }
        
        function showGizmoInfo(visible) {
            const info = document.getElementById('gizmo-info');
            info.classList.toggle('visible', visible);
            
            if (visible) {
                document.getElementById('gizmo-info-title').textContent = 
                    gizmoState.mode === 'translate' ? 'Position' : 'Rotation';
                
                // Highlight active axis
                ['x', 'y', 'z'].forEach(axis => {
                    const el = document.getElementById(`gizmo-axis-${axis}`);
                    if (el) {
                        const isActive = gizmoState.activeAxis && 
                            (gizmoState.activeAxis === axis || gizmoState.activeAxis.includes(axis));
                        el.classList.toggle('active', isActive);
                    }
                });
            }
        }
        
        function updateGizmoInfo(data) {
            if (gizmoState.mode === 'translate') {
                document.getElementById('gizmo-x').textContent = data.position.x.toFixed(2);
                document.getElementById('gizmo-y').textContent = data.position.y.toFixed(2);
                document.getElementById('gizmo-z').textContent = data.position.z.toFixed(2);
                
                // Calculate and display delta
                if (gizmoState.startValue) {
                    const dx = data.position.x - gizmoState.startValue.x;
                    const dy = data.position.y - gizmoState.startValue.y;
                    const dz = data.position.z - gizmoState.startValue.z;
                    const delta = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    document.getElementById('gizmo-delta-value').textContent = 
                        (delta >= 0 ? '+' : '') + delta.toFixed(2) + 'm';
                }
            } else {
                document.getElementById('gizmo-x').textContent = data.rotation.x.toFixed(1) + 'Â°';
                document.getElementById('gizmo-y').textContent = data.rotation.y.toFixed(1) + 'Â°';
                document.getElementById('gizmo-z').textContent = data.rotation.z.toFixed(1) + 'Â°';
                
                // Calculate and display delta for rotation
                if (gizmoState.startValue) {
                    const dx = data.rotation.x - gizmoState.startValue.x;
                    const dy = data.rotation.y - gizmoState.startValue.y;
                    const dz = data.rotation.z - gizmoState.startValue.z;
                    const maxDelta = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));
                    document.getElementById('gizmo-delta-value').textContent = 
                        (maxDelta >= 0 ? '+' : '') + maxDelta.toFixed(1) + 'Â°';
                }
            }
            
            // Update active axis highlighting during drag
            ['x', 'y', 'z'].forEach(axis => {
                const el = document.getElementById(`gizmo-axis-${axis}`);
                if (el) {
                    const isActive = gizmoState.activeAxis && 
                        (gizmoState.activeAxis === axis || gizmoState.activeAxis.includes(axis));
                    el.classList.toggle('active', isActive);
                }
            });
        }
        
        // ==========================================
        // END TRANSFORM GIZMO SYSTEM
        // ==========================================
        
        // Projector presets with real-world specifications
        const projectorPresets = {
            'custom': { name: 'Custom', lumens: 10000, throwRatio: 1.5, aspectRatio: 16/9, resolution: '1920Ã—1080' },
            'barco-udx-4k40': { name: 'Barco UDX-4K40', lumens: 40000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840Ã—2160' },
            'barco-udx-4k26': { name: 'Barco UDX-4K26', lumens: 26000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840Ã—2160' },
            'christie-griffyn-4k35': { name: 'Christie Griffyn 4K35', lumens: 36500, throwRatio: 1.38, aspectRatio: 16/9, resolution: '4096Ã—2160' },
            'christie-d4k40': { name: 'Christie D4K40-RGB', lumens: 45000, throwRatio: 1.8, aspectRatio: 1.9, resolution: '4096Ã—2160' },
            'panasonic-pt-rq35k': { name: 'Panasonic PT-RQ35K', lumens: 30500, throwRatio: 1.7, aspectRatio: 16/9, resolution: '5120Ã—3200' },
            'panasonic-pt-rz120': { name: 'Panasonic PT-RZ120', lumens: 12000, throwRatio: 1.7, aspectRatio: 16/10, resolution: '1920Ã—1200' },
            'epson-pro-l30000': { name: 'Epson Pro L30000U', lumens: 30000, throwRatio: 1.57, aspectRatio: 16/10, resolution: '1920Ã—1200' },
            'sony-vpl-gtz380': { name: 'Sony VPL-GTZ380', lumens: 10000, throwRatio: 1.4, aspectRatio: 17/9, resolution: '4096Ã—2160' },
            'digital-projection-titan': { name: 'DP TITAN Laser 37000', lumens: 37000, throwRatio: 1.56, aspectRatio: 16/9, resolution: '3840Ã—2160' }
        };
        
        // ==========================================
        // SHADERS - With luminance calculation
        // ==========================================
        
        const projectionVertexShader = `
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            void main() {
                vWorldPosition = modelMatrix * vec4(position, 1.0);
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // Fragment shader with shadow mapping for occlusion
        // Uses 8 unique texture slots (16 texture units) but supports 20 projection slots
        // Array instances share their parent projector's texture and shadow map
        const projectionFragmentShader = `
            // 8 texture slots per pass (8 proj + 8 shadow = 16 texture units max)
            // Multi-pass rendering allows unlimited projectors
            uniform sampler2D projTex0, projTex1, projTex2, projTex3;
            uniform sampler2D projTex4, projTex5, projTex6, projTex7;
            uniform sampler2D shadowMap0, shadowMap1, shadowMap2, shadowMap3;
            uniform sampler2D shadowMap4, shadowMap5, shadowMap6, shadowMap7;
            
            // Per-slot data for this pass (8 slots max per pass)
            uniform mat4 projMat[8];
            uniform mat4 shadowMat[8];
            uniform vec3 projPos[8];
            uniform mat3 projRotInv[8];
            uniform float projLumens[8];
            uniform float projThrow[8];
            uniform float projNear[8];
            uniform float projFar[8];
            uniform vec2 texOffset[8];
            uniform vec4 lensParams[8];   // x=type, y=k1, z=k2, w=k3
            uniform vec4 lensParams2[8];  // x=p1, y=p2, z=cx, w=cy
            uniform float fisheyeFov[8];
            
            uniform int numProjectors;     // Number of projectors in THIS pass (0-8)
            uniform bool includeAmbient;   // True for pass 0, false for additive passes
            uniform bool showCoverage;
            uniform bool showOverlap;
            uniform bool showHeatmap;
            uniform bool debugLensType;
            uniform float surfaceGain;
            uniform vec3 baseColor;
            uniform float heatmapMax;
            uniform float ambientIntensity;
            
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            #define LENS_RECTILINEAR 0
            #define LENS_FISHEYE_EQUIDISTANT 1
            #define LENS_FISHEYE_EQUISOLID 2
            #define LENS_FISHEYE_STEREOGRAPHIC 3
            #define LENS_FISHEYE_ORTHOGRAPHIC 4
            
            vec2 applyDistortion(vec2 uv, float k1, float k2, float k3, float p1, float p2, float cx, float cy) {
                vec2 centered = uv - vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                float r2 = dot(centered, centered);
                float r4 = r2 * r2;
                float r6 = r4 * r2;
                float radialFactor = 1.0 + k1 * r2 + k2 * r4 + k3 * r6;
                vec2 tangential = vec2(
                    2.0 * p1 * centered.x * centered.y + p2 * (r2 + 2.0 * centered.x * centered.x),
                    p1 * (r2 + 2.0 * centered.y * centered.y) + 2.0 * p2 * centered.x * centered.y
                );
                vec2 distorted = centered * radialFactor + tangential;
                return distorted + vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
            }
            
            vec2 calculateFisheyeUV(vec3 localDir, int lensType, float cx, float cy) {
                float cosTheta = localDir.z;
                float theta = acos(clamp(cosTheta, -1.0, 1.0));
                vec2 xyDir = localDir.xy;
                float xyLen = length(xyDir);
                
                if (xyLen < 0.0001) {
                    return vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                }
                
                vec2 xyNorm = xyDir / xyLen;
                float halfPi = 1.5707963;
                float radius;
                
                if (lensType == LENS_FISHEYE_EQUIDISTANT) {
                    radius = theta / halfPi;
                } else if (lensType == LENS_FISHEYE_EQUISOLID) {
                    radius = 2.0 * sin(theta * 0.5) / 1.4142;
                } else if (lensType == LENS_FISHEYE_STEREOGRAPHIC) {
                    radius = tan(theta * 0.5);
                } else if (lensType == LENS_FISHEYE_ORTHOGRAPHIC) {
                    radius = sin(theta);
                } else {
                    radius = tan(theta);
                }
                
                radius = clamp(radius, 0.0, 1.5);
                vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                return principalPoint + xyNorm * radius * 0.5;
            }
            
            float unpackLinearDepth(vec4 rgbaDepth) {
                const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
                return dot(rgbaDepth, bitShift);
            }
            
            vec3 heatmapColor(float t) {
                if (t > 1.0) {
                    float overflow = min((t - 1.0) * 2.0, 1.0);
                    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), overflow);
                }
                t = clamp(t, 0.0, 1.0);
                if (t < 0.167) return mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.27, 0.67), t / 0.167);
                else if (t < 0.333) return mix(vec3(0.0, 0.27, 0.67), vec3(0.0, 0.67, 0.27), (t - 0.167) / 0.167);
                else if (t < 0.5) return mix(vec3(0.0, 0.67, 0.27), vec3(0.67, 0.67, 0.0), (t - 0.333) / 0.167);
                else if (t < 0.667) return mix(vec3(0.67, 0.67, 0.0), vec3(1.0, 0.67, 0.0), (t - 0.5) / 0.167);
                else if (t < 0.833) return mix(vec3(1.0, 0.67, 0.0), vec3(1.0, 0.4, 0.0), (t - 0.667) / 0.167);
                else return mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.833) / 0.167);
            }
            
            // Sample texture by slot index (0-7)
            vec4 sampleProjTex(int slot, vec2 uv) {
                if (slot == 0) return texture2D(projTex0, uv);
                else if (slot == 1) return texture2D(projTex1, uv);
                else if (slot == 2) return texture2D(projTex2, uv);
                else if (slot == 3) return texture2D(projTex3, uv);
                else if (slot == 4) return texture2D(projTex4, uv);
                else if (slot == 5) return texture2D(projTex5, uv);
                else if (slot == 6) return texture2D(projTex6, uv);
                else return texture2D(projTex7, uv);
            }
            
            vec4 sampleShadowTex(int slot, vec2 uv) {
                if (slot == 0) return texture2D(shadowMap0, uv);
                else if (slot == 1) return texture2D(shadowMap1, uv);
                else if (slot == 2) return texture2D(shadowMap2, uv);
                else if (slot == 3) return texture2D(shadowMap3, uv);
                else if (slot == 4) return texture2D(shadowMap4, uv);
                else if (slot == 5) return texture2D(shadowMap5, uv);
                else if (slot == 6) return texture2D(shadowMap6, uv);
                else return texture2D(shadowMap7, uv);
            }
            
            // Sample a projector with explicit parameters (avoids GLSL ES array indexing issues)
            vec4 sampleProjectorDirect(
                mat4 pMat, mat4 sMat, vec3 pPos, mat3 pRotInv,
                float lumens, float throwRatio, float nearPlane, float farPlane,
                vec2 tOffset, vec4 lParams, vec4 lParams2, float fovDeg,
                sampler2D pTex, sampler2D sTex
            ) {
                // Extract lens type with robust bounds checking
                // 0 = rectilinear, 1-4 = fisheye variants
                int lensType = int(lParams.x + 0.5);
                // Safety: treat any invalid lens type as rectilinear
                if (lensType < 0 || lensType > 4) lensType = 0;
                
                float k1 = lParams.y;
                float k2 = lParams.z;
                float k3 = lParams.w;
                float p1 = lParams2.x;
                float p2 = lParams2.y;
                float cx = lParams2.z;
                float cy = lParams2.w;
                
                vec3 worldDir = vWorldPosition.xyz - pPos;
                float dist = length(worldDir);
                vec3 worldDirNorm = worldDir / dist;
                
                if (dist < nearPlane || dist > farPlane) return vec4(0.0);
                
                vec3 toProj = -worldDirNorm;
                float facing = dot(vWorldNormal, toProj);
                if (facing <= 0.0) return vec4(0.0);
                
                vec2 lensUV;
                vec2 shadowUV;
                float shadowViewZ = 0.0;  // View-space Z for shadow comparison
                
                // Always compute shadow coordinates using shadow matrix
                // Shadow map was rendered with shadow camera, so we need its view-space Z
                vec4 shadowProjCoord = sMat * vWorldPosition;
                if (shadowProjCoord.w > 0.0) {
                    shadowViewZ = shadowProjCoord.w;  // View-space Z from shadow camera's perspective
                }
                
                if (lensType == LENS_RECTILINEAR) {
                    vec4 projCoord = pMat * vWorldPosition;
                    if (projCoord.w <= 0.0) return vec4(0.0);
                    
                    vec3 ndc = projCoord.xyz / projCoord.w;
                    lensUV = ndc.xy * 0.5 + 0.5;
                    
                    if (lensUV.x < 0.0 || lensUV.x > 1.0 || lensUV.y < 0.0 || lensUV.y > 1.0) return vec4(0.0);
                    if (ndc.z < -1.0 || ndc.z > 1.0) return vec4(0.0);
                    
                    // Shadow UV from shadow matrix (must check w > 0 before division)
                    if (shadowProjCoord.w > 0.0) {
                        vec3 shadowNdc = shadowProjCoord.xyz / shadowProjCoord.w;
                        shadowUV = shadowNdc.xy * 0.5 + 0.5;
                    } else {
                        shadowUV = vec2(-1.0);  // Invalid
                    }
                } else {
                    vec3 localDir = pRotInv * worldDirNorm;
                    if (localDir.z <= 0.0) return vec4(0.0);
                    
                    float theta = acos(clamp(localDir.z, 0.0, 1.0));
                    float maxTheta = radians(fovDeg * 0.5);
                    if (theta > maxTheta) return vec4(0.0);
                    
                    lensUV = calculateFisheyeUV(localDir, lensType, cx, cy);
                    
                    float maxRadius = fovDeg / 360.0;
                    vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                    float radialDist = length(lensUV - principalPoint);
                    if (radialDist > maxRadius) return vec4(0.0);
                    
                    // Use shadow coordinates already computed from shadow matrix
                    if (shadowProjCoord.w > 0.0) {
                        vec3 shadowNdc = shadowProjCoord.xyz / shadowProjCoord.w;
                        shadowUV = shadowNdc.xy * 0.5 + 0.5;
                    } else {
                        shadowUV = vec2(-1.0);  // Invalid - skip shadow test
                        shadowViewZ = 0.0;  // Override to skip shadow test
                    }
                }
                
                // Shadow test - CRITICAL: Use view-space Z depth, NOT Euclidean distance
                // Using Euclidean distance causes circular clipping because:
                // At center: 3D dist â‰ˆ Z depth
                // At 45Â° angle: 3D dist = Z depth / cos(45Â°) = 1.41Ã— larger
                // This causes false shadow rejection at edges in a circular pattern!
                // 
                // shadowViewZ is from shadowProjCoord.w which is view-space Z from shadow camera
                // Shadow map stores: (linearDepth - near) / (far - near)
                // So we must normalize the same way
                if (shadowUV.x >= 0.0 && shadowUV.x <= 1.0 && shadowUV.y >= 0.0 && shadowUV.y <= 1.0 && shadowViewZ > 0.0) {
                    vec4 shadowSample = texture2D(sTex, shadowUV);
                    float storedDepth = unpackLinearDepth(shadowSample);
                    // Normalize view-space Z to [0,1] range matching shadow map encoding
                    float currentDepth = (shadowViewZ - nearPlane) / (farPlane - nearPlane);
                    // Bias: distance-based + angle-based to prevent shadow acne
                    float distanceBias = 0.001 + (shadowViewZ * 0.0005);
                    float angleBias = 0.002 * (1.0 - facing);
                    float bias = distanceBias + angleBias;
                    if (storedDepth > 0.001 && currentDepth > storedDepth + bias) {
                        return vec4(0.0);
                    }
                }
                
                // Calculate illumination
                float projWidth = dist / throwRatio;
                float projHeight = projWidth / (16.0/9.0);
                float projArea = projWidth * projHeight;
                float lux = lumens / projArea;
                float cdm2 = (lux * surfaceGain / 3.14159) * facing;
                
                // Edge falloff
                float edgeFalloff;
                if (lensType == LENS_RECTILINEAR) {
                    float edgeDist = max(abs(lensUV.x - 0.5), abs(lensUV.y - 0.5)) * 2.0;
                    edgeFalloff = 1.0 - smoothstep(0.85, 1.0, edgeDist);
                } else {
                    vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                    float maxRadius = fovDeg / 360.0;
                    float radialDist = length(lensUV - principalPoint) / maxRadius;
                    edgeFalloff = 1.0 - smoothstep(0.85, 1.0, radialDist);
                }
                cdm2 *= edgeFalloff;
                
                // Sample texture
                vec2 scrolledUV = fract(lensUV + tOffset);
                vec4 texColor = texture2D(pTex, scrolledUV);
                float displayIntensity = cdm2 / 1500.0;
                
                return vec4(texColor.rgb * displayIntensity * facing, cdm2);
            }
            
            void main() {
                // Only include ambient on first pass
                vec3 color = includeAmbient ? baseColor * (0.02 + ambientIntensity * 0.5) : vec3(0.0);
                float totalCdm2 = 0.0;
                int hitCount = 0;
                
                // UNROLLED LOOP: Use explicit constant indices to avoid GLSL ES array indexing issues
                // Each projector slot is sampled with constant array indices
                if (numProjectors > 0) {
                    vec4 result = sampleProjectorDirect(
                        projMat[0], shadowMat[0], projPos[0], projRotInv[0],
                        projLumens[0], projThrow[0], projNear[0], projFar[0],
                        texOffset[0], lensParams[0], lensParams2[0], fisheyeFov[0],
                        projTex0, shadowMap0
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 1) {
                    vec4 result = sampleProjectorDirect(
                        projMat[1], shadowMat[1], projPos[1], projRotInv[1],
                        projLumens[1], projThrow[1], projNear[1], projFar[1],
                        texOffset[1], lensParams[1], lensParams2[1], fisheyeFov[1],
                        projTex1, shadowMap1
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 2) {
                    vec4 result = sampleProjectorDirect(
                        projMat[2], shadowMat[2], projPos[2], projRotInv[2],
                        projLumens[2], projThrow[2], projNear[2], projFar[2],
                        texOffset[2], lensParams[2], lensParams2[2], fisheyeFov[2],
                        projTex2, shadowMap2
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 3) {
                    vec4 result = sampleProjectorDirect(
                        projMat[3], shadowMat[3], projPos[3], projRotInv[3],
                        projLumens[3], projThrow[3], projNear[3], projFar[3],
                        texOffset[3], lensParams[3], lensParams2[3], fisheyeFov[3],
                        projTex3, shadowMap3
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 4) {
                    vec4 result = sampleProjectorDirect(
                        projMat[4], shadowMat[4], projPos[4], projRotInv[4],
                        projLumens[4], projThrow[4], projNear[4], projFar[4],
                        texOffset[4], lensParams[4], lensParams2[4], fisheyeFov[4],
                        projTex4, shadowMap4
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 5) {
                    vec4 result = sampleProjectorDirect(
                        projMat[5], shadowMat[5], projPos[5], projRotInv[5],
                        projLumens[5], projThrow[5], projNear[5], projFar[5],
                        texOffset[5], lensParams[5], lensParams2[5], fisheyeFov[5],
                        projTex5, shadowMap5
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 6) {
                    vec4 result = sampleProjectorDirect(
                        projMat[6], shadowMat[6], projPos[6], projRotInv[6],
                        projLumens[6], projThrow[6], projNear[6], projFar[6],
                        texOffset[6], lensParams[6], lensParams2[6], fisheyeFov[6],
                        projTex6, shadowMap6
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                if (numProjectors > 7) {
                    vec4 result = sampleProjectorDirect(
                        projMat[7], shadowMat[7], projPos[7], projRotInv[7],
                        projLumens[7], projThrow[7], projNear[7], projFar[7],
                        texOffset[7], lensParams[7], lensParams2[7], fisheyeFov[7],
                        projTex7, shadowMap7
                    );
                    if (result.a > 0.0) { color += result.rgb; totalCdm2 += result.a; hitCount++; }
                }
                
                // Visualization modes only apply when includeAmbient is true (first pass)
                if (includeAmbient) {
                    // Debug mode: show lens type as color
                    if (debugLensType && numProjectors > 0) {
                        int lensType = int(lensParams[0].x + 0.5);
                        if (lensType == LENS_RECTILINEAR) {
                            color = mix(color, vec3(0.0, 1.0, 0.0), 0.5); // Green = rectilinear
                        } else {
                            color = mix(color, vec3(0.0, 0.5, 1.0), 0.5); // Blue = fisheye
                        }
                        if (hitCount == 0) {
                            color = vec3(0.2, 0.0, 0.0); // Dark red = no projection hit
                        }
                    } else if (showHeatmap) {
                        if (hitCount == 0) {
                            color = vec3(0.0, 0.0, 0.1);
                        } else {
                            float normalizedLuminance = totalCdm2 / heatmapMax;
                            color = heatmapColor(normalizedLuminance);
                        }
                    } else {
                        if (showCoverage && hitCount == 0) {
                            color = vec3(0.25, 0.02, 0.02);
                        }
                        if (showOverlap && hitCount > 1) {
                            float overlapIntensity = float(hitCount - 1) / 3.0;
                            color = mix(color, vec3(1.0, 0.5, 0.0), min(overlapIntensity, 0.7));
                        }
                    }
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // ==========================================
        // ACCUMULATION SHADER - Outputs (hitCount, totalCdm2) for visualization
        // ==========================================
        const accumulationFragmentShader = `
            precision highp float;
            
            // Same uniforms as projection shader
            uniform mat4 projMat[8];
            uniform mat4 shadowMat[8];
            uniform vec3 projPos[8];
            uniform mat3 projRotInv[8];
            uniform float projLumens[8];
            uniform float projThrow[8];
            uniform float projNear[8];
            uniform float projFar[8];
            uniform vec2 texOffset[8];
            uniform vec4 lensParams[8];
            uniform vec4 lensParams2[8];
            uniform float fisheyeFov[8];
            uniform sampler2D projTex0, projTex1, projTex2, projTex3;
            uniform sampler2D projTex4, projTex5, projTex6, projTex7;
            uniform sampler2D shadowMap0, shadowMap1, shadowMap2, shadowMap3;
            uniform sampler2D shadowMap4, shadowMap5, shadowMap6, shadowMap7;
            uniform int numProjectors;
            uniform float surfaceGain;
            
            varying vec4 vWorldPosition;
            varying vec3 vWorldNormal;
            
            const int LENS_RECTILINEAR = 0;
            const int LENS_FISHEYE_EQUIDISTANT = 1;
            const int LENS_FISHEYE_EQUISOLID = 2;
            const int LENS_FISHEYE_STEREOGRAPHIC = 3;
            const int LENS_FISHEYE_ORTHOGRAPHIC = 4;
            
            float unpackLinearDepth(vec4 rgba) {
                const vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
                return dot(rgba, bitShift);
            }
            
            vec2 calculateFisheyeUV(vec3 localDir, int fisheyeType, float cx, float cy) {
                float theta = acos(clamp(localDir.z, 0.0, 1.0));
                float phi = atan(localDir.y, localDir.x);
                float r;
                if (fisheyeType == LENS_FISHEYE_EQUIDISTANT) {
                    r = theta / 3.14159;
                } else if (fisheyeType == LENS_FISHEYE_EQUISOLID) {
                    r = 2.0 * sin(theta / 2.0) / 3.14159;
                } else if (fisheyeType == LENS_FISHEYE_STEREOGRAPHIC) {
                    r = 2.0 * tan(theta / 2.0) / 3.14159;
                } else {
                    r = sin(theta) / 3.14159;
                }
                vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                return principalPoint + r * vec2(cos(phi), sin(phi));
            }
            
            // Returns cdm2 if hit, 0 if no hit
            float sampleProjectorAccum(
                mat4 pMat, mat4 sMat, vec3 pPos, mat3 pRotInv,
                float lumens, float throwRatio, float nearPlane, float farPlane,
                vec4 lParams, vec4 lParams2, float fovDeg,
                sampler2D sTex
            ) {
                int lensType = int(lParams.x + 0.5);
                if (lensType < 0 || lensType > 4) lensType = 0;
                
                float cx = lParams2.z;
                float cy = lParams2.w;
                
                vec3 worldDir = vWorldPosition.xyz - pPos;
                float dist = length(worldDir);
                vec3 worldDirNorm = worldDir / dist;
                
                if (dist < nearPlane || dist > farPlane) return 0.0;
                
                vec3 toProj = -worldDirNorm;
                float facing = dot(vWorldNormal, toProj);
                if (facing <= 0.0) return 0.0;
                
                vec2 lensUV;
                vec2 shadowUV;
                float shadowViewZ = 0.0;
                
                vec4 shadowProjCoord = sMat * vWorldPosition;
                if (shadowProjCoord.w > 0.0) {
                    shadowViewZ = shadowProjCoord.w;
                }
                
                if (lensType == LENS_RECTILINEAR) {
                    vec4 projCoord = pMat * vWorldPosition;
                    if (projCoord.w <= 0.0) return 0.0;
                    
                    vec3 ndc = projCoord.xyz / projCoord.w;
                    lensUV = ndc.xy * 0.5 + 0.5;
                    
                    if (lensUV.x < 0.0 || lensUV.x > 1.0 || lensUV.y < 0.0 || lensUV.y > 1.0) return 0.0;
                    if (ndc.z < -1.0 || ndc.z > 1.0) return 0.0;
                    
                    if (shadowProjCoord.w > 0.0) {
                        vec3 shadowNdc = shadowProjCoord.xyz / shadowProjCoord.w;
                        shadowUV = shadowNdc.xy * 0.5 + 0.5;
                    } else {
                        shadowUV = vec2(-1.0);
                    }
                } else {
                    vec3 localDir = pRotInv * worldDirNorm;
                    if (localDir.z <= 0.0) return 0.0;
                    
                    float theta = acos(clamp(localDir.z, 0.0, 1.0));
                    float maxTheta = radians(fovDeg * 0.5);
                    if (theta > maxTheta) return 0.0;
                    
                    lensUV = calculateFisheyeUV(localDir, lensType, cx, cy);
                    
                    float maxRadius = fovDeg / 360.0;
                    vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                    float radialDist = length(lensUV - principalPoint);
                    if (radialDist > maxRadius) return 0.0;
                    
                    if (shadowProjCoord.w > 0.0) {
                        vec3 shadowNdc = shadowProjCoord.xyz / shadowProjCoord.w;
                        shadowUV = shadowNdc.xy * 0.5 + 0.5;
                    } else {
                        shadowUV = vec2(-1.0);
                        shadowViewZ = 0.0;
                    }
                }
                
                // Shadow test
                if (shadowUV.x >= 0.0 && shadowUV.x <= 1.0 && shadowUV.y >= 0.0 && shadowUV.y <= 1.0 && shadowViewZ > 0.0) {
                    vec4 shadowSample = texture2D(sTex, shadowUV);
                    float storedDepth = unpackLinearDepth(shadowSample);
                    float currentDepth = (shadowViewZ - nearPlane) / (farPlane - nearPlane);
                    float distanceBias = 0.001 + (shadowViewZ * 0.0005);
                    float angleBias = 0.002 * (1.0 - facing);
                    float bias = distanceBias + angleBias;
                    if (storedDepth > 0.001 && currentDepth > storedDepth + bias) {
                        return 0.0;
                    }
                }
                
                // Calculate luminance
                float projWidth = dist / throwRatio;
                float projHeight = projWidth / (16.0/9.0);
                float projArea = projWidth * projHeight;
                float lux = lumens / projArea;
                float cdm2 = (lux * surfaceGain / 3.14159) * facing;
                
                // Edge falloff
                float edgeFalloff;
                if (lensType == LENS_RECTILINEAR) {
                    float edgeDist = max(abs(lensUV.x - 0.5), abs(lensUV.y - 0.5)) * 2.0;
                    edgeFalloff = 1.0 - smoothstep(0.85, 1.0, edgeDist);
                } else {
                    vec2 principalPoint = vec2(0.5 + cx * 0.5, 0.5 + cy * 0.5);
                    float maxRadius = fovDeg / 360.0;
                    float radialDist = length(lensUV - principalPoint) / maxRadius;
                    edgeFalloff = 1.0 - smoothstep(0.85, 1.0, radialDist);
                }
                
                return cdm2 * edgeFalloff;
            }
            
            void main() {
                float hitCount = 0.0;
                float totalCdm2 = 0.0;
                
                // Unrolled loop for each projector slot
                if (numProjectors > 0) {
                    float cdm2 = sampleProjectorAccum(projMat[0], shadowMat[0], projPos[0], projRotInv[0],
                        projLumens[0], projThrow[0], projNear[0], projFar[0],
                        lensParams[0], lensParams2[0], fisheyeFov[0], shadowMap0);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 1) {
                    float cdm2 = sampleProjectorAccum(projMat[1], shadowMat[1], projPos[1], projRotInv[1],
                        projLumens[1], projThrow[1], projNear[1], projFar[1],
                        lensParams[1], lensParams2[1], fisheyeFov[1], shadowMap1);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 2) {
                    float cdm2 = sampleProjectorAccum(projMat[2], shadowMat[2], projPos[2], projRotInv[2],
                        projLumens[2], projThrow[2], projNear[2], projFar[2],
                        lensParams[2], lensParams2[2], fisheyeFov[2], shadowMap2);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 3) {
                    float cdm2 = sampleProjectorAccum(projMat[3], shadowMat[3], projPos[3], projRotInv[3],
                        projLumens[3], projThrow[3], projNear[3], projFar[3],
                        lensParams[3], lensParams2[3], fisheyeFov[3], shadowMap3);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 4) {
                    float cdm2 = sampleProjectorAccum(projMat[4], shadowMat[4], projPos[4], projRotInv[4],
                        projLumens[4], projThrow[4], projNear[4], projFar[4],
                        lensParams[4], lensParams2[4], fisheyeFov[4], shadowMap4);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 5) {
                    float cdm2 = sampleProjectorAccum(projMat[5], shadowMat[5], projPos[5], projRotInv[5],
                        projLumens[5], projThrow[5], projNear[5], projFar[5],
                        lensParams[5], lensParams2[5], fisheyeFov[5], shadowMap5);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 6) {
                    float cdm2 = sampleProjectorAccum(projMat[6], shadowMat[6], projPos[6], projRotInv[6],
                        projLumens[6], projThrow[6], projNear[6], projFar[6],
                        lensParams[6], lensParams2[6], fisheyeFov[6], shadowMap6);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                if (numProjectors > 7) {
                    float cdm2 = sampleProjectorAccum(projMat[7], shadowMat[7], projPos[7], projRotInv[7],
                        projLumens[7], projThrow[7], projNear[7], projFar[7],
                        lensParams[7], lensParams2[7], fisheyeFov[7], shadowMap7);
                    if (cdm2 > 0.0) { hitCount += 1.0; totalCdm2 += cdm2; }
                }
                
                // Output: R = hit count, G = total cdm2 (scaled for precision)
                gl_FragColor = vec4(hitCount, totalCdm2 / 10000.0, 0.0, 1.0);
            }
        `;
        
        // ==========================================
        // VISUALIZATION COMPOSITE SHADER
        // ==========================================
        const compositeVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        const compositeFragmentShader = `
            precision highp float;
            
            uniform sampler2D colorTexture;
            uniform sampler2D accumTexture;
            uniform bool showCoverage;
            uniform bool showOverlap;
            uniform bool showHeatmap;
            uniform float heatmapMax;
            
            varying vec2 vUv;
            
            vec3 heatmapColor(float t) {
                t = clamp(t, 0.0, 1.0);
                if (t < 0.25) {
                    return mix(vec3(0.0, 0.0, 0.5), vec3(0.0, 0.5, 1.0), t * 4.0);
                } else if (t < 0.5) {
                    return mix(vec3(0.0, 0.5, 1.0), vec3(0.0, 1.0, 0.5), (t - 0.25) * 4.0);
                } else if (t < 0.75) {
                    return mix(vec3(0.0, 1.0, 0.5), vec3(1.0, 1.0, 0.0), (t - 0.5) * 4.0);
                } else {
                    return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (t - 0.75) * 4.0);
                }
            }
            
            void main() {
                vec4 color = texture2D(colorTexture, vUv);
                vec4 accum = texture2D(accumTexture, vUv);
                
                float hitCount = accum.r;
                float totalCdm2 = accum.g * 10000.0; // Unscale
                float isSurface = accum.a; // Alpha > 0 means this pixel is a surface
                
                vec3 result = color.rgb;
                
                // Only apply visualization to surface pixels (alpha > 0.5)
                if (isSurface > 0.5) {
                    if (showHeatmap) {
                        if (hitCount < 0.5) {
                            result = vec3(0.0, 0.0, 0.1); // No coverage = dark blue
                        } else {
                            float normalizedLuminance = totalCdm2 / heatmapMax;
                            result = heatmapColor(normalizedLuminance);
                        }
                    } else {
                        if (showCoverage && hitCount < 0.5) {
                            result = vec3(0.25, 0.02, 0.02); // No coverage = dark red
                        }
                        if (showOverlap && hitCount > 1.5) {
                            float overlapIntensity = (hitCount - 1.0) / 3.0;
                            result = mix(result, vec3(1.0, 0.5, 0.0), min(overlapIntensity, 0.7));
                        }
                    }
                }
                
                gl_FragColor = vec4(result, 1.0);
            }
        `;
        
        // ==========================================
        // INITIALIZATION
        // ==========================================
        
        function init() {
            initThreeJS();
            initControls();
            initKeyboardControls();
            animate();
            updateStatus();
        }
        
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0c);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, -18);
            camera.rotation.order = 'YXZ';
            camera.rotation.set(0, Math.PI, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));  // Basic ambient for non-projected areas
            
            gridHelper = new THREE.GridHelper(50, 50, 0x2a2a32, 0x1a1a20);
            scene.add(gridHelper);
            
            projectorGroup = new THREE.Group();
            surfaceGroup = new THREE.Group();
            distanceHelperGroup = new THREE.Group();
            scene.add(projectorGroup);
            scene.add(surfaceGroup);
            scene.add(distanceHelperGroup);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Custom linear depth material for better precision at distance
            // Standard depth buffers have poor precision at large distances
            const linearDepthVertexShader = `
                varying float vLinearDepth;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vLinearDepth = -mvPosition.z; // Linear view-space depth
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            const linearDepthFragmentShader = `
                varying float vLinearDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                
                // Pack float to RGBA for precision
                vec4 packDepth(float depth) {
                    float normalized = (depth - cameraNear) / (cameraFar - cameraNear);
                    normalized = clamp(normalized, 0.0, 1.0);
                    
                    const vec4 bitShift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
                    const vec4 bitMask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
                    vec4 res = fract(normalized * bitShift);
                    res -= res.xxyz * bitMask;
                    return res;
                }
                
                void main() {
                    gl_FragColor = packDepth(vLinearDepth);
                }
            `;
            
            depthMaterial = new THREE.ShaderMaterial({
                vertexShader: linearDepthVertexShader,
                fragmentShader: linearDepthFragmentShader,
                uniforms: {
                    cameraNear: { value: 0.1 },
                    cameraFar: { value: 100 }
                }
            });
            
            // Initialize accumulation system for visualization modes
            initAccumulationSystem(container.clientWidth, container.clientHeight);
            
            // Create transform gizmos
            createGizmos();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
                // Resize accumulation targets
                resizeAccumulationTargets(container.clientWidth, container.clientHeight);
            });
        }
        
        // Initialize accumulation system for visualization modes
        function initAccumulationSystem(width, height) {
            // Float texture for accumulation (hitCount in R, cdm2 in G)
            accumulationTarget = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });
            
            // Color render target
            colorTarget = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            
            // Composite scene with full-screen quad
            compositeScene = new THREE.Scene();
            compositeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            const quadGeometry = new THREE.PlaneGeometry(2, 2);
            compositeMaterial = new THREE.ShaderMaterial({
                vertexShader: compositeVertexShader,
                fragmentShader: compositeFragmentShader,
                uniforms: {
                    colorTexture: { value: null },
                    accumTexture: { value: null },
                    showCoverage: { value: false },
                    showOverlap: { value: false },
                    showHeatmap: { value: false },
                    heatmapMax: { value: 1000.0 }
                }
            });
            
            const quad = new THREE.Mesh(quadGeometry, compositeMaterial);
            compositeScene.add(quad);
        }
        
        // Resize accumulation targets when window resizes
        function resizeAccumulationTargets(width, height) {
            if (accumulationTarget) {
                accumulationTarget.setSize(width, height);
            }
            if (colorTarget) {
                colorTarget.setSize(width, height);
            }
        }
        
        // Create accumulation material for a surface
        function createAccumulationMaterial(surfaceMaterial) {
            // Clone uniforms from surface material
            const uniforms = {};
            for (const key in surfaceMaterial.uniforms) {
                if (surfaceMaterial.uniforms[key].value !== undefined) {
                    uniforms[key] = { value: surfaceMaterial.uniforms[key].value };
                }
            }
            
            return new THREE.ShaderMaterial({
                vertexShader: surfaceMaterial.vertexShader,
                fragmentShader: accumulationFragmentShader,
                uniforms: uniforms,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: true,
                depthFunc: THREE.LessEqualDepth,
                side: THREE.DoubleSide  // Render both sides for proper visualization
            });
        }
        
        // Get or create accumulation material for a mesh
        function getAccumulationMaterial(mesh) {
            const surfaceId = mesh.userData.surfaceId;
            
            if (!accumulationMaterials.has(surfaceId)) {
                const accumMat = createAccumulationMaterial(mesh.material);
                accumulationMaterials.set(surfaceId, accumMat);
            }
            
            return accumulationMaterials.get(surfaceId);
        }
        
        // Update accumulation material uniforms to match surface material
        function syncAccumulationMaterial(surfaceMaterial, accumMaterial) {
            for (const key in surfaceMaterial.uniforms) {
                if (accumMaterial.uniforms[key]) {
                    accumMaterial.uniforms[key].value = surfaceMaterial.uniforms[key].value;
                }
            }
        }
        
        // Create or update shadow map for a projector
        function updateShadowMap(projector) {
            // For non-array projectors, create shadow map at projector's position
            const worldTransform = getWorldTransform(projector);
            return updateShadowMapForTransform(projector, worldTransform, projector.id);
        }
        
        // Update shadow map for a specific world transform (supports array instances)
        function updateShadowMapForTransform(projector, worldTransform, shadowKey) {
            // Determine FOV based on lens type
            // Fisheye lenses need a much wider shadow map to cover their FOV
            const lens = projector.lens || { type: 'rectilinear' };
            const isFisheye = lens.type && lens.type.startsWith('fisheye');
            
            let verticalFov, aspectRatio;
            if (isFisheye) {
                // Use the projector's fisheye FOV for shadow map (clamped to practical limit)
                // Perspective cameras can't truly do 180Â°, so clamp to 170Â° max
                const fisheyeFov = lens.fisheyeFov || 180;
                verticalFov = Math.min(fisheyeFov, 170);
                aspectRatio = 1.0; // Square shadow map for omnidirectional coverage
            } else {
                // Use same vertical FOV calculation as projection matrix for rectilinear
                verticalFov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom * projector.aspectRatio)) * (180 / Math.PI);
                aspectRatio = projector.aspectRatio;
            }
            
            const nearPlane = projector.nearPlane || 0.1;
            const farPlane = projector.farPlane || 100;
            
            let shadowData = shadowMaps.get(shadowKey);
            
            if (!shadowData) {
                // Create new render target and camera
                const renderTarget = new THREE.WebGLRenderTarget(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat
                });
                
                const shadowCamera = new THREE.PerspectiveCamera(verticalFov, aspectRatio, nearPlane, farPlane);
                
                shadowData = { renderTarget, camera: shadowCamera, isFisheye };
                shadowMaps.set(shadowKey, shadowData);
            }
            
            // Update shadow camera
            const shadowCamera = shadowData.camera;
            shadowCamera.fov = verticalFov;
            shadowCamera.aspect = aspectRatio;
            shadowCamera.near = nearPlane;
            shadowCamera.far = farPlane;
            shadowData.isFisheye = isFisheye;
            
            // Use provided world transform
            shadowCamera.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            
            // Use same quaternion composition as projection matrix
            const flipQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            const userEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z),
                'YXZ'
            );
            const userQuat = new THREE.Quaternion().setFromEuler(userEuler);
            const finalQuat = new THREE.Quaternion().multiplyQuaternions(userQuat, flipQuat);
            shadowCamera.quaternion.copy(finalQuat);
            
            shadowCamera.updateMatrixWorld(true);
            shadowCamera.updateProjectionMatrix();
            
            // Render shadow map
            renderShadowMap(shadowKey);
            
            return shadowData;
        }
        
        function renderShadowMap(projectorId) {
            const shadowData = shadowMaps.get(projectorId);
            if (!shadowData || !depthMaterial) return;
            
            // Update depth material uniforms to match this projector's shadow camera
            depthMaterial.uniforms.cameraNear.value = shadowData.camera.near;
            depthMaterial.uniforms.cameraFar.value = shadowData.camera.far;
            
            const currentBackground = scene.background;
            const currentOverrideMaterial = scene.overrideMaterial;
            
            scene.background = null;
            scene.overrideMaterial = depthMaterial;
            
            // Hide gizmos, projectors, and distance helpers during shadow render
            const gizmoVisible = gizmoGroup ? gizmoGroup.visible : false;
            const projectorVisible = projectorGroup.visible;
            const distanceVisible = distanceHelperGroup ? distanceHelperGroup.visible : false;
            if (gizmoGroup) gizmoGroup.visible = false;
            if (distanceHelperGroup) distanceHelperGroup.visible = false;
            projectorGroup.visible = false;
            gridHelper.visible = false;
            
            renderer.setRenderTarget(shadowData.renderTarget);
            renderer.setClearColor(0xffffff, 1); // White = max depth (nothing there)
            renderer.clear();
            renderer.render(scene, shadowData.camera);
            renderer.setRenderTarget(null);
            renderer.setClearColor(0x0d0d12, 1); // Restore scene clear color
            
            // Restore
            scene.background = currentBackground;
            scene.overrideMaterial = currentOverrideMaterial;
            if (gizmoGroup) gizmoGroup.visible = gizmoVisible;
            if (distanceHelperGroup) distanceHelperGroup.visible = distanceVisible;
            projectorGroup.visible = projectorVisible;
            gridHelper.visible = state.displayOptions.grid;
        }
        
        function renderAllShadowMaps() {
            state.projectors.filter(p => p.enabled).forEach(p => {
                updateShadowMap(p);
            });
        }
        
        function initControls() {
            let isMouseDown = false;
            let mouseButton = -1;  // Track which button is pressed
            let prevMouseX = 0, prevMouseY = 0;
            let mouseDownX = 0, mouseDownY = 0;
            let isDragging = false;
            let isGizmoActive = false;
            
            renderer.domElement.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    // Check if clicking on gizmo first
                    if (handleGizmoInteraction(e, 'down')) {
                        isGizmoActive = true;
                        return;
                    }
                }
                
                if (e.button === 0 || e.button === 2) {
                    isMouseDown = true;
                    mouseButton = e.button;
                    isDragging = false;
                    prevMouseX = e.clientX;
                    prevMouseY = e.clientY;
                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                }
            });
            
            renderer.domElement.addEventListener('mouseup', e => {
                if (isGizmoActive) {
                    handleGizmoInteraction(e, 'up');
                    isGizmoActive = false;
                    gizmoState.startAngle = null;
                    return;
                }
                
                if (!isDragging && e.button === 0) {
                    handleCanvasClick(e);
                }
                isMouseDown = false;
                mouseButton = -1;
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => { 
                isMouseDown = false; 
                mouseButton = -1;
                isDragging = false;
                if (isGizmoActive) {
                    handleGizmoInteraction(null, 'up');
                    isGizmoActive = false;
                    gizmoState.startAngle = null;
                }
            });
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            renderer.domElement.addEventListener('mousemove', e => {
                // Handle gizmo dragging
                if (isGizmoActive) {
                    handleGizmoInteraction(e, 'move');
                    return;
                }
                
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - prevMouseX;
                const deltaY = e.clientY - prevMouseY;
                
                const totalMovement = Math.abs(e.clientX - mouseDownX) + Math.abs(e.clientY - mouseDownY);
                if (totalMovement > 5) isDragging = true;
                
                if (mouseButton === 0) {
                    // Left-click drag: Rotate camera (look around)
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y -= deltaX * 0.003;
                    camera.rotation.x -= deltaY * 0.003;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    
                    // Sync projector if in pilot mode
                    if (pilotMode.enabled) {
                        syncProjectorToCamera();
                    }
                } else if (mouseButton === 2) {
                    // Right-click drag: Pan camera (move in view plane)
                    const panSpeed = 0.01;
                    
                    // Get camera's right and up vectors in world space
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera.getWorldDirection(new THREE.Vector3());
                    right.setFromMatrixColumn(camera.matrix, 0);  // First column = right
                    up.setFromMatrixColumn(camera.matrix, 1);     // Second column = up
                    
                    // Move camera: right for horizontal, up for vertical
                    camera.position.addScaledVector(right, -deltaX * panSpeed);
                    camera.position.addScaledVector(up, deltaY * panSpeed);
                    
                    // Sync projector if in pilot mode
                    if (pilotMode.enabled) {
                        syncProjectorToCamera();
                    }
                }
                
                prevMouseX = e.clientX;
                prevMouseY = e.clientY;
            });
            
            // Scroll wheel: Move forward/backward
            renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                
                const scrollSpeed = 0.5;
                const delta = e.deltaY > 0 ? -scrollSpeed : scrollSpeed;
                
                // Get camera's forward direction
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                
                // Move camera along forward direction
                camera.position.addScaledVector(forward, delta);
                
                // Sync projector if in pilot mode
                if (pilotMode.enabled) {
                    syncProjectorToCamera();
                }
            }, { passive: false });
            
            // Gizmo hover effect
            renderer.domElement.addEventListener('mousemove', e => {
                if (isGizmoActive || !gizmoGroup || !gizmoGroup.visible) {
                    // Clear hover state when dragging
                    if (hoveredAxis && !gizmoState.isDragging) {
                        highlightAxis(hoveredAxis, false);
                        hoveredAxis = null;
                        hideAxisLabel();
                    }
                    return;
                }
                
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );
                
                updateGizmoHover(mouse);
            });
        }
        
        function initKeyboardControls() {
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                const tag = document.activeElement.tagName;
                const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement.isContentEditable;
                
                // Ctrl+Z for undo - works even when typing
                if ((e.ctrlKey || e.metaKey) && key === 'z') {
                    e.preventDefault();
                    undo();
                    return;
                }
                
                // Ctrl+D for debug lens type visualization
                if ((e.ctrlKey || e.metaKey) && key === 'd') {
                    e.preventDefault();
                    toggleDebugLensType();
                    return;
                }
                
                // Skip all hotkeys if user is typing in an input field
                if (isTyping) {
                    // Only allow Escape to blur the input
                    if (key === 'escape') {
                        document.activeElement.blur();
                        e.preventDefault();
                    }
                    return; // Don't capture any other keys while typing
                }
                
                // WASD movement keys (only when not typing)
                if (keys.hasOwnProperty(key)) { 
                    keys[key] = true; 
                    e.preventDefault(); 
                }
                
                // Transform mode shortcuts
                if (key === 'g' && state.selectedObject) {
                    setTransformMode('translate');
                    e.preventDefault();
                } else if (key === 'r' && state.selectedObject) {
                    setTransformMode('rotate');
                    e.preventDefault();
                } else if (key === 'v') {
                    setTransformMode('select');
                    e.preventDefault();
                } else if (key === 'escape') {
                    // Cancel current operation or deselect
                    if (gizmoState.isDragging) {
                        gizmoState.isDragging = false;
                        gizmoState.activeAxis = null;
                        showGizmoInfo(false);
                    } else {
                        state.selectedObject = null;
                        state.selectedType = null;
                        updateProjectorList();
                        updateSurfaceList();
                        updatePropertiesPanel();
                        enableTransformTools(false);
                        updateGizmoPosition();
                    }
                    e.preventDefault();
                } else if (key === 'delete' || key === 'backspace') {
                    // Delete selected object
                    if (state.selectedObject) {
                        if (state.selectedType === 'projector') {
                            removeProjector(state.selectedObject);
                        } else if (state.selectedType === 'surface') {
                            removeSurface(state.selectedObject);
                        }
                        e.preventDefault();
                    }
                }
            });
            window.addEventListener('keyup', e => {
                const key = e.key.toLowerCase();
                if (keys.hasOwnProperty(key)) keys[key] = false;
            });
        }
        
        function updateCameraMovement() {
            const speed = 0.15;
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            const right = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();
            
            const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
            const rightHoriz = new THREE.Vector3(right.x, 0, right.z).normalize();
            
            let moved = false;
            if (keys.w) { camera.position.addScaledVector(forward, speed); moved = true; }
            if (keys.s) { camera.position.addScaledVector(forward, -speed); moved = true; }
            if (keys.a) { camera.position.addScaledVector(rightHoriz, -speed); moved = true; }
            if (keys.d) { camera.position.addScaledVector(rightHoriz, speed); moved = true; }
            if (keys.e) { camera.position.y += speed; moved = true; }
            if (keys.q) { camera.position.y -= speed; moved = true; }
            
            // Sync projector if in pilot mode
            if (moved && pilotMode.enabled) {
                syncProjectorToCamera();
            }
        }
        
        function handleCanvasClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const projMeshes = [];
            projectorGroup.traverse(c => { if (c.isMesh && c.userData.isProjector) projMeshes.push(c); });
            let hits = raycaster.intersectObjects(projMeshes);
            if (hits.length > 0) { selectObject('projector', hits[0].object.userData.projectorId); return; }
            
            hits = raycaster.intersectObjects(surfaceGroup.children);
            if (hits.length > 0 && hits[0].object.userData.surfaceId) {
                selectObject('surface', hits[0].object.userData.surfaceId);
            }
        }
        
        // ==========================================
        // TEXTURE GENERATION
        // ==========================================
        
        function createPatternTexture(pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            switch(pattern) {
                case 'none':
                    ctx.fillStyle = '#999';
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'grid':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 512; i += 32) {
                        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
                    }
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(4, 4, 504, 504);
                    break;
                case 'checker':
                    for (let y = 0; y < 512; y += 32)
                        for (let x = 0; x < 512; x += 32) {
                            ctx.fillStyle = ((x + y) / 32) % 2 === 0 ? '#fff' : '#000';
                            ctx.fillRect(x, y, 32, 32);
                        }
                    break;
                case 'gradient':
                    const grad = ctx.createLinearGradient(0, 0, 512, 0);
                    grad.addColorStop(0, '#000'); grad.addColorStop(1, '#fff');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);
                    break;
                case 'colorbars':
                    ['#fff','#ff0','#0ff','#0f0','#f0f','#f00','#00f'].forEach((c, i) => {
                        ctx.fillStyle = c;
                        ctx.fillRect(i * 512/7, 0, 512/7 + 1, 512);
                    });
                    break;
                case 'cross':
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 512, 512);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(256, 0); ctx.lineTo(256, 512);
                    ctx.moveTo(0, 256); ctx.lineTo(512, 256);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(256, 256, 100, 0, Math.PI * 2);
                    ctx.arc(256, 256, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 3;
                    [[10,10],[452,10],[10,452],[452,452]].forEach(([x,y]) => ctx.strokeRect(x, y, 50, 50));
                    break;
                case 'white':
                    // 16:9 Grid with alphanumeric identifiers (A1, A2, B1, etc.)
                    // Use 1024x576 for 16:9 aspect ratio
                    canvas.width = 1024; canvas.height = 576;
                    const cols = 16;
                    const rows = 9;
                    const cellW = canvas.width / cols;
                    const cellH = canvas.height / rows;
                    
                    // Background
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw grid cells
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const x = c * cellW;
                            const y = r * cellH;
                            
                            // Alternate cell colors slightly
                            ctx.fillStyle = (r + c) % 2 === 0 ? '#222' : '#1a1a1a';
                            ctx.fillRect(x, y, cellW, cellH);
                            ctx.strokeRect(x, y, cellW, cellH);
                            
                            // Cell label (A1, A2, ..., I16)
                            const rowLabel = String.fromCharCode(65 + r); // A, B, C...
                            const colLabel = (c + 1).toString();
                            const label = rowLabel + colLabel;
                            
                            ctx.fillStyle = '#666';
                            ctx.font = 'bold 18px monospace';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(label, x + cellW / 2, y + cellH / 2);
                        }
                    }
                    
                    // Border
                    ctx.strokeStyle = '#0af';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                    
                    // Center crosshair
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                    break;
                case 'blend':
                    ctx.fillStyle = '#888';
                    ctx.fillRect(0, 0, 512, 512);
                    const lg = ctx.createLinearGradient(0, 0, 120, 0);
                    lg.addColorStop(0, 'rgba(255,0,0,1)'); lg.addColorStop(1, 'transparent');
                    ctx.fillStyle = lg; ctx.fillRect(0, 0, 120, 512);
                    const rg = ctx.createLinearGradient(392, 0, 512, 0);
                    rg.addColorStop(0, 'transparent'); rg.addColorStop(1, 'rgba(0,255,0,1)');
                    ctx.fillStyle = rg; ctx.fillRect(392, 0, 120, 512);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // ==========================================
        // PROJECTOR
        // ==========================================
        
        function addProjector(presetKey = 'custom') {
            const preset = projectorPresets[presetKey] || projectorPresets['custom'];
            const id = Date.now();
            const projector = {
                id,
                uuid: generateUUID(),  // Unique identifier for disguise compatibility
                name: `Projector ${state.projectors.length + 1}`,
                preset: presetKey,
                position: { x: 0, y: 4, z: -8 },
                rotation: { x: -10, y: 0, z: 0 },  // pitch, yaw, roll
                lumens: preset.lumens,
                brightness: 100,       // Brightness percentage (0-100)
                stack: 1,              // Quantity for stacked projectors
                throwRatio: preset.throwRatio,
                aspectRatio: preset.aspectRatio,
                resolution: preset.resolution,
                zoom: 1.0,
                enabled: true,
                customTextureUrl: null,
                nearPlane: 0.1,
                farPlane: 100,
                frustumDistance: 20,
                // Body mesh properties
                body: {
                    width: 0.4,        // Body width in meters
                    height: 0.2,       // Body height in meters
                    depth: 0.5,        // Body depth in meters
                    offsetX: 0,        // Position offset X
                    offsetY: 0,        // Position offset Y
                    offsetZ: 0         // Position offset Z
                },
                // Lens/Optics properties
                lens: {
                    type: 'rectilinear',  // rectilinear, fisheye_equidistant, fisheye_equisolid, fisheye_stereographic, fisheye_orthographic
                    fisheyeFov: 180,      // FOV in degrees for fisheye lenses (90-220, typical 180)
                    shiftH: 0,            // Horizontal lens shift in % (-100 to 100)
                    shiftV: 0,            // Vertical lens shift in % (-100 to 100)
                    // Distortion coefficients (Brown-Conrady model)
                    k1: 0,                // Radial distortion coefficient 1
                    k2: 0,                // Radial distortion coefficient 2
                    k3: 0,                // Radial distortion coefficient 3
                    p1: 0,                // Tangential distortion coefficient 1
                    p2: 0,                // Tangential distortion coefficient 2
                    // Principal point offset (normalized -1 to 1) - derived from shift
                    cx: 0,                // Horizontal principal point offset
                    cy: 0                 // Vertical principal point offset
                },
                // Target point (optional - for look-at calculations)
                target: null,  // { x, y, z } or null
                // Hierarchy - parent ID for nested transforms
                parentId: null,
                // Projector Array settings (for creating multiple evenly-spaced projectors)
                array: null  // { count: 3, spacing: { x: 2, y: 0, z: 0 }, rotationOffset: { x: 0, y: 0, z: 0 } }
            };
            
            state.projectors.push(projector);
            createProjectorMesh(projector);
            updateProjectorMatrix(projector);
            updateShadowMap(projector);  // Create shadow map for new projector
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', id);
            calculateCoverage();
        }
        
        // Generate UUID v4
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16).toUpperCase();
            });
        }
        
        // ==========================================
        // HIERARCHY / PARENT-CHILD SYSTEM
        // ==========================================
        
        // Get an object by ID (projector or surface)
        function getObjectById(id, type = null) {
            if (type === 'projector' || !type) {
                const proj = state.projectors.find(p => p.id === id);
                if (proj) return { obj: proj, type: 'projector' };
            }
            if (type === 'surface' || !type) {
                const surf = state.surfaces.find(s => s.id === id);
                if (surf) return { obj: surf, type: 'surface' };
            }
            return null;
        }
        
        // Get world transform by traversing parent chain
        function getWorldTransform(obj) {
            const localPos = { ...obj.position };
            const localRot = { ...obj.rotation };
            
            if (!obj.parentId) {
                return { position: localPos, rotation: localRot };
            }
            
            // Build parent chain
            const chain = [];
            let current = obj;
            while (current.parentId) {
                const parentResult = getObjectById(current.parentId);
                if (!parentResult) break;
                chain.unshift(parentResult.obj);
                current = parentResult.obj;
            }
            
            // Apply transforms from root to leaf
            const worldPos = new THREE.Vector3(localPos.x, localPos.y, localPos.z);
            const worldRot = new THREE.Euler(
                THREE.MathUtils.degToRad(localRot.x),
                THREE.MathUtils.degToRad(localRot.y),
                THREE.MathUtils.degToRad(localRot.z),
                'YXZ'
            );
            
            // Start with local position/rotation, then transform by each parent
            for (let i = chain.length - 1; i >= 0; i--) {
                const parent = chain[i];
                const parentEuler = new THREE.Euler(
                    THREE.MathUtils.degToRad(parent.rotation.x),
                    THREE.MathUtils.degToRad(parent.rotation.y),
                    THREE.MathUtils.degToRad(parent.rotation.z),
                    'YXZ'
                );
                
                // Rotate local position by parent rotation
                worldPos.applyEuler(parentEuler);
                // Add parent position
                worldPos.add(new THREE.Vector3(parent.position.x, parent.position.y, parent.position.z));
                
                // Combine rotations (apply parent rotation to local rotation)
                const parentQuat = new THREE.Quaternion().setFromEuler(parentEuler);
                const localQuat = new THREE.Quaternion().setFromEuler(worldRot);
                localQuat.premultiply(parentQuat);
                worldRot.setFromQuaternion(localQuat, 'YXZ');
            }
            
            return {
                position: { x: worldPos.x, y: worldPos.y, z: worldPos.z },
                rotation: {
                    x: THREE.MathUtils.radToDeg(worldRot.x),
                    y: THREE.MathUtils.radToDeg(worldRot.y),
                    z: THREE.MathUtils.radToDeg(worldRot.z)
                }
            };
        }
        
        // Get all array instances for a projector (for rendering and export)
        function getProjectorArrayInstances(projector) {
            if (!projector.array || projector.array.count <= 1) {
                return [{ projector, offset: { x: 0, y: 0, z: 0 }, rotOffset: { x: 0, y: 0, z: 0 }, index: 0 }];
            }
            
            const instances = [];
            const count = projector.array.count;
            const spacing = projector.array.spacing || { x: 0, y: 0, z: 0 };
            const rotOffset = projector.array.rotationOffset || { x: 0, y: 0, z: 0 };
            
            for (let i = 0; i < count; i++) {
                instances.push({
                    projector,
                    offset: {
                        x: spacing.x * i,
                        y: spacing.y * i,
                        z: spacing.z * i
                    },
                    rotOffset: {
                        x: rotOffset.x * i,
                        y: rotOffset.y * i,
                        z: rotOffset.z * i
                    },
                    index: i
                });
            }
            return instances;
        }
        
        // Get world transform for an array instance
        function getArrayInstanceWorldTransform(projector, instance) {
            // First get the projector's world transform (respecting hierarchy)
            const baseWorld = getWorldTransform(projector);
            
            // Apply array offset in local space, then transform to world
            const offsetVec = new THREE.Vector3(instance.offset.x, instance.offset.y, instance.offset.z);
            const baseEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(baseWorld.rotation.x),
                THREE.MathUtils.degToRad(baseWorld.rotation.y),
                THREE.MathUtils.degToRad(baseWorld.rotation.z),
                'YXZ'
            );
            offsetVec.applyEuler(baseEuler);
            
            return {
                position: {
                    x: baseWorld.position.x + offsetVec.x,
                    y: baseWorld.position.y + offsetVec.y,
                    z: baseWorld.position.z + offsetVec.z
                },
                rotation: {
                    x: baseWorld.rotation.x + instance.rotOffset.x,
                    y: baseWorld.rotation.y + instance.rotOffset.y,
                    z: baseWorld.rotation.z + instance.rotOffset.z
                }
            };
        }
        
        // Get valid parent options for an object (exclude self and descendants)
        function getParentOptions(type, excludeId) {
            const options = [{ id: null, name: '(None)', type: null }];
            
            // Add projectors as potential parents
            state.projectors.forEach(p => {
                if (p.id !== excludeId && !isDescendantOf(p.id, excludeId)) {
                    options.push({ id: p.id, name: p.name, type: 'projector' });
                }
            });
            
            // Add surfaces as potential parents
            state.surfaces.forEach(s => {
                if (s.id !== excludeId && !isDescendantOf(s.id, excludeId)) {
                    options.push({ id: s.id, name: s.name, type: 'surface' });
                }
            });
            
            return options;
        }
        
        // Check if an object is a descendant of another
        function isDescendantOf(childId, ancestorId) {
            if (!ancestorId) return false;
            
            const child = getObjectById(childId);
            if (!child) return false;
            
            let current = child.obj;
            while (current.parentId) {
                if (current.parentId === ancestorId) return true;
                const parent = getObjectById(current.parentId);
                if (!parent) break;
                current = parent.obj;
            }
            return false;
        }
        
        // Get children of an object
        function getChildren(parentId) {
            const children = [];
            state.projectors.forEach(p => {
                if (p.parentId === parentId) children.push({ obj: p, type: 'projector' });
            });
            state.surfaces.forEach(s => {
                if (s.parentId === parentId) children.push({ obj: s, type: 'surface' });
            });
            return children;
        }
        
        // Convert projector array to individual projectors
        function convertArrayToProjectors(projectorId) {
            const projector = state.projectors.find(p => p.id === projectorId);
            if (!projector || !projector.array || projector.array.count <= 1) {
                showToast('No array to convert');
                return;
            }
            
            const instances = getProjectorArrayInstances(projector);
            const newProjectors = [];
            
            // Skip first instance (index 0) as it becomes the original projector
            for (let i = 1; i < instances.length; i++) {
                const instance = instances[i];
                const worldTransform = getArrayInstanceWorldTransform(projector, instance);
                
                // Clone projector with world transform
                const newProj = JSON.parse(JSON.stringify(projector));
                newProj.id = Date.now() + i;
                newProj.uuid = generateUUID();
                newProj.name = `${projector.name} (${i + 1})`;
                newProj.position = worldTransform.position;
                newProj.rotation = worldTransform.rotation;
                newProj.array = null;  // Not an array
                newProj.parentId = null;  // Independent projector
                
                newProjectors.push(newProj);
            }
            
            // Clear array from original projector
            projector.array = null;
            
            // Add new projectors
            newProjectors.forEach(p => {
                state.projectors.push(p);
                createProjectorMesh(p);
                updateProjectorMatrix(p);
                updateShadowMap(p);
            });
            
            // Update original projector mesh (remove array instances)
            updateProjectorMeshWithArray(projector);
            
            updateAllSurfaceMaterials();
            updateProjectorList();
            updatePropertiesPanel();
            showToast(`Created ${newProjectors.length} projectors from array`);
        }

        // Calculate projector metrics at target distance
        function calculateProjectorMetrics(projector, targetDistance = null) {
            const dist = targetDistance || projector.frustumDistance || 20;
            const effectiveLumens = projector.lumens * (projector.brightness / 100) * (projector.stack || 1);
            
            // Calculate projection dimensions at target distance
            const width = dist / projector.throwRatio / (projector.zoom || 1);
            const height = width / projector.aspectRatio;
            const area = width * height;
            
            // Illuminance in lux at target
            const illuminance = effectiveLumens / area;
            
            // Parse resolution
            const resParts = projector.resolution.split('Ã—');
            const resX = parseInt(resParts[0]) || 1920;
            const resY = parseInt(resParts[1]) || 1080;
            
            // DPI at target (pixels per inch, with meters to inches conversion)
            const widthInches = width * 39.3701;
            const dpi = resX / widthInches;
            
            return {
                distance: dist,
                width: width,
                height: height,
                area: area,
                illuminance: illuminance,
                effectiveLumens: effectiveLumens,
                dpi: dpi,
                resX: resX,
                resY: resY
            };
        }
        
        function createProjectorMesh(projector) {
            // Get world transform (respects parent hierarchy)
            const worldTransform = getWorldTransform(projector);
            
            const group = new THREE.Group();
            group.userData.projectorId = projector.id;
            group.userData.isMainProjector = true;
            
            // Get body dimensions with defaults
            const bodyW = projector.body?.width || 0.4;
            const bodyH = projector.body?.height || 0.2;
            const bodyD = projector.body?.depth || 0.5;
            const offsetX = projector.body?.offsetX || 0;
            const offsetY = projector.body?.offsetY || 0;
            const offsetZ = projector.body?.offsetZ || 0;
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(bodyW, bodyH, bodyD),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            body.userData.isProjector = true;
            body.userData.projectorId = projector.id;
            body.position.set(offsetX, offsetY, offsetZ);
            group.add(body);
            
            // Direction indicator above projector
            const indicatorSize = Math.min(bodyW, bodyH) * 0.4;
            const indicator = new THREE.Mesh(
                new THREE.ConeGeometry(indicatorSize, indicatorSize * 2.5, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            indicator.rotation.x = Math.PI / 2;
            indicator.position.y = offsetY + bodyH / 2 + indicatorSize;
            indicator.position.z = offsetZ + bodyD * 0.3;
            group.add(indicator);
            
            group.add(createFrustum(projector));
            
            // Use world transform for position and rotation
            group.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            group.rotation.order = 'YXZ';
            group.rotation.set(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z)
            );
            
            projectorGroup.add(group);
            
            // Create array instance meshes if applicable
            if (projector.array && projector.array.count > 1) {
                createArrayInstanceMeshes(projector);
            }
        }
        
        // Create ghost meshes for array instances
        function createArrayInstanceMeshes(projector) {
            const instances = getProjectorArrayInstances(projector);
            const bodyW = projector.body?.width || 0.4;
            const bodyH = projector.body?.height || 0.2;
            const bodyD = projector.body?.depth || 0.5;
            
            // Skip first instance (it's the main projector)
            for (let i = 1; i < instances.length; i++) {
                const instance = instances[i];
                const worldTransform = getArrayInstanceWorldTransform(projector, instance);
                
                const group = new THREE.Group();
                group.userData.projectorId = projector.id;
                group.userData.arrayIndex = i;
                group.userData.isArrayInstance = true;
                
                // Ghost body (semi-transparent)
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(bodyW, bodyH, bodyD),
                    new THREE.MeshBasicMaterial({ color: 0x446688, transparent: true, opacity: 0.5 })
                );
                const offsetX = projector.body?.offsetX || 0;
                const offsetY = projector.body?.offsetY || 0;
                const offsetZ = projector.body?.offsetZ || 0;
                body.position.set(offsetX, offsetY, offsetZ);
                group.add(body);
                
                // Ghost frustum
                group.add(createFrustum(projector, true));
                
                group.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
                group.rotation.order = 'YXZ';
                group.rotation.set(
                    THREE.MathUtils.degToRad(worldTransform.rotation.x),
                    THREE.MathUtils.degToRad(worldTransform.rotation.y),
                    THREE.MathUtils.degToRad(worldTransform.rotation.z)
                );
                
                projectorGroup.add(group);
            }
        }
        
        // Update projector mesh with array (rebuild array instances)
        function updateProjectorMeshWithArray(projector) {
            // Remove existing array instance meshes
            const toRemove = [];
            projectorGroup.children.forEach(c => {
                if (c.userData.projectorId === projector.id && c.userData.isArrayInstance) {
                    toRemove.push(c);
                }
            });
            toRemove.forEach(c => {
                c.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                projectorGroup.remove(c);
            });
            
            // Recreate array instances if needed
            if (projector.array && projector.array.count > 1) {
                createArrayInstanceMeshes(projector);
            }
        }
        
        function createFrustum(projector, isGhost = false) {
            const group = new THREE.Group();
            group.userData.isFrustum = true;
            
            const dist = projector.frustumDistance || 20;
            // Calculate frustum dimensions at the target distance
            const w = (dist / projector.throwRatio) / projector.zoom;
            const h = w / projector.aspectRatio;
            
            const color = isGhost ? 0x4488aa : 0x00aaff;
            const opacity = isGhost ? 0.25 : 0.5;
            const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity, depthTest: true, depthWrite: false });
            
            // Frustum edge lines from projector to far plane
            const pts = [
                [0,0,0], [-w/2,-h/2,dist], [0,0,0], [w/2,-h/2,dist],
                [0,0,0], [w/2,h/2,dist], [0,0,0], [-w/2,h/2,dist]
            ].map(p => new THREE.Vector3(...p));
            group.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), mat));
            
            // Rectangle at frustum end
            const rect = [[-w/2,-h/2,dist], [w/2,-h/2,dist], [w/2,h/2,dist], [-w/2,h/2,dist], [-w/2,-h/2,dist]]
                .map(p => new THREE.Vector3(...p));
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rect), mat));
            
            group.visible = state.displayOptions.frustums;
            return group;
        }
        
        function updateProjectorMatrix(projector) {
            // Get world transform (respects parent hierarchy)
            const worldTransform = getWorldTransform(projector);
            
            // Calculate VERTICAL FOV from throw ratio
            // Throw ratio = distance / width, so horizontal half-angle = atan(1 / (2 * throwRatio * zoom))
            // Vertical half-angle = horizontal half-angle / aspectRatio
            // PerspectiveCamera expects vertical FOV
            const verticalFov = 2 * Math.atan(1 / (2 * projector.throwRatio * projector.zoom * projector.aspectRatio)) * (180 / Math.PI);
            
            const nearPlane = projector.nearPlane || 0.1;
            const farPlane = projector.farPlane || 100;
            
            const projCam = new THREE.PerspectiveCamera(verticalFov, projector.aspectRatio, nearPlane, farPlane);
            projCam.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            
            // User rotation euler (this is what the mesh uses, +Z is forward)
            const userEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z),
                'YXZ'
            );
            const userQuat = new THREE.Quaternion().setFromEuler(userEuler);
            
            // For the projection camera, we need to flip since cameras look at -Z by default
            // Create flip quaternion (180Â° around Y) to make camera face +Z instead of -Z
            const flipQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            
            // Compose: first flip to face +Z, then apply user rotation
            const finalQuat = new THREE.Quaternion().multiplyQuaternions(userQuat, flipQuat);
            projCam.quaternion.copy(finalQuat);
            
            projCam.updateMatrixWorld(true);
            projCam.updateProjectionMatrix();
            
            const vpMatrix = new THREE.Matrix4();
            vpMatrix.multiplyMatrices(projCam.projectionMatrix, projCam.matrixWorldInverse);
            
            // For fisheye calculation, use the USER rotation only (no flip)
            // This matches the projector mesh orientation where +Z is forward
            // The rotation matrix transforms from local to world space
            const rotMatrix = new THREE.Matrix4().makeRotationFromQuaternion(userQuat);
            const rotMatrix3 = new THREE.Matrix3().setFromMatrix4(rotMatrix);
            // Inverse (transpose) transforms from world to local space
            const rotMatrixInverse = rotMatrix3.clone().transpose();
            
            // Calculate effective lumens (base * brightness% * stack)
            const effectiveLumens = projector.lumens * ((projector.brightness || 100) / 100) * (projector.stack || 1);
            
            projectorMatrixData.set(projector.id, {
                matrix: vpMatrix,
                position: new THREE.Vector3(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z),
                rotationMatrixInverse: rotMatrixInverse,
                lumens: effectiveLumens,
                throwRatio: projector.throwRatio * projector.zoom,
                nearPlane: nearPlane,
                farPlane: farPlane
            });
            
            if (projector.customTextureUrl && customTextureData.has(projector.id)) {
                projectionTextures.set(projector.id, customTextureData.get(projector.id));
            } else {
                projectionTextures.set(projector.id, createPatternTexture(state.currentPattern));
            }
        }
        
        function updateProjectorMesh(projector) {
            // Get world transform (respects parent hierarchy)
            const worldTransform = getWorldTransform(projector);
            
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === projector.id && c.userData.isMainProjector);
            if (mesh) {
                mesh.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
                // Use YXZ order to match updateProjectorMatrix
                mesh.rotation.order = 'YXZ';
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(worldTransform.rotation.x),
                    THREE.MathUtils.degToRad(worldTransform.rotation.y),
                    THREE.MathUtils.degToRad(worldTransform.rotation.z)
                );
                
                const oldF = mesh.children.find(c => c.userData.isFrustum);
                if (oldF) {
                    // Dispose old frustum geometry and materials
                    oldF.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    mesh.remove(oldF);
                }
                mesh.add(createFrustum(projector));
            }
            
            // Update array instances
            updateProjectorMeshWithArray(projector);
            
            // Also update children of this projector
            const children = getChildren(projector.id);
            children.forEach(child => {
                if (child.type === 'projector') {
                    updateProjectorMesh(child.obj);
                } else if (child.type === 'surface') {
                    updateSurfaceMesh(child.obj);
                }
            });
            
            updateProjectorMatrix(projector);
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function applyPreset(projectorId, presetKey) {
            const projector = state.projectors.find(p => p.id === projectorId);
            const preset = projectorPresets[presetKey];
            if (!projector || !preset) return;
            
            projector.preset = presetKey;
            projector.lumens = preset.lumens;
            projector.throwRatio = preset.throwRatio;
            projector.aspectRatio = preset.aspectRatio;
            projector.resolution = preset.resolution;
            
            updateProjectorMesh(projector);
            updateProjectorList();
            updatePropertiesPanel();
        }
        
        function removeProjector(id) {
            // Orphan any children (projectors or surfaces that have this as parent)
            state.projectors.forEach(p => {
                if (p.parentId === id) {
                    p.parentId = null;
                    updateProjectorMesh(p);
                }
            });
            state.surfaces.forEach(s => {
                if (s.parentId === id) {
                    s.parentId = null;
                    updateSurfaceMesh(s);
                }
            });
            
            state.projectors = state.projectors.filter(p => p.id !== id);
            
            // Clean up main mesh and array instance meshes
            const meshesToRemove = projectorGroup.children.filter(c => c.userData.projectorId === id);
            meshesToRemove.forEach(mesh => {
                mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                projectorGroup.remove(mesh);
            });
            
            // Clean up shadow map render target
            const shadowData = shadowMaps.get(id);
            if (shadowData) {
                shadowData.renderTarget.dispose();
                shadowMaps.delete(id);
            }
            
            // Clean up video data
            const videoData = videoTextureData.get(id);
            if (videoData) {
                if (videoData.updateInterval) {
                    clearInterval(videoData.updateInterval);
                }
                videoData.video.pause();
                videoData.video.src = '';
                if (videoData.texture) videoData.texture.dispose();
                videoTextureData.delete(id);
            }
            
            // Clean up textures
            const tex = projectionTextures.get(id);
            if (tex && !customTextureData.has(id)) {
                tex.dispose(); // Only dispose if not a custom texture
            }
            projectorMatrixData.delete(id);
            projectionTextures.delete(id);
            customTextureData.delete(id);
            
            if (state.selectedType === 'projector' && state.selectedObject === id) {
                state.selectedObject = null;
                state.selectedType = null;
                updatePropertiesPanel();
            }
            
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateSurfaceList();
            updateStatus();
            calculateCoverage();
        }
        
        function loadCustomTexture(projectorId, file) {
            if (!file) return;
            
            const projector = state.projectors.find(p => p.id === projectorId);
            if (!projector) return;
            
            const isVideo = file.type.startsWith('video/');
            
            if (isVideo) {
                // Handle video file
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.loop = true;
                video.muted = true; // Muted to allow autoplay
                video.playsInline = true;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    video.src = e.target.result;
                    
                    video.onloadedmetadata = function() {
                        // Store video data
                        const resolution = projector.videoResolution || 'native';
                        const texture = createVideoTexture(video, resolution);
                        
                        videoTextureData.set(projectorId, {
                            video: video,
                            texture: texture,
                            playing: false,
                            loop: true,
                            resolution: resolution,
                            nativeWidth: video.videoWidth,
                            nativeHeight: video.videoHeight
                        });
                        
                        projector.customTextureUrl = 'video';
                        projector.customTextureType = 'video';
                        projector.videoResolution = resolution;
                        customTextureData.set(projectorId, texture);
                        projectionTextures.set(projectorId, texture);
                        updateAllSurfaceMaterials();
                        updatePropertiesPanel();
                    };
                };
                reader.readAsDataURL(file);
            } else {
                // Handle image file (original behavior)
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        
                        projector.customTextureUrl = e.target.result;
                        projector.customTextureType = 'image';
                        customTextureData.set(projectorId, texture);
                        projectionTextures.set(projectorId, texture);
                        updateAllSurfaceMaterials();
                        updatePropertiesPanel();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function createVideoTexture(video, resolution) {
            // Get target resolution
            const resolutions = {
                'native': { w: video.videoWidth, h: video.videoHeight },
                '1080p': { w: 1920, h: 1080 },
                '720p': { w: 1280, h: 720 },
                '480p': { w: 854, h: 480 },
                '360p': { w: 640, h: 360 }
            };
            
            const target = resolutions[resolution] || resolutions['native'];
            
            // Create a canvas for downsampling if needed
            if (resolution !== 'native' && (video.videoWidth > target.w || video.videoHeight > target.h)) {
                const canvas = document.createElement('canvas');
                canvas.width = target.w;
                canvas.height = target.h;
                
                // Create canvas texture that we'll update from video
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.userData = { 
                    canvas: canvas, 
                    ctx: canvas.getContext('2d'),
                    video: video,
                    isDownsampled: true
                };
                return texture;
            } else {
                // Use native video texture
                const texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                return texture;
            }
        }
        
        function updateVideoResolution(projectorId, resolution) {
            const videoData = videoTextureData.get(projectorId);
            const projector = state.projectors.find(p => p.id === projectorId);
            if (!videoData || !projector) return;
            
            const wasPlaying = videoData.playing;
            
            // Create new texture with new resolution
            const newTexture = createVideoTexture(videoData.video, resolution);
            
            // Clean up old texture
            if (videoData.texture) {
                videoData.texture.dispose();
            }
            
            videoData.texture = newTexture;
            videoData.resolution = resolution;
            projector.videoResolution = resolution;
            
            customTextureData.set(projectorId, newTexture);
            projectionTextures.set(projectorId, newTexture);
            updateAllSurfaceMaterials();
            
            if (wasPlaying) {
                playVideo(projectorId);
            }
        }
        
        function playVideo(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.play();
            videoData.playing = true;
            
            // Start interval to update seek bar
            if (!videoData.updateInterval) {
                videoData.updateInterval = setInterval(() => {
                    // Only update if this projector is selected
                    if (state.selectedType === 'projector' && state.selectedObject === projectorId) {
                        const seekInput = document.querySelector('.video-seek input[type="range"]');
                        const timeDisplay = document.querySelector('.video-time');
                        if (seekInput && timeDisplay) {
                            seekInput.value = videoData.video.currentTime;
                            seekInput.max = videoData.video.duration;
                            timeDisplay.textContent = `${formatTime(videoData.video.currentTime)} / ${formatTime(videoData.video.duration)}`;
                        }
                    }
                }, 250);
            }
            
            updatePropertiesPanel();
        }
        
        function pauseVideo(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.pause();
            videoData.playing = false;
            
            // Clear update interval
            if (videoData.updateInterval) {
                clearInterval(videoData.updateInterval);
                videoData.updateInterval = null;
            }
            
            updatePropertiesPanel();
        }
        
        function toggleVideoLoop(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.loop = !videoData.loop;
            videoData.video.loop = videoData.loop;
            updatePropertiesPanel();
        }
        
        function seekVideo(projectorId, time) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.currentTime = time;
        }
        
        function restartVideo(projectorId) {
            const videoData = videoTextureData.get(projectorId);
            if (!videoData) return;
            
            videoData.video.currentTime = 0;
            if (!videoData.playing) {
                playVideo(projectorId);
            }
        }
        
        function clearCustomTexture(projectorId) {
            const projector = state.projectors.find(p => p.id === projectorId);
            if (projector) {
                projector.customTextureUrl = null;
                projector.customTextureType = null;
                projector.videoResolution = null;
                
                // Clean up video if present
                const videoData = videoTextureData.get(projectorId);
                if (videoData) {
                    if (videoData.updateInterval) {
                        clearInterval(videoData.updateInterval);
                    }
                    videoData.video.pause();
                    videoData.video.src = '';
                    if (videoData.texture) videoData.texture.dispose();
                    videoTextureData.delete(projectorId);
                }
                
                customTextureData.delete(projectorId);
                projectionTextures.set(projectorId, createPatternTexture(state.currentPattern));
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
            }
        }
        
        function updateProjectorList() {
            const list = document.getElementById('projector-list');
            document.getElementById('projector-count').textContent = state.projectors.length;
            
            if (state.projectors.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No projectors yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.projectors.map(p => {
                let textureInfo = '';
                if (p.customTextureType === 'video') {
                    textureInfo = ' â€¢ Video';
                } else if (p.customTextureUrl) {
                    textureInfo = ' â€¢ Image';
                }
                const effectiveLm = p.lumens * ((p.brightness || 100) / 100) * (p.stack || 1);
                const stackInfo = (p.stack || 1) > 1 ? ` (Ã—${p.stack})` : '';
                const arrayInfo = p.array && p.array.count > 1 ? ` [Array: ${p.array.count}]` : '';
                const parentInfo = p.parentId ? ' âŠ‚' : '';  // Symbol to indicate it has a parent
                return `
                <div class="object-item ${state.selectedType === 'projector' && state.selectedObject === p.id ? 'selected' : ''}" onclick="selectObject('projector', ${p.id})" style="${p.parentId ? 'padding-left: 28px;' : ''}">
                    <div class="object-icon projector"><svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/></svg></div>
                    <div class="object-info">
                        <div class="object-name">${p.name}${stackInfo}${arrayInfo}${parentInfo}</div>
                        <div class="object-type">${(effectiveLm/1000).toFixed(0)}K lm${textureInfo}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn" onclick="event.stopPropagation(); duplicateProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeProjector(${p.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>
            `}).join('');
        }
        
        function duplicateProjector(id) {
            const orig = state.projectors.find(p => p.id === id);
            if (!orig) return;
            const dup = { 
                ...JSON.parse(JSON.stringify(orig)), 
                id: Date.now(), 
                uuid: generateUUID(),  // Generate new unique ID
                name: orig.name + ' (Copy)', 
                position: { ...orig.position, x: orig.position.x + 2 }, 
                customTextureUrl: null,
                customTextureType: null,
                videoResolution: null
            };
            state.projectors.push(dup);
            createProjectorMesh(dup);
            updateProjectorMatrix(dup);
            updateShadowMap(dup);  // Create shadow map for duplicated projector
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateStatus();
            selectObject('projector', dup.id);
            calculateCoverage();
        }
        
        // ==========================================
        // SURFACE
        // ==========================================
        
        function addSurface() {
            const id = Date.now();
            const surface = {
                id,
                name: `Surface ${state.surfaces.length + 1}`,
                type: 'flat',
                position: { x: 0, y: 3, z: 5 },
                rotation: { x: 0, y: 180, z: 0 },
                dimensions: { width: 8, height: 4.5 },
                curvature: 30,
                color: state.sceneSettings.defaultSurfaceColor,
                gain: 1.0,
                parentId: null  // Hierarchy - parent ID for nested transforms
            };
            
            state.surfaces.push(surface);
            createSurfaceMesh(surface);
            // Re-render shadow maps to include new surface, then update all materials
            updateAllSurfaceMaterials();
            updateSurfaceList();
            updateStatus();
            selectObject('surface', id);
            calculateCoverage();
        }
        
        function importOBJSurface(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(e.target.result);
                    
                    // Calculate bounding box to determine size and center
                    const box = new THREE.Box3().setFromObject(obj);
                    const size = new THREE.Vector3();
                    const center = new THREE.Vector3();
                    box.getSize(size);
                    box.getCenter(center);
                    
                    const id = Date.now();
                    const surface = {
                        id,
                        name: file.name.replace('.obj', ''),
                        type: 'custom',
                        position: { x: 0, y: size.y / 2, z: 5 },
                        rotation: { x: 0, y: 0, z: 0 },
                        dimensions: { width: size.x, height: size.y },
                        curvature: 0,
                        color: state.sceneSettings.defaultSurfaceColor,
                        gain: 1.0,
                        scale: 1.0,
                        objData: e.target.result, // Store OBJ data for export
                        parentId: null  // Hierarchy - parent ID for nested transforms
                    };
                    
                    state.surfaces.push(surface);
                    
                    // Create mesh from OBJ with projection material
                    createOBJSurfaceMesh(surface, obj, center);
                    
                    // Re-render shadow maps to include new surface, then update all materials
                    updateAllSurfaceMaterials();
                    updateSurfaceList();
                    updateStatus();
                    selectObject('surface', id);
                    calculateCoverage();
                    
                    showToast(`Imported "${surface.name}" successfully`);
                } catch (err) {
                    console.error('OBJ import error:', err);
                    showToast('Failed to import OBJ file', 'error');
                }
            };
            
            reader.onerror = function() {
                showToast('Failed to read OBJ file', 'error');
            };
            
            reader.readAsText(file);
            
            // Reset file input
            document.getElementById('obj-import').value = '';
        }
        
        function createOBJSurfaceMesh(surface, obj, center) {
            // Merge all geometries from the OBJ
            const geometries = [];
            obj.traverse(child => {
                if (child.isMesh && child.geometry) {
                    // Clone and transform geometry
                    const geom = child.geometry.clone();
                    
                    // Center the geometry
                    geom.translate(-center.x, -center.y, -center.z);
                    
                    // Ensure normals exist
                    if (!geom.attributes.normal) {
                        geom.computeVertexNormals();
                    }
                    
                    geometries.push(geom);
                }
            });
            
            if (geometries.length === 0) {
                showToast('No valid geometry found in OBJ', 'error');
                return;
            }
            
            // Merge geometries if multiple
            let finalGeom;
            if (geometries.length === 1) {
                finalGeom = geometries[0];
            } else {
                // Simple merge - combine all buffer attributes
                const positions = [];
                const normals = [];
                const uvs = [];
                
                geometries.forEach(geom => {
                    const pos = geom.attributes.position;
                    const norm = geom.attributes.normal;
                    const uv = geom.attributes.uv;
                    
                    for (let i = 0; i < pos.count; i++) {
                        positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        if (norm) normals.push(norm.getX(i), norm.getY(i), norm.getZ(i));
                        if (uv) uvs.push(uv.getX(i), uv.getY(i));
                    }
                });
                
                finalGeom = new THREE.BufferGeometry();
                finalGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                if (normals.length > 0) {
                    finalGeom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                } else {
                    finalGeom.computeVertexNormals();
                }
                if (uvs.length > 0) {
                    finalGeom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                }
            }
            
            const mesh = new THREE.Mesh(finalGeom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface;
            mesh.userData.isCustomOBJ = true;
            
            // Get world transform (respects parent hierarchy)
            const worldTransform = getWorldTransform(surface);
            
            mesh.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            // Use YXZ order consistently to avoid gimbal lock
            mesh.rotation.order = 'YXZ';
            mesh.rotation.set(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z)
            );
            
            // Apply scale
            const scale = surface.scale || 1.0;
            mesh.scale.setScalar(scale);
            
            surfaceGroup.add(mesh);
        }
        
        function createSurfaceMaterial(surface) {
            const defaultTex = createPatternTexture('none');
            const defaultShadowTex = new THREE.DataTexture(new Uint8Array([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat);
            defaultShadowTex.needsUpdate = true;
            
            // Initialize array uniform values for 8 projection slots (per pass)
            const projMatArr = [];
            const shadowMatArr = [];
            const projPosArr = [];
            const projRotInvArr = [];
            const projLumensArr = [];
            const projThrowArr = [];
            const projNearArr = [];
            const projFarArr = [];
            const texOffsetArr = [];
            const lensParamsArr = [];
            const lensParams2Arr = [];
            const fisheyeFovArr = [];
            
            for (let i = 0; i < 8; i++) {
                projMatArr.push(new THREE.Matrix4());
                shadowMatArr.push(new THREE.Matrix4());
                projPosArr.push(new THREE.Vector3());
                projRotInvArr.push(new THREE.Matrix3());
                projLumensArr.push(0);
                projThrowArr.push(1.5);
                projNearArr.push(0.1);
                projFarArr.push(100);
                texOffsetArr.push(new THREE.Vector2(0, 0));
                lensParamsArr.push(new THREE.Vector4(0, 0, 0, 0));
                lensParams2Arr.push(new THREE.Vector4(0, 0, 0, 0));
                fisheyeFovArr.push(180);
            }
            
            // Build uniforms object with 8 texture slots
            const uniforms = {
                // 8 individual texture uniforms
                projTex0: { value: defaultTex },
                projTex1: { value: defaultTex },
                projTex2: { value: defaultTex },
                projTex3: { value: defaultTex },
                projTex4: { value: defaultTex },
                projTex5: { value: defaultTex },
                projTex6: { value: defaultTex },
                projTex7: { value: defaultTex },
                shadowMap0: { value: defaultShadowTex },
                shadowMap1: { value: defaultShadowTex },
                shadowMap2: { value: defaultShadowTex },
                shadowMap3: { value: defaultShadowTex },
                shadowMap4: { value: defaultShadowTex },
                shadowMap5: { value: defaultShadowTex },
                shadowMap6: { value: defaultShadowTex },
                shadowMap7: { value: defaultShadowTex },
                // Array uniforms for 8 slots per pass
                projMat: { value: projMatArr },
                shadowMat: { value: shadowMatArr },
                projPos: { value: projPosArr },
                projRotInv: { value: projRotInvArr },
                projLumens: { value: projLumensArr },
                projThrow: { value: projThrowArr },
                projNear: { value: projNearArr },
                projFar: { value: projFarArr },
                texOffset: { value: texOffsetArr },
                lensParams: { value: lensParamsArr },
                lensParams2: { value: lensParams2Arr },
                fisheyeFov: { value: fisheyeFovArr },
                // Global uniforms
                numProjectors: { value: 0 },
                includeAmbient: { value: true },
                showCoverage: { value: state.displayOptions.coverage },
                showOverlap: { value: state.displayOptions.overlap },
                showHeatmap: { value: state.displayOptions.heatmap },
                debugLensType: { value: false },
                surfaceGain: { value: surface.gain },
                baseColor: { value: new THREE.Color(surface.color) },
                heatmapMax: { value: state.heatmapMax },
                ambientIntensity: { value: state.sceneSettings.ambientLight / 100 }
            };
            
            return new THREE.ShaderMaterial({
                uniforms,
                vertexShader: projectionVertexShader,
                fragmentShader: projectionFragmentShader,
                side: THREE.DoubleSide,
                transparent: false  // Set to true dynamically during additive passes
            });
        }
        
        // Calculate projection data for a slot given a projector and world transform
        function calculateProjectorSlotData(proj, worldTransform, slotData, shadowKey) {
            const verticalFov = 2 * Math.atan(1 / (2 * proj.throwRatio * proj.zoom * proj.aspectRatio)) * (180 / Math.PI);
            const nearPlane = proj.nearPlane || 0.1;
            const farPlane = proj.farPlane || 100;
            
            const projCam = new THREE.PerspectiveCamera(verticalFov, proj.aspectRatio, nearPlane, farPlane);
            projCam.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            
            const userEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z),
                'YXZ'
            );
            const userQuat = new THREE.Quaternion().setFromEuler(userEuler);
            const flipQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            const finalQuat = new THREE.Quaternion().multiplyQuaternions(userQuat, flipQuat);
            projCam.quaternion.copy(finalQuat);
            projCam.updateMatrixWorld(true);
            projCam.updateProjectionMatrix();
            
            const vpMatrix = new THREE.Matrix4();
            vpMatrix.multiplyMatrices(projCam.projectionMatrix, projCam.matrixWorldInverse);
            
            const rotMatrix = new THREE.Matrix4().makeRotationFromQuaternion(userQuat);
            const rotMatrix3 = new THREE.Matrix3().setFromMatrix4(rotMatrix);
            const rotMatrixInverse = rotMatrix3.clone().transpose();
            
            const effectiveLumens = proj.lumens * ((proj.brightness || 100) / 100) * (proj.stack || 1);
            
            slotData.projMat.copy(vpMatrix);
            slotData.projPos.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            slotData.projRotInv.copy(rotMatrixInverse);
            slotData.projLumens = effectiveLumens;
            slotData.projThrow = proj.throwRatio * proj.zoom;
            slotData.projNear = nearPlane;
            slotData.projFar = farPlane;
            
            // Shadow matrix - use shadowKey to get instance-specific shadow map
            const useShadowKey = shadowKey || proj.id;
            const shadow = shadowMaps.get(useShadowKey);
            if (shadow && shadow.camera) {
                const shadowVPMatrix = new THREE.Matrix4();
                shadowVPMatrix.multiplyMatrices(shadow.camera.projectionMatrix, shadow.camera.matrixWorldInverse);
                slotData.shadowMat.copy(shadowVPMatrix);
            }
            
            // Lens parameters
            const lens = proj.lens || { type: 'rectilinear', k1: 0, k2: 0, k3: 0, p1: 0, p2: 0, cx: 0, cy: 0 };
            const lensTypeMap = {
                'rectilinear': 0,
                'fisheye_equidistant': 1,
                'fisheye_equisolid': 2,
                'fisheye_stereographic': 3,
                'fisheye_orthographic': 4
            };
            const lensTypeValue = lensTypeMap[lens.type] !== undefined ? lensTypeMap[lens.type] : 0;
            slotData.lensParams.set(lensTypeValue, lens.k1 || 0, lens.k2 || 0, lens.k3 || 0);
            slotData.lensParams2.set(lens.p1 || 0, lens.p2 || 0, lens.cx || 0, lens.cy || 0);
            slotData.fisheyeFov = lens.fisheyeFov || 180;
            
            // Texture offset
            if (!proj.customTextureUrl && patternScrollState.enabled) {
                slotData.texOffset.set(patternScrollState.offset.x, patternScrollState.offset.y);
            } else {
                slotData.texOffset.set(0, 0);
            }
            
            // Texture and shadow map
            slotData.projTex = projectionTextures.get(proj.id) || createPatternTexture('none');
            const shadowData = shadowMaps.get(useShadowKey);
            if (shadowData && shadowData.renderTarget) {
                slotData.shadowTex = shadowData.renderTarget.texture;
            } else {
                slotData.shadowTex = null;
            }
        }
        
        // Update material uniforms for a specific render pass
        function updateMaterialForPass(material, passSlots, isFirstPass, surface) {
            const { defaultTex, defaultShadowTex } = getDefaultTextures();
            
            const u = material.uniforms;
            
            // Set pass-specific flags
            u.includeAmbient.value = isFirstPass;
            u.numProjectors.value = passSlots.length;
            
            // Update display options
            u.showCoverage.value = state.displayOptions.coverage;
            u.showOverlap.value = state.displayOptions.overlap;
            u.showHeatmap.value = state.displayOptions.heatmap;
            u.surfaceGain.value = surface.gain;
            u.baseColor.value.set(surface.color);
            u.heatmapMax.value = state.heatmapMax;
            u.ambientIntensity.value = state.sceneSettings.ambientLight / 100;
            
            // Fill slots 0-7 with this pass's projectors
            for (let i = 0; i < 8; i++) {
                if (i < passSlots.length) {
                    const slotData = passSlots[i];
                    
                    // Set textures
                    u[`projTex${i}`].value = slotData.projTex || defaultTex;
                    u[`shadowMap${i}`].value = slotData.shadowTex || defaultShadowTex;
                    
                    // Set array uniforms - use explicit value setting for reliable updates
                    u.projMat.value[i].copy(slotData.projMat);
                    u.shadowMat.value[i].copy(slotData.shadowMat);
                    u.projPos.value[i].copy(slotData.projPos);
                    u.projRotInv.value[i].copy(slotData.projRotInv);
                    u.projLumens.value[i] = slotData.projLumens;
                    u.projThrow.value[i] = slotData.projThrow;
                    u.projNear.value[i] = slotData.projNear;
                    u.projFar.value[i] = slotData.projFar;
                    u.texOffset.value[i].set(slotData.texOffset.x, slotData.texOffset.y);
                    // Set lens params explicitly to ensure values are correct
                    u.lensParams.value[i].set(
                        slotData.lensParams.x,
                        slotData.lensParams.y,
                        slotData.lensParams.z,
                        slotData.lensParams.w
                    );
                    u.lensParams2.value[i].set(
                        slotData.lensParams2.x,
                        slotData.lensParams2.y,
                        slotData.lensParams2.z,
                        slotData.lensParams2.w
                    );
                    u.fisheyeFov.value[i] = slotData.fisheyeFov;
                } else {
                    // Clear unused slots - reset ALL parameters to defaults
                    u[`projTex${i}`].value = defaultTex;
                    u[`shadowMap${i}`].value = defaultShadowTex;
                    u.projLumens.value[i] = 0;
                    // IMPORTANT: Reset lens type to rectilinear (0) to prevent stale fisheye data
                    u.lensParams.value[i].set(0, 0, 0, 0);  // x=0 means rectilinear
                    u.lensParams2.value[i].set(0, 0, 0, 0);
                    u.fisheyeFov.value[i] = 180;
                }
            }
            
            // Configure blending for this pass
            if (isFirstPass) {
                material.transparent = false;
                material.blending = THREE.NormalBlending;
                material.depthWrite = true;
                material.depthTest = true;
                material.depthFunc = THREE.LessEqualDepth;
            } else {
                // Additive pass - blend on top without writing depth
                material.transparent = true;  // Required for additive blending
                material.blending = THREE.AdditiveBlending;
                material.depthWrite = false;
                material.depthTest = true;
                material.depthFunc = THREE.LessEqualDepth;  // LessEqual works better than Equal
            }
            
            material.needsUpdate = true;
        }
        
        // Get all projector slots including array instances for shader
        function getAllProjectorSlots() {
            const slots = [];
            const enabled = state.projectors.filter(p => p.enabled);
            
            enabled.forEach(proj => {
                const instances = getProjectorArrayInstances(proj);
                instances.forEach((instance, index) => {
                    const worldTransform = getArrayInstanceWorldTransform(proj, instance);
                    // Create unique shadow key for each instance
                    // For single projectors (index 0), use projector ID
                    // For array instances, append instance index
                    const shadowKey = instances.length > 1 ? `${proj.id}_inst_${index}` : proj.id;
                    slots.push({
                        projector: proj,
                        instance: instance,
                        worldTransform: worldTransform,
                        shadowKey: shadowKey
                    });
                });
            });
            
            return slots;
        }
        
        function createSurfaceMesh(surface) {
            // Get world transform (respects parent hierarchy)
            const worldTransform = getWorldTransform(surface);
            
            // Skip custom OBJ surfaces - they're handled by createOBJSurfaceMesh
            if (surface.type === 'custom') {
                // Re-parse OBJ data if available
                if (surface.objData) {
                    const loader = new THREE.OBJLoader();
                    const obj = loader.parse(surface.objData);
                    const box = new THREE.Box3().setFromObject(obj);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    createOBJSurfaceMesh(surface, obj, center);
                }
                return;
            }
            
            let geom;
            if (surface.type === 'sphere') {
                // Sphere geometry
                const radius = surface.dimensions.radius || surface.dimensions.width / 2 || 2;
                const segments = surface.segments || 32;
                geom = new THREE.SphereGeometry(radius, segments, segments);
            } else if (surface.type === 'cube') {
                // Cube/Box geometry
                const width = surface.dimensions.width || 2;
                const height = surface.dimensions.height || 2;
                const depth = surface.dimensions.depth || width;
                geom = new THREE.BoxGeometry(width, height, depth, 8, 8, 8);
            } else if (surface.type === 'curved' && surface.curvature > 0) {
                const angle = surface.curvature * Math.PI / 180;
                const radius = surface.dimensions.width / Math.max(angle, 0.01);
                geom = new THREE.CylinderGeometry(radius, radius, surface.dimensions.height, 64, 1, true, Math.PI - angle/2, angle);
            } else {
                geom = new THREE.PlaneGeometry(surface.dimensions.width, surface.dimensions.height, 32, 32);
            }
            
            const mesh = new THREE.Mesh(geom, createSurfaceMaterial(surface));
            mesh.userData.surfaceId = surface.id;
            mesh.userData.surface = surface; // Store reference for coverage calculation
            // Use world transform
            mesh.position.set(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            // Use YXZ order consistently to avoid gimbal lock
            mesh.rotation.order = 'YXZ';
            mesh.rotation.set(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z)
            );
            surfaceGroup.add(mesh);
        }
        
        function updateSurfaceMesh(surface) {
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
            if (mesh) {
                mesh.material.dispose();
                mesh.geometry.dispose();
                surfaceGroup.remove(mesh);
                createSurfaceMesh(surface);
            }
            
            // Also update children of this surface
            const children = getChildren(surface.id);
            children.forEach(child => {
                if (child.type === 'projector') {
                    updateProjectorMesh(child.obj);
                } else if (child.type === 'surface') {
                    updateSurfaceMesh(child.obj);
                }
            });
            
            // Re-render shadow maps since surface geometry/position changed
            updateAllSurfaceMaterials();
            calculateCoverage();
        }
        
        function updateAllSurfaceMaterials() {
            state.projectors.forEach(p => {
                if (!p.customTextureUrl) {
                    projectionTextures.set(p.id, createPatternTexture(state.currentPattern));
                }
            });
            
            // Always render shadow maps for physically accurate occlusion
            renderAllShadowMaps();
            
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (mesh) {
                    mesh.material.dispose();
                    mesh.material = createSurfaceMaterial(surface);
                }
            });
            
            // Update distance helpers if enabled
            if (state.displayOptions.distance) {
                updateDistanceHelpers();
            }
        }
        
        function removeSurface(id) {
            // Orphan any children (projectors or surfaces that have this as parent)
            state.projectors.forEach(p => {
                if (p.parentId === id) {
                    p.parentId = null;
                    updateProjectorMesh(p);
                }
            });
            state.surfaces.forEach(s => {
                if (s.parentId === id) {
                    s.parentId = null;
                    updateSurfaceMesh(s);
                }
            });
            
            state.surfaces = state.surfaces.filter(s => s.id !== id);
            const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
            if (mesh) { mesh.material.dispose(); mesh.geometry.dispose(); surfaceGroup.remove(mesh); }
            if (state.selectedType === 'surface' && state.selectedObject === id) {
                state.selectedObject = null; state.selectedType = null; updatePropertiesPanel();
            }
            // Re-render shadow maps since surface no longer blocks light
            updateAllSurfaceMaterials();
            updateProjectorList(); updateSurfaceList(); updateStatus(); calculateCoverage();
        }
        
        function updateSurfaceList() {
            const list = document.getElementById('surface-list');
            document.getElementById('surface-count').textContent = state.surfaces.length;
            
            if (state.surfaces.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No surfaces yet.</p></div>';
                return;
            }
            
            list.innerHTML = state.surfaces.map(s => {
                let typeInfo;
                if (s.type === 'custom') {
                    typeInfo = `Custom OBJ â€¢ Scale ${(s.scale || 1.0).toFixed(1)}Ã—`;
                } else if (s.type === 'sphere') {
                    const radius = s.dimensions.radius || s.dimensions.width / 2 || 2;
                    typeInfo = `Sphere â€¢ r=${radius.toFixed(1)}m â€¢ Gain ${s.gain}`;
                } else if (s.type === 'cube') {
                    const depth = s.dimensions.depth || s.dimensions.width;
                    typeInfo = `Cube â€¢ ${s.dimensions.width.toFixed(1)}Ã—${s.dimensions.height.toFixed(1)}Ã—${depth.toFixed(1)}m â€¢ Gain ${s.gain}`;
                } else {
                    typeInfo = `${s.dimensions.width.toFixed(1)}m Ã— ${s.dimensions.height.toFixed(1)}m â€¢ Gain ${s.gain}`;
                }
                
                const parentInfo = s.parentId ? ' âŠ‚' : '';  // Symbol to indicate it has a parent
                
                let icon;
                if (s.type === 'custom') {
                    icon = `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>`;
                } else if (s.type === 'sphere') {
                    icon = `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><ellipse cx="12" cy="12" rx="10" ry="4" fill="none" stroke="currentColor" stroke-width="1"/><path d="M12 2v20" stroke="currentColor" stroke-width="1"/></svg>`;
                } else if (s.type === 'cube') {
                    icon = `<svg viewBox="0 0 24 24"><path d="M21 16.5c0 .38-.21.71-.53.88l-7.9 4.44c-.16.12-.36.18-.57.18-.21 0-.41-.06-.57-.18l-7.9-4.44A.991.991 0 013 16.5v-9c0-.38.21-.71.53-.88l7.9-4.44c.16-.12.36-.18.57-.18.21 0 .41.06.57.18l7.9 4.44c.32.17.53.5.53.88v9zM12 4.15L5 8.09v7.82l7 3.94l7-3.94V8.09l-7-3.94z"/></svg>`;
                } else {
                    icon = `<svg viewBox="0 0 24 24"><path d="M20 6H4c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"/></svg>`;
                }
                
                return `
                <div class="object-item ${state.selectedType === 'surface' && state.selectedObject === s.id ? 'selected' : ''}" onclick="selectObject('surface', ${s.id})" style="${s.parentId ? 'padding-left: 28px;' : ''}">
                    <div class="object-icon surface">${icon}</div>
                    <div class="object-info">
                        <div class="object-name">${s.name}${parentInfo}</div>
                        <div class="object-type">${typeInfo}</div>
                    </div>
                    <div class="object-actions">
                        <button class="icon-btn danger" onclick="event.stopPropagation(); removeSurface(${s.id})"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                    </div>
                </div>`;
            }).join('');
        }
        
        // ==========================================
        // COVERAGE CALCULATION - PROPER IMPLEMENTATION
        // ==========================================
        
        function calculateCoverage() {
            if (state.surfaces.length === 0 || state.projectors.filter(p => p.enabled).length === 0) {
                updateCoverageDisplay(0, 0, 0, 0);
                return;
            }
            
            let totalSamples = 0;
            let coveredSamples = 0;
            let totalCdm2 = 0;
            let minCdm2 = Infinity;
            let maxCdm2 = 0;
            let cdm2Samples = [];
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            
            // Sample each surface using actual geometry
            state.surfaces.forEach(surface => {
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (!mesh || !mesh.geometry) return;
                
                // Update matrix world to ensure accurate transforms
                mesh.updateMatrixWorld(true);
                
                const geometry = mesh.geometry;
                const positionAttr = geometry.attributes.position;
                const normalAttr = geometry.attributes.normal;
                
                if (!positionAttr) return;
                
                // For accuracy, sample at vertex positions and face centers
                const sampledPoints = [];
                
                // Sample vertices
                const vertexStride = Math.max(1, Math.floor(positionAttr.count / 200)); // Limit to ~200 vertices
                for (let i = 0; i < positionAttr.count; i += vertexStride) {
                    const localPos = new THREE.Vector3(
                        positionAttr.getX(i),
                        positionAttr.getY(i),
                        positionAttr.getZ(i)
                    );
                    
                    let localNormal;
                    if (normalAttr) {
                        localNormal = new THREE.Vector3(
                            normalAttr.getX(i),
                            normalAttr.getY(i),
                            normalAttr.getZ(i)
                        );
                    } else {
                        localNormal = new THREE.Vector3(0, 0, 1);
                    }
                    
                    sampledPoints.push({ pos: localPos, normal: localNormal });
                }
                
                // Also sample face centers for indexed geometry
                if (geometry.index) {
                    const indices = geometry.index.array;
                    const faceStride = Math.max(3, Math.floor(indices.length / 300) * 3); // Limit to ~100 faces
                    
                    for (let i = 0; i < indices.length; i += faceStride) {
                        if (i + 2 >= indices.length) break;
                        
                        const i0 = indices[i], i1 = indices[i + 1], i2 = indices[i + 2];
                        
                        const p0 = new THREE.Vector3(positionAttr.getX(i0), positionAttr.getY(i0), positionAttr.getZ(i0));
                        const p1 = new THREE.Vector3(positionAttr.getX(i1), positionAttr.getY(i1), positionAttr.getZ(i1));
                        const p2 = new THREE.Vector3(positionAttr.getX(i2), positionAttr.getY(i2), positionAttr.getZ(i2));
                        
                        // Face center
                        const center = new THREE.Vector3().addVectors(p0, p1).add(p2).divideScalar(3);
                        
                        // Face normal (computed from vertices)
                        const edge1 = new THREE.Vector3().subVectors(p1, p0);
                        const edge2 = new THREE.Vector3().subVectors(p2, p0);
                        const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                        
                        sampledPoints.push({ pos: center, normal: faceNormal });
                    }
                }
                
                // Process each sample point
                sampledPoints.forEach(sample => {
                    // Transform to world space
                    const worldPos = sample.pos.clone().applyMatrix4(mesh.matrixWorld);
                    
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    const worldNormal = sample.normal.clone().applyMatrix3(normalMatrix).normalize();
                    
                    totalSamples++;
                    let sampleCdm2 = 0;
                    let isHit = false;
                    
                    enabledProjectors.forEach(proj => {
                        const data = projectorMatrixData.get(proj.id);
                        const shadowData = shadowMaps.get(proj.id);
                        if (!data) return;
                        
                        // Check if point is within projector frustum
                        const projCoord = new THREE.Vector4(worldPos.x, worldPos.y, worldPos.z, 1);
                        projCoord.applyMatrix4(data.matrix);
                        
                        if (projCoord.w <= 0) return;
                        
                        const ndc = new THREE.Vector3(
                            projCoord.x / projCoord.w,
                            projCoord.y / projCoord.w,
                            projCoord.z / projCoord.w
                        );
                        
                        const uv = new THREE.Vector2(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
                        
                        if (uv.x < 0 || uv.x > 1 || uv.y < 0 || uv.y > 1) return;
                        if (ndc.z < -1 || ndc.z > 1) return;
                        
                        // Check facing - surface must face the projector
                        const toProj = new THREE.Vector3().subVectors(data.position, worldPos).normalize();
                        const facing = worldNormal.dot(toProj);
                        if (facing <= 0) return;
                        
                        // Shadow occlusion check - sample shadow map
                        // This mirrors the shader logic
                        if (shadowData && shadowData.renderTarget) {
                            const fragDepthNormalized = ndc.z * 0.5 + 0.5;
                            
                            // Read shadow map at this UV (approximation - we use a raycast instead for CPU accuracy)
                            // For better accuracy, cast a ray from projector to point and check for intersections
                            const rayOrigin = data.position.clone();
                            const rayDir = new THREE.Vector3().subVectors(worldPos, rayOrigin).normalize();
                            const distToPoint = data.position.distanceTo(worldPos);
                            
                            const shadowRay = new THREE.Raycaster(rayOrigin, rayDir, 0.01, distToPoint - 0.01);
                            const intersects = shadowRay.intersectObjects(surfaceGroup.children, false);
                            
                            // If ray hits something before reaching this point, it's occluded
                            if (intersects.length > 0) {
                                const hitDist = intersects[0].distance;
                                if (hitDist < distToPoint - 0.05) {
                                    return; // Occluded by another surface
                                }
                            }
                        }
                        
                        isHit = true;
                        
                        // Calculate luminance in cd/mÂ²
                        const dist = data.position.distanceTo(worldPos);
                        const projWidth = dist / data.throwRatio;
                        const projHeight = projWidth / proj.aspectRatio;
                        const projArea = projWidth * projHeight;
                        const lux = data.lumens / projArea;
                        const cdm2 = (lux * surface.gain / Math.PI) * facing;
                        
                        sampleCdm2 += cdm2;
                    });
                    
                    if (isHit) {
                        coveredSamples++;
                        cdm2Samples.push(sampleCdm2);
                        totalCdm2 += sampleCdm2;
                        minCdm2 = Math.min(minCdm2, sampleCdm2);
                        maxCdm2 = Math.max(maxCdm2, sampleCdm2);
                    }
                });
            });
            
            const coverage = totalSamples > 0 ? (coveredSamples / totalSamples) * 100 : 0;
            const avgCdm2 = cdm2Samples.length > 0 ? totalCdm2 / cdm2Samples.length : 0;
            
            updateCoverageDisplay(
                coverage,
                avgCdm2,
                minCdm2 === Infinity ? 0 : minCdm2,
                maxCdm2
            );
        }
        
        function updateCoverageDisplay(coverage, avgCdm2, minCdm2, maxCdm2) {
            document.getElementById('coverage-fill').style.width = coverage + '%';
            document.getElementById('coverage-percent').textContent = coverage.toFixed(1) + '%';
            document.getElementById('avg-cdm2').textContent = Math.round(avgCdm2).toLocaleString();
            document.getElementById('min-cdm2').textContent = Math.round(minCdm2).toLocaleString();
            document.getElementById('max-cdm2').textContent = Math.round(maxCdm2).toLocaleString();
        }
        
        // ==========================================
        // SELECTION & PROPERTIES
        // ==========================================
        
        function selectObject(type, id) {
            state.selectedType = type;
            state.selectedObject = id;
            updateProjectorList();
            updateSurfaceList();
            updatePropertiesPanel();
            
            // Enable/disable transform tools based on selection
            enableTransformTools(!!id);
            
            // Update gizmo position (gizmo visibility depends on current mode)
            updateGizmoPosition();
        }
        
        function buildTextureControlsHtml(p) {
            const videoData = videoTextureData.get(p.id);
            
            if (p.customTextureType === 'video' && videoData) {
                // Video controls
                const duration = videoData.video.duration || 0;
                const currentTime = videoData.video.currentTime || 0;
                const isPlaying = videoData.playing;
                const isLooping = videoData.loop;
                const resolution = videoData.resolution || 'native';
                const nativeRes = `${videoData.nativeWidth}Ã—${videoData.nativeHeight}`;
                
                return `
                    <div class="video-preview">
                        <div class="video-info">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>
                            <span>Video (${nativeRes})</span>
                        </div>
                        <div class="video-controls">
                            <button class="video-btn" onclick="${isPlaying ? 'pauseVideo' : 'playVideo'}(${p.id})" title="${isPlaying ? 'Pause' : 'Play'}">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                    ${isPlaying 
                                        ? '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>' 
                                        : '<path d="M8 5v14l11-7z"/>'}
                                </svg>
                            </button>
                            <button class="video-btn" onclick="restartVideo(${p.id})" title="Restart">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                            </button>
                            <button class="video-btn ${isLooping ? 'active' : ''}" onclick="toggleVideoLoop(${p.id})" title="Loop">
                                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
                            </button>
                        </div>
                        <div class="video-seek">
                            <input type="range" min="0" max="${duration}" step="0.1" value="${currentTime}" 
                                oninput="seekVideo(${p.id}, +this.value)" 
                                style="width: 100%;">
                            <div class="video-time">${formatTime(currentTime)} / ${formatTime(duration)}</div>
                        </div>
                        <div class="property-row" style="margin-top: 8px;">
                            <span class="property-label">Quality</span>
                            <div class="single-input">
                                <select onchange="updateVideoResolution(${p.id}, this.value)">
                                    <option value="native" ${resolution === 'native' ? 'selected' : ''}>Native (${nativeRes})</option>
                                    <option value="1080p" ${resolution === '1080p' ? 'selected' : ''}>1080p</option>
                                    <option value="720p" ${resolution === '720p' ? 'selected' : ''}>720p</option>
                                    <option value="480p" ${resolution === '480p' ? 'selected' : ''}>480p</option>
                                    <option value="360p" ${resolution === '360p' ? 'selected' : ''}>360p</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <button class="btn clear-texture-btn" onclick="clearCustomTexture(${p.id})">Clear Video</button>
                `;
            } else if (p.customTextureUrl && p.customTextureType !== 'video') {
                // Image preview
                return `
                    <div class="texture-preview" style="background-image: url('${p.customTextureUrl}')"></div>
                    <button class="btn clear-texture-btn" onclick="clearCustomTexture(${p.id})">Clear Image</button>
                `;
            } else {
                // Upload prompt
                return `
                    <div class="texture-upload" onclick="document.getElementById('tex-upload-${p.id}').click()">
                        <input type="file" id="tex-upload-${p.id}" accept="image/*,video/*" onchange="loadCustomTexture(${p.id}, this.files[0])">
                        <p>Click to upload image or video</p>
                    </div>
                `;
            }
        }
        
        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-panel');
            
            if (!state.selectedObject) {
                panel.innerHTML = `<div class="no-selection"><div class="no-selection-icon"><svg viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg></div><h3>No Selection</h3><p>Select an object to edit.</p></div>`;
                return;
            }
            
            if (state.selectedType === 'projector') {
                const p = state.projectors.find(x => x.id === state.selectedObject);
                if (!p) return;
                
                const presetOptions = Object.entries(projectorPresets).map(([key, val]) => 
                    `<option value="${key}" ${p.preset === key ? 'selected' : ''}>${val.name}</option>`
                ).join('');
                
                // Build parent options
                const parentOptions = getParentOptions('projector', p.id);
                const parentOptionsHtml = parentOptions.map(opt => 
                    `<option value="${opt.id || ''}" ${p.parentId === opt.id ? 'selected' : ''}>${opt.name}${opt.type ? ` (${opt.type})` : ''}</option>`
                ).join('');
                
                // Array settings
                const hasArray = p.array && p.array.count > 1;
                const arrayCount = p.array?.count || 2;
                const arraySpacingX = p.array?.spacing?.x || 2;
                const arraySpacingY = p.array?.spacing?.y || 0;
                const arraySpacingZ = p.array?.spacing?.z || 0;
                const arrayRotX = p.array?.rotationOffset?.x || 0;
                const arrayRotY = p.array?.rotationOffset?.y || 0;
                const arrayRotZ = p.array?.rotationOffset?.z || 0;
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Projector</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${p.name}" onchange="updateProjectorProp(${p.id}, 'name', this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Preset</span><div class="single-input"><select onchange="applyPreset(${p.id}, this.value)">${presetOptions}</select></div></div>
                            <div class="property-row"><span class="property-label">Parent</span><div class="single-input"><select onchange="updateParent(${p.id}, 'projector', this.value || null)">${parentOptionsHtml}</select></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Projector Array</div>
                            <div class="toggle-row"><span class="toggle-label">Enable Array</span><div class="toggle ${hasArray ? 'active' : ''}" onclick="toggleProjectorArray(${p.id})"></div></div>
                            ${hasArray ? `
                            <div class="property-row"><span class="property-label">Count</span><div class="single-input"><input type="number" step="1" min="2" max="20" value="${arrayCount}" onchange="updateArrayProp(${p.id}, 'count', +this.value)" style="width: 60px;"></div></div>
                            <div class="property-row"><span class="property-label">Spacing (m)</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${arraySpacingX}" onchange="updateArrayProp(${p.id}, 'spacingX', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${arraySpacingY}" onchange="updateArrayProp(${p.id}, 'spacingY', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${arraySpacingZ}" onchange="updateArrayProp(${p.id}, 'spacingZ', +this.value)"></div>
                                </div>
                            </div>
                            <div class="property-row"><span class="property-label">Rot Offset (Â°)</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${arrayRotX}" onchange="updateArrayProp(${p.id}, 'rotX', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${arrayRotY}" onchange="updateArrayProp(${p.id}, 'rotY', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${arrayRotZ}" onchange="updateArrayProp(${p.id}, 'rotZ', +this.value)"></div>
                                </div>
                            </div>
                            <button class="btn btn-sm btn-primary" style="width: 100%; margin-top: 8px;" onclick="convertArrayToProjectors(${p.id})">Create ${arrayCount} Projectors</button>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Creates ${arrayCount} individual projectors from array</p>
                            ` : `<p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Enable to create evenly-spaced projector copies</p>`}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)${p.parentId ? ' <span style="color: var(--accent-color); font-size: 9px;">LOCAL</span>' : ''}</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${p.position.x.toFixed(2)}" onchange="updateProjectorPos(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${p.position.y.toFixed(2)}" onchange="updateProjectorPos(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${p.position.z.toFixed(2)}" onchange="updateProjectorPos(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)${p.parentId ? ' <span style="color: var(--accent-color); font-size: 9px;">LOCAL</span>' : ''}</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${p.rotation.x.toFixed(1)}" onchange="updateProjectorRot(${p.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${p.rotation.y.toFixed(1)}" onchange="updateProjectorRot(${p.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${p.rotation.z.toFixed(1)}" onchange="updateProjectorRot(${p.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Optics</div>
                            <div class="slider-row"><span class="slider-label">Throw Ratio</span><div class="slider-container"><input type="range" class="slider" min="0.3" max="3" step="0.05" value="${p.throwRatio}" oninput="updateProjectorProp(${p.id}, 'throwRatio', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.05" min="0.3" max="3" value="${p.throwRatio.toFixed(2)}" onchange="updateProjectorProp(${p.id}, 'throwRatio', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Zoom</span><div class="slider-container"><input type="range" class="slider" min="0.8" max="1.5" step="0.01" value="${p.zoom}" oninput="updateProjectorProp(${p.id}, 'zoom', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="0.8" max="1.5" value="${p.zoom.toFixed(2)}" onchange="updateProjectorProp(${p.id}, 'zoom', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="property-row"><span class="property-label">Lumens</span><div class="single-input"><input type="number" step="1000" value="${p.lumens}" onchange="updateProjectorProp(${p.id}, 'lumens', +this.value)"></div></div>
                            <div class="slider-row"><span class="slider-label">Brightness (%)</span><div class="slider-container"><input type="range" class="slider" min="0" max="100" step="5" value="${p.brightness || 100}" oninput="updateProjectorProp(${p.id}, 'brightness', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="5" min="0" max="100" value="${p.brightness || 100}" onchange="updateProjectorProp(${p.id}, 'brightness', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="property-row"><span class="property-label">Stack Qty</span><div class="single-input"><input type="number" step="1" min="1" max="10" value="${p.stack || 1}" onchange="updateProjectorProp(${p.id}, 'stack', +this.value)" style="width: 60px;"></div></div>
                            <div class="property-row" style="font-size: 10px; color: var(--text-muted); margin-top: -4px;"><span>Effective: ${Math.round(p.lumens * (p.brightness || 100) / 100 * (p.stack || 1))} lm</span></div>
                            <div class="property-row"><span class="property-label">Resolution</span><div class="single-input"><input type="text" value="${p.resolution || '1920Ã—1080'}" readonly style="opacity: 0.6;"></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Lens Shift</div>
                            <div class="slider-row"><span class="slider-label">Horizontal (%)</span><div class="slider-container"><input type="range" class="slider" min="-100" max="100" step="1" value="${p.lens?.shiftH || 0}" oninput="updateLensShift(${p.id}, 'shiftH', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="-100" max="100" value="${p.lens?.shiftH || 0}" onchange="updateLensShift(${p.id}, 'shiftH', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Vertical (%)</span><div class="slider-container"><input type="range" class="slider" min="-100" max="100" step="1" value="${p.lens?.shiftV || 0}" oninput="updateLensShift(${p.id}, 'shiftV', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="-100" max="100" value="${p.lens?.shiftV || 0}" onchange="updateLensShift(${p.id}, 'shiftV', +this.value); this.previousElementSibling.value=this.value"></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Lens Model</div>
                            <div class="property-row"><span class="property-label">Lens Type</span><div class="single-input"><select onchange="updateLensProp(${p.id}, 'type', this.value)">
                                <option value="rectilinear" ${(p.lens?.type || 'rectilinear') === 'rectilinear' ? 'selected' : ''}>Rectilinear (Standard)</option>
                                <option value="fisheye_equidistant" ${p.lens?.type === 'fisheye_equidistant' ? 'selected' : ''}>Fisheye - Equidistant</option>
                                <option value="fisheye_equisolid" ${p.lens?.type === 'fisheye_equisolid' ? 'selected' : ''}>Fisheye - Equisolid</option>
                                <option value="fisheye_stereographic" ${p.lens?.type === 'fisheye_stereographic' ? 'selected' : ''}>Fisheye - Stereographic</option>
                                <option value="fisheye_orthographic" ${p.lens?.type === 'fisheye_orthographic' ? 'selected' : ''}>Fisheye - Orthographic</option>
                            </select></div></div>
                            ${(p.lens?.type && p.lens.type.startsWith('fisheye')) ? `<div class="slider-row"><span class="slider-label">Fisheye FOV (Â°)</span><div class="slider-container"><input type="range" class="slider" min="90" max="220" step="5" value="${p.lens?.fisheyeFov || 180}" oninput="updateLensProp(${p.id}, 'fisheyeFov', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="5" min="90" max="220" value="${p.lens?.fisheyeFov || 180}" onchange="updateLensProp(${p.id}, 'fisheyeFov', +this.value); this.previousElementSibling.value=this.value"></div></div>` : ''}
                            <div class="slider-row"><span class="slider-label">Barrel/Pincushion (K1)</span><div class="slider-container"><input type="range" class="slider" min="-0.5" max="0.5" step="0.01" value="${p.lens?.k1 || 0}" oninput="updateLensProp(${p.id}, 'k1', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="-0.5" max="0.5" value="${(p.lens?.k1 || 0).toFixed(2)}" onchange="updateLensProp(${p.id}, 'k1', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Radial K2</span><div class="slider-container"><input type="range" class="slider" min="-0.3" max="0.3" step="0.01" value="${p.lens?.k2 || 0}" oninput="updateLensProp(${p.id}, 'k2', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="-0.3" max="0.3" value="${(p.lens?.k2 || 0).toFixed(2)}" onchange="updateLensProp(${p.id}, 'k2', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Radial K3</span><div class="slider-container"><input type="range" class="slider" min="-0.2" max="0.2" step="0.01" value="${p.lens?.k3 || 0}" oninput="updateLensProp(${p.id}, 'k3', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(2)"><input type="number" class="slider-input" step="0.01" min="-0.2" max="0.2" value="${(p.lens?.k3 || 0).toFixed(2)}" onchange="updateLensProp(${p.id}, 'k3', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Tangential P1</span><div class="slider-container"><input type="range" class="slider" min="-0.1" max="0.1" step="0.001" value="${p.lens?.p1 || 0}" oninput="updateLensProp(${p.id}, 'p1', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(3)"><input type="number" class="slider-input" step="0.001" min="-0.1" max="0.1" value="${(p.lens?.p1 || 0).toFixed(3)}" onchange="updateLensProp(${p.id}, 'p1', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <div class="slider-row"><span class="slider-label">Tangential P2</span><div class="slider-container"><input type="range" class="slider" min="-0.1" max="0.1" step="0.001" value="${p.lens?.p2 || 0}" oninput="updateLensProp(${p.id}, 'p2', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(3)"><input type="number" class="slider-input" step="0.001" min="-0.1" max="0.1" value="${(p.lens?.p2 || 0).toFixed(3)}" onchange="updateLensProp(${p.id}, 'p2', +this.value); this.previousElementSibling.value=this.value"></div></div>
                            <button class="btn btn-sm" style="width: 100%; margin-top: 8px;" onclick="resetLensParams(${p.id})">Reset Lens to Default</button>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">K1-K3: Radial distortion. P1-P2: Tangential.</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Body Mesh</div>
                            <div class="property-row"><span class="property-label">Size (m)</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>W</label><input type="number" step="0.05" min="0.05" value="${(p.body?.width || 0.4).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'width', +this.value)"></div>
                                    <div class="input-group"><label>H</label><input type="number" step="0.05" min="0.05" value="${(p.body?.height || 0.2).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'height', +this.value)"></div>
                                    <div class="input-group"><label>D</label><input type="number" step="0.05" min="0.05" value="${(p.body?.depth || 0.5).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'depth', +this.value)"></div>
                                </div>
                            </div>
                            <div class="property-row"><span class="property-label">Offset (m)</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.05" value="${(p.body?.offsetX || 0).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'offsetX', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.05" value="${(p.body?.offsetY || 0).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'offsetY', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.05" value="${(p.body?.offsetZ || 0).toFixed(2)}" onchange="updateBodyProp(${p.id}, 'offsetZ', +this.value)"></div>
                                </div>
                            </div>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Offset is relative to projection origin (lens center)</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Custom Texture</div>
                            ${buildTextureControlsHtml(p)}
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Range</div>
                            <div class="slider-row"><span class="slider-label">Max Distance</span><div class="slider-container"><input type="range" class="slider" min="10" max="500" step="5" value="${p.farPlane || 100}" oninput="updateProjectorProp(${p.id}, 'farPlane', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="5" min="10" max="500" value="${p.farPlane || 100}" onchange="updateProjectorProp(${p.id}, 'farPlane', +this.value); this.previousElementSibling.value=this.value">m</div></div>
                            <div class="slider-row"><span class="slider-label">Frustum Display</span><div class="slider-container"><input type="range" class="slider" min="5" max="100" step="1" value="${p.frustumDistance || 20}" oninput="updateProjectorProp(${p.id}, 'frustumDistance', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="5" max="100" value="${p.frustumDistance || 20}" onchange="updateProjectorProp(${p.id}, 'frustumDistance', +this.value); this.previousElementSibling.value=this.value">m</div></div>
                            <p style="font-size: 10px; color: #666; margin: 4px 0 0 0;">Max Distance affects shadow occlusion range</p>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Display</div>
                            <div class="toggle-row"><span class="toggle-label">Enabled</span><div class="toggle ${p.enabled ? 'active' : ''}" onclick="toggleProjectorEnabled(${p.id})"></div></div>
                        </div>
                    </div></div>`;
            } else if (state.selectedType === 'surface') {
                const s = state.surfaces.find(x => x.id === state.selectedObject);
                if (!s) return;
                
                const isCustomOBJ = s.type === 'custom';
                
                // Build parent options
                const parentOptions = getParentOptions('surface', s.id);
                const parentOptionsHtml = parentOptions.map(opt => 
                    `<option value="${opt.id || ''}" ${s.parentId === opt.id ? 'selected' : ''}>${opt.name}${opt.type ? ` (${opt.type})` : ''}</option>`
                ).join('');
                
                // Build type selector HTML (hidden for custom OBJ)
                const typeHtml = isCustomOBJ 
                    ? `<div class="property-row"><span class="property-label">Type</span><div class="single-input"><input type="text" value="Custom OBJ" disabled style="opacity: 0.6"></div></div>`
                    : `<div class="property-row"><span class="property-label">Type</span><div class="single-input"><select onchange="updateSurfaceProp(${s.id}, 'type', this.value)"><option value="flat" ${s.type==='flat'?'selected':''}>Flat</option><option value="curved" ${s.type==='curved'?'selected':''}>Curved</option><option value="sphere" ${s.type==='sphere'?'selected':''}>Sphere</option><option value="cube" ${s.type==='cube'?'selected':''}>Cube</option></select></div></div>`;
                
                // Build dimensions HTML (scale for OBJ, type-specific for others)
                let dimensionsHtml;
                if (isCustomOBJ) {
                    const scale = s.scale || 1.0;
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Scale</div>
                            <div class="slider-row"><span class="slider-label">Uniform Scale</span><div class="slider-container"><input type="range" class="slider" min="0.1" max="5" step="0.1" value="${scale}" oninput="updateSurfaceScale(${s.id}, +this.value); this.nextElementSibling.value=Number(this.value).toFixed(1)"><input type="number" class="slider-input" step="0.1" min="0.1" max="10" value="${scale.toFixed(1)}" onchange="updateSurfaceScale(${s.id}, +this.value); this.previousElementSibling.value=this.value">Ã—</div></div>
                            <div class="property-row" style="opacity: 0.6"><span class="property-label">Original Size</span><div class="single-input"><input type="text" value="${s.dimensions.width.toFixed(1)}m Ã— ${s.dimensions.height.toFixed(1)}m" disabled></div></div>
                        </div>`;
                } else if (s.type === 'sphere') {
                    const radius = s.dimensions.radius || s.dimensions.width / 2 || 2;
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Radius (m)</span><div class="single-input"><input type="number" step="0.1" min="0.1" value="${radius}" onchange="updateSurfaceDim(${s.id}, 'radius', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Segments</span><div class="single-input"><input type="number" step="4" min="8" max="128" value="${s.segments || 32}" onchange="updateSurfaceProp(${s.id}, 'segments', +this.value)"></div></div>
                        </div>`;
                } else if (s.type === 'cube') {
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Width (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'width', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Height (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.height}" onchange="updateSurfaceDim(${s.id}, 'height', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Depth (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.depth || s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'depth', +this.value)"></div></div>
                        </div>`;
                } else {
                    dimensionsHtml = `
                        <div class="property-group">
                            <div class="property-group-title">Dimensions</div>
                            <div class="property-row"><span class="property-label">Width (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.width}" onchange="updateSurfaceDim(${s.id}, 'width', +this.value)"></div></div>
                            <div class="property-row"><span class="property-label">Height (m)</span><div class="single-input"><input type="number" step="0.1" value="${s.dimensions.height}" onchange="updateSurfaceDim(${s.id}, 'height', +this.value)"></div></div>
                            ${s.type === 'curved' ? `<div class="slider-row"><span class="slider-label">Curvature</span><div class="slider-container"><input type="range" class="slider" min="5" max="180" value="${s.curvature}" oninput="updateSurfaceProp(${s.id}, 'curvature', +this.value); this.nextElementSibling.value=this.value"><input type="number" class="slider-input" step="1" min="5" max="180" value="${s.curvature}" onchange="updateSurfaceProp(${s.id}, 'curvature', +this.value); this.previousElementSibling.value=this.value">Â°</div></div>` : ''}
                        </div>`;
                }
                
                panel.innerHTML = `
                    <div class="panel-section"><div class="panel-header"><span class="panel-title">Surface</span></div>
                    <div class="panel-content">
                        <div class="property-group">
                            <div class="property-group-title">General</div>
                            <div class="property-row"><span class="property-label">Name</span><div class="single-input"><input type="text" value="${s.name}" onchange="updateSurfaceProp(${s.id}, 'name', this.value)"></div></div>
                            ${typeHtml}
                            <div class="property-row"><span class="property-label">Parent</span><div class="single-input"><select onchange="updateParent(${s.id}, 'surface', this.value || null)">${parentOptionsHtml}</select></div></div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Position (meters)${s.parentId ? ' <span style="color: var(--accent-color); font-size: 9px;">LOCAL</span>' : ''}</div>
                            <div class="property-row"><span class="property-label">Position</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="0.1" value="${s.position.x.toFixed(2)}" onchange="updateSurfacePos(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="0.1" value="${s.position.y.toFixed(2)}" onchange="updateSurfacePos(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="0.1" value="${s.position.z.toFixed(2)}" onchange="updateSurfacePos(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <div class="property-group-title">Rotation (degrees)${s.parentId ? ' <span style="color: var(--accent-color); font-size: 9px;">LOCAL</span>' : ''}</div>
                            <div class="property-row"><span class="property-label">Rotation</span>
                                <div class="property-inputs">
                                    <div class="input-group"><label>X</label><input type="number" step="1" value="${s.rotation.x.toFixed(1)}" onchange="updateSurfaceRot(${s.id}, 'x', +this.value)"></div>
                                    <div class="input-group"><label>Y</label><input type="number" step="1" value="${s.rotation.y.toFixed(1)}" onchange="updateSurfaceRot(${s.id}, 'y', +this.value)"></div>
                                    <div class="input-group"><label>Z</label><input type="number" step="1" value="${s.rotation.z.toFixed(1)}" onchange="updateSurfaceRot(${s.id}, 'z', +this.value)"></div>
                                </div>
                            </div>
                        </div>
                        ${dimensionsHtml}
                        <div class="property-group">
                            <div class="property-group-title">Screen Properties</div>
                            <div class="slider-row"><span class="slider-label">Screen Gain</span><div class="slider-container"><input type="range" class="slider" min="0.5" max="2.5" step="0.1" value="${s.gain}" oninput="updateSurfaceProp(${s.id}, 'gain', +this.value); this.nextElementSibling.value=Number(this.value).toFixed(1)"><input type="number" class="slider-input" step="0.1" min="0.5" max="2.5" value="${s.gain.toFixed(1)}" onchange="updateSurfaceProp(${s.id}, 'gain', +this.value); this.previousElementSibling.value=this.value"></div></div>
                        </div>
                    </div></div>`;
            }
        }
        
        // ==========================================
        // PROPERTY HANDLERS
        // ==========================================
        // PROPERTY HANDLERS WITH VALIDATION
        // ==========================================
        
        function updateProjectorProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Validate numeric properties
                if (prop === 'lumens') val = Math.max(100, Math.min(100000, val));
                if (prop === 'throwRatio') val = Math.max(0.3, Math.min(10, val));
                if (prop === 'zoom') val = Math.max(0.5, Math.min(2, val));
                
                p[prop] = val;
                if (prop !== 'name') p.preset = 'custom';
                updateProjectorMesh(p);
                updateProjectorList();
            }
        }
        
        function updateProjectorPos(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                saveStateForUndo(`Move ${p.name} (panel)`);
                p.position[axis] = val;
                updateProjectorMesh(p);
                updateGizmoPosition();  // Update gizmo to follow moved object
            }
        }
        
        function updateProjectorRot(id, axis, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                saveStateForUndo(`Rotate ${p.name} (panel)`);
                p.rotation[axis] = val;
                updateProjectorMesh(p);
                updateGizmoPosition();  // Update gizmo to follow rotated object
            }
        }
        
        // Update parent for projector or surface - preserves world position
        function updateParent(id, type, parentId) {
            const obj = type === 'projector' 
                ? state.projectors.find(x => x.id === id)
                : state.surfaces.find(x => x.id === id);
            
            if (!obj) return;
            
            // Convert empty string to null
            const newParentId = parentId === '' ? null : (typeof parentId === 'string' ? parseInt(parentId) : parentId);
            
            // Get current world transform before changing parent
            const currentWorldTransform = getWorldTransform(obj);
            
            // Set new parent
            obj.parentId = newParentId;
            
            // Calculate local transform that preserves world position
            if (newParentId) {
                const parent = getObjectById(newParentId);
                if (parent) {
                    const parentWorld = getWorldTransform(parent.obj);
                    const localTransform = worldToLocalTransform(currentWorldTransform, parentWorld);
                    obj.position = localTransform.position;
                    obj.rotation = localTransform.rotation;
                }
            } else {
                // No parent - local = world
                obj.position = { ...currentWorldTransform.position };
                obj.rotation = { ...currentWorldTransform.rotation };
            }
            
            // Update mesh with new world transform
            if (type === 'projector') {
                updateProjectorMesh(obj);
            } else {
                updateSurfaceMesh(obj);
            }
            
            updateProjectorList();
            updateSurfaceList();
            updatePropertiesPanel();
        }
        
        // Convert world transform to local transform given parent's world transform
        function worldToLocalTransform(worldTransform, parentWorld) {
            // Create parent inverse transform
            const parentPos = new THREE.Vector3(parentWorld.position.x, parentWorld.position.y, parentWorld.position.z);
            const parentEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(parentWorld.rotation.x),
                THREE.MathUtils.degToRad(parentWorld.rotation.y),
                THREE.MathUtils.degToRad(parentWorld.rotation.z),
                'YXZ'
            );
            const parentQuat = new THREE.Quaternion().setFromEuler(parentEuler);
            const parentQuatInverse = parentQuat.clone().invert();
            
            // Calculate local position: inverse rotate (worldPos - parentPos)
            const worldPos = new THREE.Vector3(worldTransform.position.x, worldTransform.position.y, worldTransform.position.z);
            const localPos = worldPos.clone().sub(parentPos).applyQuaternion(parentQuatInverse);
            
            // Calculate local rotation: inverse(parentRot) * worldRot
            const worldEuler = new THREE.Euler(
                THREE.MathUtils.degToRad(worldTransform.rotation.x),
                THREE.MathUtils.degToRad(worldTransform.rotation.y),
                THREE.MathUtils.degToRad(worldTransform.rotation.z),
                'YXZ'
            );
            const worldQuat = new THREE.Quaternion().setFromEuler(worldEuler);
            const localQuat = parentQuatInverse.clone().multiply(worldQuat);
            const localEuler = new THREE.Euler().setFromQuaternion(localQuat, 'YXZ');
            
            return {
                position: { x: localPos.x, y: localPos.y, z: localPos.z },
                rotation: {
                    x: THREE.MathUtils.radToDeg(localEuler.x),
                    y: THREE.MathUtils.radToDeg(localEuler.y),
                    z: THREE.MathUtils.radToDeg(localEuler.z)
                }
            };
        }
        
        // Toggle projector array mode
        function toggleProjectorArray(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                if (p.array) {
                    // Disable array
                    p.array = null;
                    updateProjectorMeshWithArray(p);
                } else {
                    // Enable array with defaults
                    p.array = {
                        count: 3,
                        spacing: { x: 2, y: 0, z: 0 },
                        rotationOffset: { x: 0, y: 0, z: 0 }
                    };
                    updateProjectorMeshWithArray(p);
                }
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
            }
        }
        
        // Update array properties
        function updateArrayProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p && p.array) {
                if (prop === 'count') {
                    p.array.count = Math.max(2, Math.min(20, val));
                } else if (prop.startsWith('spacing')) {
                    const axis = prop.replace('spacing', '').toLowerCase();
                    if (!p.array.spacing) p.array.spacing = { x: 0, y: 0, z: 0 };
                    p.array.spacing[axis] = val;
                } else if (prop.startsWith('rot')) {
                    const axis = prop.replace('rot', '').toLowerCase();
                    if (!p.array.rotationOffset) p.array.rotationOffset = { x: 0, y: 0, z: 0 };
                    p.array.rotationOffset[axis] = val;
                }
                
                updateProjectorMeshWithArray(p);
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
            }
        }
        
        function toggleProjectorEnabled(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p.enabled = !p.enabled;
                const mesh = projectorGroup.children.find(c => c.userData.projectorId === id);
                if (mesh) mesh.visible = p.enabled;
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
                calculateCoverage();
            }
        }
        
        function updateLensProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Initialize lens object if needed
                if (!p.lens) {
                    p.lens = {
                        type: 'rectilinear',
                        fisheyeFov: 180,
                        shiftH: 0, shiftV: 0,
                        k1: 0, k2: 0, k3: 0,
                        p1: 0, p2: 0,
                        cx: 0, cy: 0
                    };
                }
                p.lens[prop] = val;
                updateProjectorMatrix(p);
                // Update shadow map when fisheyeFov or type changes (affects shadow frustum)
                if (prop === 'fisheyeFov' || prop === 'type') {
                    updateShadowMap(p);
                }
                updateAllSurfaceMaterials();
                calculateCoverage();
                // Refresh panel when type changes to show/hide fisheyeFov slider
                if (prop === 'type') {
                    updatePropertiesPanel();
                }
            }
        }
        
        function updateLensShift(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                if (!p.lens) {
                    p.lens = {
                        type: 'rectilinear',
                        fisheyeFov: 180,
                        shiftH: 0, shiftV: 0,
                        k1: 0, k2: 0, k3: 0,
                        p1: 0, p2: 0,
                        cx: 0, cy: 0
                    };
                }
                // Store both the percentage value and convert to cx/cy
                p.lens[prop] = val;
                if (prop === 'shiftH') {
                    p.lens.cx = val / 50;  // Convert -100..100% to -2..2 range (for full image shift)
                } else if (prop === 'shiftV') {
                    p.lens.cy = val / 50;
                }
                updateProjectorMatrix(p);
                updateAllSurfaceMaterials();
                calculateCoverage();
            }
        }
        
        function updateBodyProp(id, prop, val) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                // Initialize body object if needed
                if (!p.body) {
                    p.body = {
                        width: 0.4, height: 0.2, depth: 0.5,
                        offsetX: 0, offsetY: 0, offsetZ: 0
                    };
                }
                // Validate dimensions (must be positive)
                if (['width', 'height', 'depth'].includes(prop)) {
                    val = Math.max(0.05, Math.min(5, val));
                }
                // Validate offset (reasonable range)
                if (['offsetX', 'offsetY', 'offsetZ'].includes(prop)) {
                    val = Math.max(-5, Math.min(5, val));
                }
                p.body[prop] = val;
                
                // Rebuild the projector mesh
                rebuildProjectorBody(p);
            }
        }
        
        function rebuildProjectorBody(projector) {
            const mesh = projectorGroup.children.find(c => c.userData.projectorId === projector.id);
            if (!mesh) return;
            
            // Find and remove old body and indicator
            const oldBody = mesh.children.find(c => c.userData.isProjector);
            if (oldBody) {
                if (oldBody.geometry) oldBody.geometry.dispose();
                if (oldBody.material) oldBody.material.dispose();
                mesh.remove(oldBody);
            }
            
            // Remove old indicator (cone without specific userData)
            const oldIndicator = mesh.children.find(c => c.geometry && c.geometry.type === 'ConeGeometry');
            if (oldIndicator) {
                if (oldIndicator.geometry) oldIndicator.geometry.dispose();
                if (oldIndicator.material) oldIndicator.material.dispose();
                mesh.remove(oldIndicator);
            }
            
            // Create new body with updated dimensions
            const bodyW = projector.body?.width || 0.4;
            const bodyH = projector.body?.height || 0.2;
            const bodyD = projector.body?.depth || 0.5;
            const offsetX = projector.body?.offsetX || 0;
            const offsetY = projector.body?.offsetY || 0;
            const offsetZ = projector.body?.offsetZ || 0;
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(bodyW, bodyH, bodyD),
                new THREE.MeshBasicMaterial({ color: 0x444444 })
            );
            body.userData.isProjector = true;
            body.userData.projectorId = projector.id;
            body.position.set(offsetX, offsetY, offsetZ);
            mesh.add(body);
            
            // Create new indicator
            const indicatorSize = Math.min(bodyW, bodyH) * 0.4;
            const indicator = new THREE.Mesh(
                new THREE.ConeGeometry(indicatorSize, indicatorSize * 2.5, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            indicator.rotation.x = Math.PI / 2;
            indicator.position.y = offsetY + bodyH / 2 + indicatorSize;
            indicator.position.z = offsetZ + bodyD * 0.3;
            mesh.add(indicator);
        }
        
        function resetLensParams(id) {
            const p = state.projectors.find(x => x.id === id);
            if (p) {
                p.lens = {
                    type: 'rectilinear',
                    fisheyeFov: 180,
                    shiftH: 0, shiftV: 0,
                    k1: 0, k2: 0, k3: 0,
                    p1: 0, p2: 0,
                    cx: 0, cy: 0
                };
                updateProjectorMatrix(p);
                updateShadowMap(p);
                updateAllSurfaceMaterials();
                updatePropertiesPanel();
                calculateCoverage();
            }
        }
        
        function updateSurfaceProp(id, prop, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                // Validate gain
                if (prop === 'gain') val = Math.max(0.1, Math.min(5, val));
                if (prop === 'curvature') val = Math.max(0, Math.min(180, val));
                if (prop === 'segments') val = Math.max(8, Math.min(128, val));
                
                // Handle type change - set appropriate default dimensions
                if (prop === 'type') {
                    if (val === 'sphere' && s.type !== 'sphere') {
                        // Switching to sphere - set radius based on current size
                        const avgSize = (s.dimensions.width + s.dimensions.height) / 2;
                        s.dimensions.radius = avgSize / 2;
                        s.segments = 32;
                    } else if (val === 'cube' && s.type !== 'cube') {
                        // Switching to cube - ensure depth is set
                        if (!s.dimensions.depth) {
                            s.dimensions.depth = s.dimensions.width;
                        }
                    }
                }
                
                s[prop] = val;
                updateSurfaceMesh(s);
                updateSurfaceList();
                updatePropertiesPanel();
            }
        }
        
        function updateSurfacePos(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                saveStateForUndo(`Move ${s.name} (panel)`);
                s.position[axis] = val;
                updateSurfaceMesh(s);
                updateGizmoPosition();  // Update gizmo to follow moved object
            }
        }
        
        function updateSurfaceRot(id, axis, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                saveStateForUndo(`Rotate ${s.name} (panel)`);
                s.rotation[axis] = val;
                updateSurfaceMesh(s);
                updateGizmoPosition();  // Update gizmo to follow rotated object
            }
        }
        
        function updateSurfaceDim(id, dim, val) {
            const s = state.surfaces.find(x => x.id === id);
            if (s) {
                saveStateForUndo(`Resize ${s.name}`);
                // Validate dimensions - must be positive
                val = Math.max(0.1, Math.min(100, val));
                s.dimensions[dim] = val;
                updateSurfaceMesh(s);
                updateSurfaceList();
            }
        }
        
        function updateSurfaceScale(id, scale) {
            const s = state.surfaces.find(x => x.id === id);
            if (s && s.type === 'custom') {
                // Validate scale
                scale = Math.max(0.1, Math.min(10, scale));
                s.scale = scale;
                // Update the mesh scale
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === id);
                if (mesh) {
                    mesh.scale.setScalar(scale);
                }
                updateAllSurfaceMaterials();
                debouncedCalculateCoverage();
            }
        }
        
        // Debounced coverage calculation for better performance
        let coverageTimeout = null;
        function debouncedCalculateCoverage() {
            if (coverageTimeout) clearTimeout(coverageTimeout);
            coverageTimeout = setTimeout(calculateCoverage, 150);
        }
        
        // ==========================================
        // VIEW & OPTIONS
        // ==========================================
        
        function setView(view) {
            state.currentView = view;
            document.querySelectorAll('.view-btn:not(.pilot-btn)').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Show/hide pilot button based on view
            const pilotBtn = document.getElementById('pilot-mode-btn');
            if (view === 'projector') {
                pilotBtn.style.display = 'inline-block';
            } else {
                pilotBtn.style.display = 'none';
                // Disable pilot mode when leaving projector POV
                if (pilotMode.enabled) {
                    pilotMode.enabled = false;
                    pilotMode.projectorId = null;
                    pilotBtn.classList.remove('active');
                }
            }
            
            const views = {
                perspective: () => { camera.position.set(0, 8, -18); camera.rotation.set(0, Math.PI, 0); },
                top: () => { camera.position.set(0, 25, 0.01); camera.rotation.set(-Math.PI/2, 0, 0); },
                front: () => { camera.position.set(0, 3, -20); camera.rotation.set(0, Math.PI, 0); },
                side: () => { camera.position.set(-20, 3, 0); camera.rotation.set(0, Math.PI/2, 0); },
                projector: () => {
                    let p = null;
                    if (state.selectedType === 'projector' && state.selectedObject) {
                        p = state.projectors.find(x => x.id === state.selectedObject);
                    }
                    if (!p && state.projectors.length) p = state.projectors[0];
                    if (p) {
                        pilotMode.projectorId = p.id;
                        camera.position.set(p.position.x, p.position.y, p.position.z);
                        const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(
                            THREE.MathUtils.degToRad(p.rotation.x),
                            THREE.MathUtils.degToRad(p.rotation.y),
                            THREE.MathUtils.degToRad(p.rotation.z), 'YXZ'
                        ));
                        camera.lookAt(p.position.x + forward.x * 10, p.position.y + forward.y * 10, p.position.z + forward.z * 10);
                    }
                }
            };
            views[view]?.();
            document.getElementById('camera-info').textContent = view.charAt(0).toUpperCase() + view.slice(1);
        }
        
        function togglePilotMode() {
            pilotMode.enabled = !pilotMode.enabled;
            const pilotBtn = document.getElementById('pilot-mode-btn');
            pilotBtn.classList.toggle('active', pilotMode.enabled);
            
            if (pilotMode.enabled && pilotMode.projectorId) {
                // Save undo state before starting pilot mode
                saveUndo();
                // Select the projector we're piloting
                selectObject('projector', pilotMode.projectorId);
            }
        }
        
        // Debounce timer for pilot mode undo saves
        let pilotUndoTimer = null;
        
        function syncProjectorToCamera() {
            if (!pilotMode.enabled || !pilotMode.projectorId) return;
            
            const p = state.projectors.find(x => x.id === pilotMode.projectorId);
            if (!p) return;
            
            // Get camera position
            p.position.x = camera.position.x;
            p.position.y = camera.position.y;
            p.position.z = camera.position.z;
            
            // Get camera rotation and convert to projector rotation
            // Camera looks at -Z, projector looks at +Z
            // A 180Â° Y flip also inverts X rotation behavior
            camera.rotation.order = 'YXZ';
            // Negate X rotation because 180Â° Y flip inverts pitch direction
            p.rotation.x = -THREE.MathUtils.radToDeg(camera.rotation.x);
            // Add 180Â° to Y rotation to flip the direction
            p.rotation.y = THREE.MathUtils.radToDeg(camera.rotation.y) + 180;
            // Normalize to -180 to 180 range
            while (p.rotation.y > 180) p.rotation.y -= 360;
            while (p.rotation.y < -180) p.rotation.y += 360;
            // Negate Z rotation as well due to the flip
            p.rotation.z = -THREE.MathUtils.radToDeg(camera.rotation.z);
            
            // Update projector visuals and projection
            updateProjectorMatrix(p);
            updateProjectorMesh(p);
            updateShadowMap(p);
            updateAllSurfaceMaterials();
            updatePropertiesPanel();
            updateGizmoPosition();
            
            // Debounced undo save - save state after 500ms of no changes
            if (pilotUndoTimer) clearTimeout(pilotUndoTimer);
            pilotUndoTimer = setTimeout(() => {
                saveUndo();
                pilotUndoTimer = null;
            }, 500);
        }
        
        function toggleOption(opt) {
            state.displayOptions[opt] = !state.displayOptions[opt];
            document.getElementById(`toggle-${opt}`).classList.toggle('active', state.displayOptions[opt]);
            
            if (opt === 'frustums') projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
            else if (opt === 'grid') gridHelper.visible = state.displayOptions.grid;
            else if (opt === 'wireframe') surfaceGroup.children.forEach(m => { if (m.material) m.material.wireframe = state.displayOptions.wireframe; });
            else if (opt === 'heatmap') {
                document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) m.material.uniforms.showHeatmap.value = state.displayOptions.heatmap;
                });
            }
            else if (opt === 'coverage' || opt === 'overlap') {
                surfaceGroup.children.forEach(m => {
                    if (m.material?.uniforms) {
                        m.material.uniforms.showCoverage.value = state.displayOptions.coverage;
                        m.material.uniforms.showOverlap.value = state.displayOptions.overlap;
                    }
                });
            }
            else if (opt === 'distance') {
                updateDistanceHelpers();
            }
        }
        
        function updateAmbientLight(value) {
            state.sceneSettings.ambientLight = value;
            // Update the shader uniform on all surfaces
            const intensity = value / 100;
            surfaceGroup.children.forEach(mesh => {
                if (mesh.material?.uniforms?.ambientIntensity) {
                    mesh.material.uniforms.ambientIntensity.value = intensity;
                }
            });
        }
        
        function updateDefaultSurfaceColor(color) {
            state.sceneSettings.defaultSurfaceColor = color;
        }
        
        function applyColorToAllSurfaces() {
            const color = state.sceneSettings.defaultSurfaceColor;
            state.surfaces.forEach(surface => {
                surface.color = color;
                // Update the mesh material
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (mesh && mesh.material?.uniforms?.baseColor) {
                    mesh.material.uniforms.baseColor.value.set(color);
                }
            });
            updateSurfaceList();
            updatePropertiesPanel();
            showToast(`Applied color to ${state.surfaces.length} surfaces`);
        }
        
        function resetSceneSettings() {
            // Reset to defaults
            state.sceneSettings.ambientLight = 10;
            state.sceneSettings.defaultSurfaceColor = '#808080';
            
            // Update UI
            document.getElementById('ambient-light-slider').value = 10;
            document.getElementById('ambient-light-input').value = 10;
            document.getElementById('default-surface-color').value = '#808080';
            
            // Apply ambient light change
            updateAmbientLight(10);
            
            showToast('Scene settings reset to defaults');
        }
        
        // Debug mode: visualize lens type and rejection reasons
        let debugLensTypeEnabled = false;
        function toggleDebugLensType() {
            debugLensTypeEnabled = !debugLensTypeEnabled;
            surfaceGroup.children.forEach(m => {
                if (m.material?.uniforms?.debugLensType) {
                    m.material.uniforms.debugLensType.value = debugLensTypeEnabled;
                }
            });
            showToast(debugLensTypeEnabled ? 
                'Debug Mode ON: Green=Rectilinear, Blue=Fisheye, Dark colors=rejection reasons (Ctrl+D to toggle)' : 
                'Debug Mode OFF');
        }
        
        function updateDistanceHelpers() {
            // Clear existing helpers
            while (distanceHelperGroup.children.length > 0) {
                const child = distanceHelperGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                distanceHelperGroup.remove(child);
            }
            
            // Remove any existing labels
            document.querySelectorAll('.distance-label').forEach(el => el.remove());
            
            if (!state.displayOptions.distance) return;
            
            const enabledProjectors = state.projectors.filter(p => p.enabled);
            if (enabledProjectors.length === 0 || surfaceGroup.children.length === 0) return;
            
            enabledProjectors.forEach(proj => {
                // Get projector world position and direction
                const projMesh = projectorGroup.children.find(c => c.userData.projectorId === proj.id);
                if (!projMesh) return;
                
                const projPos = new THREE.Vector3(proj.position.x, proj.position.y, proj.position.z);
                
                // Calculate forward direction from rotation
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(proj.rotation.x),
                    THREE.MathUtils.degToRad(proj.rotation.y),
                    THREE.MathUtils.degToRad(proj.rotation.z),
                    'YXZ'
                );
                const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                
                // Raycast from projector center to find nearest surface
                const raycaster = new THREE.Raycaster(projPos, forward, 0.1, proj.farPlane || 100);
                const intersects = raycaster.intersectObjects(surfaceGroup.children, false);
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const distance = hit.distance;
                    
                    // Create line from projector to hit point
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([projPos, hit.point]);
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00, 
                        transparent: true, 
                        opacity: 0.8,
                        depthTest: false
                    });
                    const line = new THREE.Line(lineGeom, lineMat);
                    line.renderOrder = 999;
                    distanceHelperGroup.add(line);
                    
                    // Create a small sphere at the hit point
                    const sphereGeom = new THREE.SphereGeometry(0.05, 8, 8);
                    const sphereMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
                    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                    sphere.position.copy(hit.point);
                    sphere.renderOrder = 999;
                    distanceHelperGroup.add(sphere);
                    
                    // Create HTML label for distance
                    const label = document.createElement('div');
                    label.className = 'distance-label';
                    label.innerHTML = `
                        <strong>${proj.name}</strong><br>
                        ${distance.toFixed(2)}m
                    `;
                    label.dataset.projectorId = proj.id;
                    document.querySelector('.viewport').appendChild(label);
                    
                    // Store hit point for label positioning in animate loop
                    label.hitPoint = hit.point.clone();
                    label.midPoint = projPos.clone().add(hit.point).multiplyScalar(0.5);
                }
            });
        }
        
        function updateHeatmapMax(value) {
            state.heatmapMax = value;
            document.getElementById('legend-mid').textContent = Math.round(value / 2);
            document.getElementById('legend-max').textContent = value + '+';
            
            // Update all surface materials with new heatmap max
            surfaceGroup.children.forEach(m => {
                if (m.material?.uniforms?.heatmapMax) {
                    m.material.uniforms.heatmapMax.value = value;
                }
            });
        }
        
        function setPattern(pattern) {
            state.currentPattern = pattern;
            document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Reset scroll offset when changing pattern
            patternScrollState.offset = { x: 0, y: 0 };
            
            updateAllSurfaceMaterials();
        }
        
        function togglePatternScroll() {
            patternScrollState.enabled = !patternScrollState.enabled;
            document.getElementById('toggle-pattern-scroll').classList.toggle('active', patternScrollState.enabled);
            
            // Reset offset when disabling
            if (!patternScrollState.enabled) {
                patternScrollState.offset = { x: 0, y: 0 };
                // Reset shader uniforms on all surfaces
                surfaceGroup.children.forEach(mesh => {
                    if (mesh.material && mesh.material.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (mesh.material.uniforms[`texOffset${i}`]) {
                                mesh.material.uniforms[`texOffset${i}`].value.set(0, 0);
                            }
                        }
                    }
                });
            }
        }
        
        function updatePatternScrollSpeed(speed) {
            patternScrollState.speed = speed;
        }
        
        function updatePatternScrollDirection(direction) {
            patternScrollState.direction = direction;
        }
        
        // ==========================================
        // UTILITY
        // ==========================================
        
        function updateStatus() {
            const enabledCount = state.projectors.filter(p => p.enabled).length;
            
            // Count total projection slots including array instances
            const allSlots = getAllProjectorSlots();
            const totalSlots = allSlots.length;
            const numPasses = Math.max(1, Math.ceil(totalSlots / 8));
            
            let projText = state.projectors.length + ' Projector' + (state.projectors.length !== 1 ? 's' : '');
            if (totalSlots > 0) {
                projText += ` (${totalSlots} slots`;
                if (numPasses > 1) {
                    projText += `, ${numPasses} passes`;
                }
                projText += ')';
            }
            document.getElementById('projector-status').textContent = projText;
            document.getElementById('surface-status').textContent = state.surfaces.length + ' Surface' + (state.surfaces.length !== 1 ? 's' : '');
        }
        
        function resetScene() {
            while (projectorGroup.children.length) projectorGroup.remove(projectorGroup.children[0]);
            while (surfaceGroup.children.length) { const m = surfaceGroup.children[0]; m.material?.dispose(); m.geometry?.dispose(); surfaceGroup.remove(m); }
            
            // Clean up video textures
            videoTextureData.forEach((videoData) => {
                if (videoData.updateInterval) clearInterval(videoData.updateInterval);
                videoData.video.pause();
                videoData.video.src = '';
                if (videoData.texture) videoData.texture.dispose();
            });
            videoTextureData.clear();
            
            state.projectors = []; state.surfaces = []; state.selectedObject = null; state.selectedType = null;
            projectorMatrixData.clear(); projectionTextures.clear(); customTextureData.clear();
            updateProjectorList(); updateSurfaceList(); updatePropertiesPanel(); updateStatus();
            updateCoverageDisplay(0, 0, 0, 0);
            
            // Clear undo history (old IDs no longer valid)
            undoHistory.length = 0;
            
            // Reset transform tools
            enableTransformTools(false);
            setTransformMode('select');
            if (gizmoGroup) gizmoGroup.visible = false;
        }
        
        // ==========================================
        // IMPORT / EXPORT
        // ==========================================
        
        const exportOptions = {
            projectors: true,
            surfaces: true,
            settings: true,
            textures: false,
            format: 'json'  // 'json' or 'csv'
        };
        
        const importOptions = {
            replace: true,
            merge: false
        };
        
        let pendingImportData = null;
        let pendingImportFormat = 'json';  // 'json' or 'csv'
        
        function setExportFormat(format) {
            // Legacy function - no longer used
        }
        
        // ==========================================
        // COORDINATE SYSTEM TRANSFORMS
        // ==========================================
        // disguise: X=right, Y=forward (toward stage), Z=up (Z-up, right-handed)
        // Three.js/Our scene: X=right, Y=up, Z=forward (Y-up, right-handed)
        //
        // Position transform (swap Y and Z):
        //   Three.js X = disguise X
        //   Three.js Y = disguise Z (up)
        //   Three.js Z = disguise Y (forward)
        //
        // Rotation transform:
        //   disguise: Pitch=around X, Yaw=around Z, Roll=around Y
        //   Three.js: X=pitch, Y=yaw, Z=roll
        //
        //   - Pitch: NEGATE (disguise negative=down, Three.js positive=down)
        //   - Yaw: NEGATE (disguise CW+, Three.js CCW+)
        //   - Roll: unchanged
        
        function disguisePosToThreeJS(pos) {
            return {
                x: pos.x,
                y: pos.z,        // Z (up) â†’ Y
                z: pos.y         // Y (forward) â†’ Z
            };
        }
        
        function threeJSPosToDisguise(pos) {
            return {
                x: pos.x,
                y: pos.z,        // Z â†’ Y (forward)
                z: pos.y         // Y â†’ Z (up)
            };
        }
        
        function disguiseRotToThreeJS(rot) {
            // rot = { pitch, yaw, roll } in degrees
            return {
                x: -rot.pitch,   // NEGATE: opposite tilt convention
                y: -rot.yaw,     // NEGATE: CW to CCW conversion
                z: rot.roll
            };
        }
        
        function threeJSRotToDisguise(rot) {
            // rot = { x, y, z } in degrees
            return {
                pitch: -rot.x,   // NEGATE: opposite tilt convention
                yaw: -rot.y,     // NEGATE: CCW to CW conversion
                roll: rot.z
            };
        }
        
        function disguiseToThreeJS(pos, rot) {
            return {
                position: disguisePosToThreeJS(pos),
                rotation: disguiseRotToThreeJS(rot)
            };
        }
        
        function threeJSToDisguise(pos, rot) {
            return {
                position: threeJSPosToDisguise(pos),
                rotation: threeJSRotToDisguise(rot)
            };
        }
        
        // Export to disguise-compatible CSV format
        function exportToCSV() {
            const headers = [
                'Projector_Name',
                'Projector_Qte(Stack)',
                'Projector_Native-Rez-X',
                'Projector_Native-Rez-Y',
                'Projector_Lumens(lux)',
                'Projector_Brightness(%)',
                'Projector_Total_Lumens(lux)',
                'Projector_Trow-Ratio',
                'Lens_Shift-H(%)',
                'Lens_Shift-V(%)',
                'Lens_X',
                'Lens_Y',
                'Lens_Z',
                'Pitch(deg)',
                'Yaw(deg)',
                'Roll(deg)',
                'Target_X',
                'Target_Y',
                'Target_Z',
                'Target_Distance',
                'Target_Width',
                'Target_Height',
                'Target_Illuminance',
                'Target_DPI',
                'Unit_Dim',
                'Unit_Illuminance',
                'Projector_UUID'
            ];
            
            const rows = [];
            
            state.projectors.forEach(p => {
                // Get all instances (handles arrays)
                const instances = getProjectorArrayInstances(p);
                
                instances.forEach((instance, idx) => {
                    // Get world transform for this instance
                    const worldTransform = getArrayInstanceWorldTransform(p, instance);
                    
                    const metrics = calculateProjectorMetrics(p);
                    const resParts = p.resolution.split('Ã—');
                    const resX = parseInt(resParts[0]) || 1920;
                    const resY = parseInt(resParts[1]) || 1080;
                    
                    // Calculate target point using world transform
                    const targetDist = p.frustumDistance || 20;
                    
                    const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(worldTransform.rotation.x),
                        THREE.MathUtils.degToRad(worldTransform.rotation.y),
                        THREE.MathUtils.degToRad(worldTransform.rotation.z),
                        'YXZ'
                    );
                    const forward = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                    
                    const targetThreeJS = {
                        x: worldTransform.position.x + forward.x * targetDist,
                        y: worldTransform.position.y + forward.y * targetDist,
                        z: worldTransform.position.z + forward.z * targetDist
                    };
                    
                    // Transform to disguise coordinates
                    const disguisePos = threeJSPosToDisguise(worldTransform.position);
                    const disguiseRot = threeJSRotToDisguise(worldTransform.rotation);
                    const disguiseTarget = threeJSPosToDisguise(targetThreeJS);
                    
                    // Name with array index if applicable
                    const name = instances.length > 1 ? `${p.name}_${idx + 1}` : p.name;
                    // UUID - generate unique for array instances
                    const uuid = instances.length > 1 ? generateUUID() : (p.uuid || generateUUID());
                    
                    rows.push([
                        name,
                        p.stack || 1,
                        resX,
                        resY,
                        p.lumens,
                        p.brightness || 100,
                        metrics.effectiveLumens,
                        p.throwRatio,
                        p.lens?.shiftH || 0,
                        p.lens?.shiftV || 0,
                        disguisePos.x.toFixed(3),
                        disguisePos.y.toFixed(3),
                        disguisePos.z.toFixed(3),
                        disguiseRot.pitch.toFixed(8),
                        disguiseRot.yaw.toFixed(8),
                        disguiseRot.roll.toFixed(8),
                        disguiseTarget.x.toFixed(3),
                        disguiseTarget.y.toFixed(3),
                        disguiseTarget.z.toFixed(3),
                        metrics.distance.toFixed(3),
                        metrics.width.toFixed(3),
                        metrics.height.toFixed(3),
                        Math.round(metrics.illuminance),
                        metrics.dpi.toFixed(2),
                        'm',
                        'lux',
                        uuid
                    ].join(','));
                });
            });
            
            return [headers.join(','), ...rows].join('\n');
        }
        
        // Export all surfaces to OBJ format
        function exportToOBJ() {
            let objContent = '# Projection Studio OBJ Export\n';
            objContent += `# Generated: ${new Date().toISOString()}\n`;
            objContent += `# Surfaces: ${state.surfaces.length}\n\n`;
            
            let vertexOffset = 0;
            let uvOffset = 0;
            let normalOffset = 0;
            
            state.surfaces.forEach(surface => {
                // Find the mesh for this surface
                const mesh = surfaceGroup.children.find(c => c.userData.surfaceId === surface.id);
                if (!mesh || !mesh.geometry) return;
                
                // Get the geometry in world coordinates
                const geometry = mesh.geometry.clone();
                mesh.updateMatrixWorld();
                geometry.applyMatrix4(mesh.matrixWorld);
                
                // Ensure we have the attributes
                if (!geometry.attributes.position) return;
                
                const positions = geometry.attributes.position.array;
                const uvs = geometry.attributes.uv ? geometry.attributes.uv.array : null;
                const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
                const indices = geometry.index ? geometry.index.array : null;
                
                // Clean the surface name for OBJ (remove special chars)
                const cleanName = surface.name.replace(/[^a-zA-Z0-9_-]/g, '_');
                objContent += `# Surface: ${surface.name}\n`;
                objContent += `o ${cleanName}\n`;
                
                // Write vertices
                const vertexCount = positions.length / 3;
                for (let i = 0; i < vertexCount; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];
                    objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
                }
                
                // Write texture coordinates
                if (uvs) {
                    const uvCount = uvs.length / 2;
                    for (let i = 0; i < uvCount; i++) {
                        const u = uvs[i * 2];
                        const v = uvs[i * 2 + 1];
                        objContent += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
                    }
                }
                
                // Write normals
                if (normals) {
                    const normalCount = normals.length / 3;
                    for (let i = 0; i < normalCount; i++) {
                        const nx = normals[i * 3];
                        const ny = normals[i * 3 + 1];
                        const nz = normals[i * 3 + 2];
                        objContent += `vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n`;
                    }
                }
                
                // Write faces
                if (indices) {
                    // Indexed geometry
                    const faceCount = indices.length / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const a = indices[i * 3] + 1 + vertexOffset;
                        const b = indices[i * 3 + 1] + 1 + vertexOffset;
                        const c = indices[i * 3 + 2] + 1 + vertexOffset;
                        
                        if (uvs && normals) {
                            const ua = indices[i * 3] + 1 + uvOffset;
                            const ub = indices[i * 3 + 1] + 1 + uvOffset;
                            const uc = indices[i * 3 + 2] + 1 + uvOffset;
                            const na = indices[i * 3] + 1 + normalOffset;
                            const nb = indices[i * 3 + 1] + 1 + normalOffset;
                            const nc = indices[i * 3 + 2] + 1 + normalOffset;
                            objContent += `f ${a}/${ua}/${na} ${b}/${ub}/${nb} ${c}/${uc}/${nc}\n`;
                        } else if (uvs) {
                            const ua = indices[i * 3] + 1 + uvOffset;
                            const ub = indices[i * 3 + 1] + 1 + uvOffset;
                            const uc = indices[i * 3 + 2] + 1 + uvOffset;
                            objContent += `f ${a}/${ua} ${b}/${ub} ${c}/${uc}\n`;
                        } else {
                            objContent += `f ${a} ${b} ${c}\n`;
                        }
                    }
                } else {
                    // Non-indexed geometry (triangles)
                    const faceCount = vertexCount / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const a = i * 3 + 1 + vertexOffset;
                        const b = i * 3 + 2 + vertexOffset;
                        const c = i * 3 + 3 + vertexOffset;
                        
                        if (uvs && normals) {
                            objContent += `f ${a}/${a - vertexOffset + uvOffset}/${a - vertexOffset + normalOffset} ${b}/${b - vertexOffset + uvOffset}/${b - vertexOffset + normalOffset} ${c}/${c - vertexOffset + uvOffset}/${c - vertexOffset + normalOffset}\n`;
                        } else if (uvs) {
                            objContent += `f ${a}/${a - vertexOffset + uvOffset} ${b}/${b - vertexOffset + uvOffset} ${c}/${c - vertexOffset + uvOffset}\n`;
                        } else {
                            objContent += `f ${a} ${b} ${c}\n`;
                        }
                    }
                }
                
                // Update offsets for next object
                vertexOffset += vertexCount;
                if (uvs) uvOffset += uvs.length / 2;
                if (normals) normalOffset += normals.length / 3;
                
                objContent += '\n';
                
                // Clean up cloned geometry
                geometry.dispose();
            });
            
            return objContent;
        }
        
        // Parse disguise CSV format
        function parseDisguiseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header and at least one data row');
            }
            
            const headers = lines[0].split(',').map(h => h.trim());
            const projectors = [];
            
            // Map header names to indices
            const headerMap = {};
            headers.forEach((h, i) => headerMap[h] = i);
            
            // Helper to get value by header name
            const getValue = (row, header, defaultVal = 0) => {
                const idx = headerMap[header];
                if (idx === undefined || idx >= row.length) return defaultVal;
                const val = row[idx];
                return val === '' ? defaultVal : val;
            };
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Parse CSV line (handle potential commas in quoted fields)
                const row = line.split(',').map(v => v.trim());
                
                const name = getValue(row, 'Projector_Name', `Projector ${i}`);
                const resX = parseInt(getValue(row, 'Projector_Native-Rez-X', 1920));
                const resY = parseInt(getValue(row, 'Projector_Native-Rez-Y', 1080));
                
                // Raw disguise coordinates (Z-up system)
                const disguisePos = {
                    x: parseFloat(getValue(row, 'Lens_X', 0)),
                    y: parseFloat(getValue(row, 'Lens_Y', 0)),
                    z: parseFloat(getValue(row, 'Lens_Z', 2.5))
                };
                const disguiseRot = {
                    pitch: parseFloat(getValue(row, 'Pitch(deg)', 0)),
                    yaw: parseFloat(getValue(row, 'Yaw(deg)', 0)),
                    roll: parseFloat(getValue(row, 'Roll(deg)', 0))
                };
                const disguiseTarget = {
                    x: parseFloat(getValue(row, 'Target_X', 0)),
                    y: parseFloat(getValue(row, 'Target_Y', 0)),
                    z: parseFloat(getValue(row, 'Target_Z', 0))
                };
                
                // Transform from disguise (Z-up) to Three.js (Y-up)
                // disguise: X=right, Y=forward, Z=up
                // Three.js: X=right, Y=up, Z=towards camera
                const transformed = disguiseToThreeJS(disguisePos, disguiseRot);
                const transformedTarget = disguisePosToThreeJS(disguiseTarget);
                
                const projector = {
                    id: Date.now() + Math.random() * 1000,
                    uuid: getValue(row, 'Projector_UUID', generateUUID()),
                    name: name,
                    preset: 'custom',
                    position: transformed.position,
                    rotation: transformed.rotation,
                    lumens: parseFloat(getValue(row, 'Projector_Lumens(lux)', 10000)),
                    brightness: parseFloat(getValue(row, 'Projector_Brightness(%)', 100)),
                    stack: parseInt(getValue(row, 'Projector_Qte(Stack)', 1)),
                    throwRatio: parseFloat(getValue(row, 'Projector_Trow-Ratio', 1.5)),
                    aspectRatio: resX / resY,
                    resolution: `${resX}Ã—${resY}`,
                    zoom: 1.0,
                    enabled: true,
                    customTextureUrl: null,
                    nearPlane: 0.1,
                    farPlane: 100,
                    frustumDistance: parseFloat(getValue(row, 'Target_Distance', 20)),
                    lens: {
                        type: 'rectilinear',
                        fisheyeFov: 180,
                        shiftH: parseFloat(getValue(row, 'Lens_Shift-H(%)', 0)),
                        shiftV: parseFloat(getValue(row, 'Lens_Shift-V(%)', 0)),
                        k1: 0, k2: 0, k3: 0,
                        p1: 0, p2: 0,
                        cx: parseFloat(getValue(row, 'Lens_Shift-H(%)', 0)) / 50,
                        cy: parseFloat(getValue(row, 'Lens_Shift-V(%)', 0)) / 50
                    },
                    target: transformedTarget
                };
                
                projectors.push(projector);
            }
            
            return { projectors, surfaces: [] };
        }
        
        function showExportModal() {
            // Show the "project moved" modal
            document.getElementById('export-modal').classList.add('active');
        }
        
        function _showExportModalInternal() {
            // Legacy function - no longer used
            showExportModal();
        }
        
        function toggleExportOption(option) {
            // Legacy function - no longer used
        }
        
        function toggleImportOption(option) {
            // Radio-button behavior for replace/merge
            if (option === 'replace') {
                importOptions.replace = true;
                importOptions.merge = false;
            } else if (option === 'merge') {
                importOptions.replace = false;
                importOptions.merge = true;
            }
            
            document.getElementById('import-check-replace').classList.toggle('checked', importOptions.replace);
            document.getElementById('import-check-merge').classList.toggle('checked', importOptions.merge);
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            if (id === 'import-modal') {
                pendingImportData = null;
            }
        }
        
        function toggleContactPanel() {
            const panel = document.getElementById('contact-panel');
            panel.classList.toggle('active');
            
            // Close when clicking outside
            if (panel.classList.contains('active')) {
                setTimeout(() => {
                    document.addEventListener('click', closeContactPanelOutside);
                }, 10);
            }
        }
        
        function closeContactPanelOutside(e) {
            const panel = document.getElementById('contact-panel');
            const wrapper = e.target.closest('.contact-wrapper');
            if (!wrapper && panel.classList.contains('active')) {
                panel.classList.remove('active');
                document.removeEventListener('click', closeContactPanelOutside);
            }
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            
            toastMessage.textContent = message;
            toast.className = `toast ${type} active`;
            
            // Update icon based on type
            const svg = toast.querySelector('svg');
            if (type === 'success') {
                svg.innerHTML = '<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>';
            } else if (type === 'error') {
                svg.innerHTML = '<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>';
            }
            
            setTimeout(() => {
                toast.classList.remove('active');
            }, 3000);
        }
        

        function doExport() {
            // Legacy function - no longer used
            // Export functionality moved to hosted version
        }

        
        function importConfig(file) {
            if (!file) return;
            
            const isCSV = file.name.toLowerCase().endsWith('.csv');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    
                    if (isCSV) {
                        // Parse CSV (disguise format)
                        data = parseDisguiseCSV(e.target.result);
                        pendingImportFormat = 'csv';
                        
                        // Update preview for CSV
                        document.getElementById('import-version').textContent = 'disguise CSV';
                        document.getElementById('import-projectors').textContent = 
                            `${data.projectors.length} projector${data.projectors.length !== 1 ? 's' : ''}`;
                        document.getElementById('import-surfaces').textContent = 'None (CSV only contains projectors)';
                        document.getElementById('import-textures').textContent = 'None';
                        document.getElementById('import-settings').textContent = 'Not included';
                    } else {
                        // Parse JSON
                        data = JSON.parse(e.target.result);
                        pendingImportFormat = 'json';
                        
                        // Update preview for JSON
                        document.getElementById('import-version').textContent = data.version || 'Unknown';
                        document.getElementById('import-projectors').textContent = 
                            data.projectors ? `${data.projectors.length} projector${data.projectors.length !== 1 ? 's' : ''}` : 'None';
                        
                        // Show surface count with custom OBJ info
                        const customObjCount = data.surfaces ? data.surfaces.filter(s => s.type === 'custom' && s.objData).length : 0;
                        let surfaceText = data.surfaces ? `${data.surfaces.length} surface${data.surfaces.length !== 1 ? 's' : ''}` : 'None';
                        if (customObjCount > 0) {
                            surfaceText += ` (${customObjCount} custom OBJ)`;
                        }
                        document.getElementById('import-surfaces').textContent = surfaceText;
                        
                        const imageCount = data.projectors ? data.projectors.filter(p => p.customTextureUrl && p.customTextureType !== 'video').length : 0;
                        document.getElementById('import-textures').textContent = 
                            imageCount > 0 ? `${imageCount} image${imageCount !== 1 ? 's' : ''} embedded` : 'None';
                        
                        document.getElementById('import-settings').textContent = 
                            data.settings ? 'Included' : 'Not included';
                    }
                    
                    pendingImportData = data;
                    
                    // Show modal
                    document.getElementById('import-modal').classList.add('active');
                    
                    // Clear file input so same file can be selected again
                    document.getElementById('import-file').value = '';
                    
                } catch (err) {
                    showToast(`Error parsing file: ${isCSV ? 'Invalid CSV format' : 'Invalid JSON format'}`, 'error');
                    console.error('Import error:', err);
                }
            };
            reader.onerror = function() {
                showToast('Error reading file', 'error');
            };
            reader.readAsText(file);
        }
        
        function doImport() {
            if (!pendingImportData) {
                showToast('No import data available', 'error');
                return;
            }
            
            const data = pendingImportData;
            
            // Clear scene if replacing
            if (importOptions.replace) {
                resetScene();
            }
            
            let importedProjectors = 0;
            let importedSurfaces = 0;
            
            // Import projectors
            if (data.projectors && Array.isArray(data.projectors)) {
                data.projectors.forEach(projData => {
                    const id = Date.now() + Math.random() * 1000;
                    const projector = {
                        id,
                        uuid: projData.uuid || generateUUID(),
                        name: projData.name || `Projector ${state.projectors.length + 1}`,
                        preset: projData.preset || 'custom',
                        position: projData.position || { x: 0, y: 4, z: -8 },
                        rotation: projData.rotation || { x: -10, y: 0, z: 0 },
                        lumens: projData.lumens || 10000,
                        brightness: projData.brightness || 100,
                        stack: projData.stack || 1,
                        throwRatio: projData.throwRatio || 1.5,
                        aspectRatio: projData.aspectRatio || 16/9,
                        resolution: projData.resolution || '1920Ã—1080',
                        zoom: projData.zoom || 1.0,
                        enabled: projData.enabled !== false,
                        customTextureUrl: projData.customTextureUrl || null,
                        customTextureType: projData.customTextureType || null,
                        videoResolution: projData.videoResolution || null,
                        nearPlane: projData.nearPlane || 0.1,
                        farPlane: projData.farPlane || 100,
                        frustumDistance: projData.frustumDistance || 20,
                        lens: projData.lens ? {
                            type: projData.lens.type || 'rectilinear',
                            fisheyeFov: projData.lens.fisheyeFov || 180,
                            shiftH: projData.lens.shiftH || 0,
                            shiftV: projData.lens.shiftV || 0,
                            k1: projData.lens.k1 || 0,
                            k2: projData.lens.k2 || 0,
                            k3: projData.lens.k3 || 0,
                            p1: projData.lens.p1 || 0,
                            p2: projData.lens.p2 || 0,
                            cx: projData.lens.cx || (projData.lens.shiftH || 0) / 50,
                            cy: projData.lens.cy || (projData.lens.shiftV || 0) / 50
                        } : {
                            type: 'rectilinear',
                            fisheyeFov: 180,
                            shiftH: 0, shiftV: 0,
                            k1: 0, k2: 0, k3: 0,
                            p1: 0, p2: 0,
                            cx: 0, cy: 0
                        },
                        body: projData.body ? {
                            width: projData.body.width || 0.4,
                            height: projData.body.height || 0.2,
                            depth: projData.body.depth || 0.5,
                            offsetX: projData.body.offsetX || 0,
                            offsetY: projData.body.offsetY || 0,
                            offsetZ: projData.body.offsetZ || 0
                        } : {
                            width: 0.4, height: 0.2, depth: 0.5,
                            offsetX: 0, offsetY: 0, offsetZ: 0
                        },
                        target: projData.target || null,
                        parentId: projData.parentId || null,
                        array: projData.array ? {
                            count: projData.array.count || 2,
                            spacing: projData.array.spacing || { x: 2, y: 0, z: 0 },
                            rotationOffset: projData.array.rotationOffset || { x: 0, y: 0, z: 0 }
                        } : null
                    };
                    
                    state.projectors.push(projector);
                    createProjectorMesh(projector);
                    
                    // Load custom texture if present (only images, not videos)
                    if (projector.customTextureUrl && projector.customTextureType !== 'video') {
                        const img = new Image();
                        img.onload = function() {
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            customTextureData.set(projector.id, texture);
                            projectionTextures.set(projector.id, texture);
                            updateAllSurfaceMaterials();
                        };
                        img.src = projector.customTextureUrl;
                    } else if (projector.customTextureType === 'video') {
                        // Video textures can't be embedded - clear the reference
                        projector.customTextureUrl = null;
                        projector.customTextureType = null;
                        projector.videoResolution = null;
                    }
                    
                    updateProjectorMatrix(projector);
                    updateShadowMap(projector);  // Create shadow map for imported projector
                    importedProjectors++;
                });
            }
            
            // Import surfaces
            if (data.surfaces && Array.isArray(data.surfaces)) {
                data.surfaces.forEach(surfData => {
                    const id = Date.now() + Math.random() * 1000;
                    const surface = {
                        id,
                        name: surfData.name || `Surface ${state.surfaces.length + 1}`,
                        type: surfData.type || 'flat',
                        position: surfData.position || { x: 0, y: 3, z: 5 },
                        rotation: surfData.rotation || { x: 0, y: 180, z: 0 },
                        dimensions: surfData.dimensions || { width: 8, height: 4.5 },
                        curvature: surfData.curvature || 30,
                        segments: surfData.segments || 32,  // For sphere surfaces
                        color: surfData.color || '#555555',
                        gain: surfData.gain || 1.0,
                        scale: surfData.scale || 1.0,
                        parentId: surfData.parentId || null,  // Hierarchy parent
                        objData: surfData.objData || null // Preserve custom OBJ data
                    };
                    
                    state.surfaces.push(surface);
                    createSurfaceMesh(surface);
                    importedSurfaces++;
                });
            }
            
            // Import settings
            if (data.settings) {
                if (data.settings.currentPattern) {
                    state.currentPattern = data.settings.currentPattern;
                    document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                    // Try to activate the right pattern button
                    const patternBtns = document.querySelectorAll('.pattern-btn');
                    const patterns = ['none', 'grid', 'checker', 'gradient', 'colorbars', 'cross', 'white', 'blend'];
                    const idx = patterns.indexOf(data.settings.currentPattern);
                    if (idx >= 0 && patternBtns[idx]) patternBtns[idx].classList.add('active');
                }
                
                if (data.settings.displayOptions) {
                    Object.keys(data.settings.displayOptions).forEach(key => {
                        if (state.displayOptions.hasOwnProperty(key)) {
                            state.displayOptions[key] = data.settings.displayOptions[key];
                            const toggle = document.getElementById(`toggle-${key}`);
                            if (toggle) toggle.classList.toggle('active', state.displayOptions[key]);
                        }
                    });
                    
                    // Apply display options
                    projectorGroup.traverse(c => { if (c.userData.isFrustum) c.visible = state.displayOptions.frustums; });
                    gridHelper.visible = state.displayOptions.grid;
                    document.getElementById('heatmap-panel').style.display = state.displayOptions.heatmap ? 'block' : 'none';
                }
                
                if (data.settings.heatmapMax) {
                    state.heatmapMax = data.settings.heatmapMax;
                    const heatmapSlider = document.getElementById('heatmap-max-slider');
                    const heatmapInput = document.getElementById('heatmap-max-input');
                    const legendMid = document.getElementById('legend-mid');
                    const legendMax = document.getElementById('legend-max');
                    if (heatmapSlider) heatmapSlider.value = data.settings.heatmapMax;
                    if (heatmapInput) heatmapInput.value = data.settings.heatmapMax;
                    if (legendMid) legendMid.textContent = Math.round(data.settings.heatmapMax / 2);
                    if (legendMax) legendMax.textContent = data.settings.heatmapMax + '+';
                }
                
                // Import scene settings
                if (data.settings.sceneSettings) {
                    if (data.settings.sceneSettings.ambientLight !== undefined) {
                        state.sceneSettings.ambientLight = data.settings.sceneSettings.ambientLight;
                        document.getElementById('ambient-light-slider').value = data.settings.sceneSettings.ambientLight;
                        document.getElementById('ambient-light-input').value = data.settings.sceneSettings.ambientLight;
                        updateAmbientLight(data.settings.sceneSettings.ambientLight);
                    }
                    if (data.settings.sceneSettings.defaultSurfaceColor) {
                        state.sceneSettings.defaultSurfaceColor = data.settings.sceneSettings.defaultSurfaceColor;
                        document.getElementById('default-surface-color').value = data.settings.sceneSettings.defaultSurfaceColor;
                    }
                }
            }
            
            // Update UI
            updateAllSurfaceMaterials();
            updateProjectorList();
            updateSurfaceList();
            updateStatus();
            calculateCoverage();
            
            // Re-enable transform tools (they get disabled by resetScene)
            // Select first projector if any were imported, otherwise first surface
            if (state.projectors.length > 0) {
                selectObject('projector', state.projectors[0].id);
            } else if (state.surfaces.length > 0) {
                selectObject('surface', state.surfaces[0].id);
            } else {
                enableTransformTools(false);
            }
            
            // Update undo button state
            updateUndoButton();
            
            closeModal('import-modal');
            
            const message = `Imported ${importedProjectors} projector${importedProjectors !== 1 ? 's' : ''} and ${importedSurfaces} surface${importedSurfaces !== 1 ? 's' : ''}`;
            showToast(message);
        }
        
        function quickSave() {
            // Show the "project moved" modal
            document.getElementById('export-modal').classList.add('active');
        }
        
        function _quickSaveInternal() {
            // Legacy function - no longer used
            quickSave();
        }
        
        function confirmNewProject() {
            if (state.projectors.length === 0 && state.surfaces.length === 0) {
                // Nothing to lose, just reset
                resetScene();
                showToast('New project created');
                return;
            }
            
            if (confirm('Start a new project? All unsaved changes will be lost.')) {
                resetScene();
                showToast('New project created');
            }
        }
        
        // ==========================================
        // ANIMATION
        // ==========================================
        
        let lastTime = performance.now(), frames = 0;
        function animate() {
            requestAnimationFrame(animate);
            updateCameraMovement();
            
            const deltaTime = 1/60; // Approximate delta time
            
            // Update video textures (for downsampled videos that need canvas updates)
            videoTextureData.forEach((videoData, projectorId) => {
                if (videoData.playing && videoData.texture) {
                    // For downsampled textures, copy video frame to canvas
                    if (videoData.texture.userData && videoData.texture.userData.isDownsampled) {
                        const { ctx, canvas, video } = videoData.texture.userData;
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        videoData.texture.needsUpdate = true;
                    } else {
                        // For native VideoTexture, just mark as needs update
                        videoData.texture.needsUpdate = true;
                    }
                }
            });
            
            // Update pattern scroll animation
            if (patternScrollState.enabled && state.currentPattern !== 'none') {
                const speed = patternScrollState.speed * deltaTime;
                
                switch (patternScrollState.direction) {
                    case 'horizontal':
                        patternScrollState.offset.x += speed;
                        break;
                    case 'vertical':
                        patternScrollState.offset.y += speed;
                        break;
                    case 'diagonal':
                        patternScrollState.offset.x += speed * 0.707;
                        patternScrollState.offset.y += speed * 0.707;
                        break;
                }
                
                // Wrap offsets
                patternScrollState.offset.x %= 1;
                patternScrollState.offset.y %= 1;
            } else if (patternScrollState.offset.x !== 0 || patternScrollState.offset.y !== 0) {
                // Reset offsets when disabled
                patternScrollState.offset.x = 0;
                patternScrollState.offset.y = 0;
            }
            
            // Update gizmo scale based on camera distance (only if not dragging)
            if (gizmoGroup && gizmoGroup.visible && !gizmoState.isDragging) {
                const dist = camera.position.distanceTo(gizmoGroup.position);
                const scale = dist * 0.15;
                gizmoGroup.scale.setScalar(Math.max(0.5, Math.min(scale, 2)));
            }
            
            // Update distance label positions in screen space
            if (state.displayOptions.distance) {
                const container = document.querySelector('.viewport');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    
                    document.querySelectorAll('.distance-label').forEach(label => {
                        if (label.midPoint) {
                            const screenPos = label.midPoint.clone().project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * rect.width;
                            const y = (-screenPos.y * 0.5 + 0.5) * rect.height;
                            
                            // Only show if in front of camera
                            if (screenPos.z < 1) {
                                label.style.left = x + 'px';
                                label.style.top = y + 'px';
                                label.style.display = 'block';
                            } else {
                                label.style.display = 'none';
                            }
                        }
                    });
                }
            }
            
            frames++;
            if (performance.now() - lastTime >= 1000) {
                document.getElementById('fps-counter').textContent = frames + ' FPS';
                frames = 0; lastTime = performance.now();
            }
            
            // Multi-pass rendering for unlimited projectors
            renderMultiPass();
        }
        
        // Cached default textures for multi-pass rendering
        let cachedDefaultTex = null;
        let cachedDefaultShadowTex = null;
        
        function getDefaultTextures() {
            if (!cachedDefaultTex) {
                cachedDefaultTex = createPatternTexture('none');
            }
            if (!cachedDefaultShadowTex) {
                cachedDefaultShadowTex = new THREE.DataTexture(new Uint8Array([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat);
                cachedDefaultShadowTex.needsUpdate = true;
            }
            return { defaultTex: cachedDefaultTex, defaultShadowTex: cachedDefaultShadowTex };
        }
        
        // Multi-pass rendering to overcome 16 texture unit limit
        function renderMultiPass() {
            // Get all projector slots (including array instances)
            const allSlots = getAllProjectorSlots();
            
            // First pass: Update shadow maps for ALL slots (including array instances)
            allSlots.forEach(slot => {
                updateShadowMapForTransform(slot.projector, slot.worldTransform, slot.shadowKey);
            });
            
            // Pre-calculate all slot data
            const slotDataArray = allSlots.map(slot => {
                const slotData = {
                    projMat: new THREE.Matrix4(),
                    shadowMat: new THREE.Matrix4(),
                    projPos: new THREE.Vector3(),
                    projRotInv: new THREE.Matrix3(),
                    projLumens: 0,
                    projThrow: 1.5,
                    projNear: 0.1,
                    projFar: 100,
                    texOffset: new THREE.Vector2(0, 0),
                    lensParams: new THREE.Vector4(0, 0, 0, 0),
                    lensParams2: new THREE.Vector4(0, 0, 0, 0),
                    fisheyeFov: 180,
                    projTex: null,
                    shadowTex: null
                };
                calculateProjectorSlotData(slot.projector, slot.worldTransform, slotData, slot.shadowKey);
                return slotData;
            });
            
            // Determine number of passes (8 projectors per pass)
            const numPasses = Math.max(1, Math.ceil(slotDataArray.length / 8));
            
            // Get list of surfaces with shader materials
            const surfaceMeshes = [];
            surfaceGroup.children.forEach(mesh => {
                if (mesh.material && mesh.material.uniforms) {
                    const surfaceId = mesh.userData.surfaceId;
                    const surface = state.surfaces.find(s => s.id === surfaceId);
                    if (surface) {
                        surfaceMeshes.push({ mesh, surface });
                    }
                }
            });
            
            // Check if any visualization mode is enabled
            const visualizationEnabled = state.displayOptions.coverage || 
                                         state.displayOptions.overlap || 
                                         state.displayOptions.heatmap;
            
            // If no slots, just render scene normally with ambient
            if (slotDataArray.length === 0) {
                surfaceMeshes.forEach(({ mesh, surface }) => {
                    updateMaterialForPass(mesh.material, [], true, surface);
                });
                renderer.render(scene, camera);
                return;
            }
            
            // If visualization is enabled AND we have more than 8 projectors, use accumulation system
            if (visualizationEnabled && numPasses > 1 && accumulationTarget && colorTarget) {
                renderWithAccumulation(slotDataArray, surfaceMeshes, numPasses);
                return;
            }
            
            // Standard rendering path (visualization works for first 8 projectors only)
            // Pass 0: Full scene render with first 8 projectors
            const pass0Slots = slotDataArray.slice(0, 8);
            surfaceMeshes.forEach(({ mesh, surface }) => {
                updateMaterialForPass(mesh.material, pass0Slots, true, surface);
            });
            renderer.render(scene, camera);
            
            // Additional passes: Only render surfaces with additive blending
            if (numPasses > 1) {
                // Save visibility states
                const gizmoVisible = gizmoGroup ? gizmoGroup.visible : false;
                const projectorVisible = projectorGroup.visible;
                const distanceVisible = distanceHelperGroup ? distanceHelperGroup.visible : false;
                const gridVisible = gridHelper ? gridHelper.visible : false;
                
                // CRITICAL: Save and remove scene background to prevent it from overwriting
                const savedBackground = scene.background;
                scene.background = null;
                
                // Hide non-surface objects for additive passes
                if (gizmoGroup) gizmoGroup.visible = false;
                projectorGroup.visible = false;
                if (distanceHelperGroup) distanceHelperGroup.visible = false;
                if (gridHelper) gridHelper.visible = false;
                
                // Disable depth and color clear for additive passes
                renderer.autoClear = false;
                
                for (let pass = 1; pass < numPasses; pass++) {
                    const startIdx = pass * 8;
                    const endIdx = Math.min(startIdx + 8, slotDataArray.length);
                    const passSlots = slotDataArray.slice(startIdx, endIdx);
                    
                    // Update surface materials for this pass
                    surfaceMeshes.forEach(({ mesh, surface }) => {
                        updateMaterialForPass(mesh.material, passSlots, false, surface);
                    });
                    
                    // Render just the surfaces (no background since scene.background = null)
                    renderer.render(scene, camera);
                }
                
                // Restore scene background first
                scene.background = savedBackground;
                
                // Restore visibility and autoClear
                renderer.autoClear = true;
                if (gizmoGroup) gizmoGroup.visible = gizmoVisible;
                projectorGroup.visible = projectorVisible;
                if (distanceHelperGroup) distanceHelperGroup.visible = distanceVisible;
                if (gridHelper) gridHelper.visible = gridVisible;
                
                // Reset materials to normal blending state for next frame's pass 0
                surfaceMeshes.forEach(({ mesh, surface }) => {
                    mesh.material.transparent = false;
                    mesh.material.blending = THREE.NormalBlending;
                    mesh.material.depthWrite = true;
                    mesh.material.depthFunc = THREE.LessEqualDepth;
                });
            }
        }
        
        // Render with accumulation system for proper visualization across all projectors
        function renderWithAccumulation(slotDataArray, surfaceMeshes, numPasses) {
            // Save visibility states
            const gizmoVisible = gizmoGroup ? gizmoGroup.visible : false;
            const projectorVisible = projectorGroup.visible;
            const distanceVisible = distanceHelperGroup ? distanceHelperGroup.visible : false;
            const gridVisible = gridHelper ? gridHelper.visible : false;
            const savedBackground = scene.background;
            
            // ========================================
            // PHASE 1: Render accumulation (hit count + luminance)
            // ========================================
            renderer.setRenderTarget(accumulationTarget);
            renderer.setClearColor(0x000000, 0);
            renderer.clear();
            
            // Hide non-surface objects
            if (gizmoGroup) gizmoGroup.visible = false;
            projectorGroup.visible = false;
            if (distanceHelperGroup) distanceHelperGroup.visible = false;
            if (gridHelper) gridHelper.visible = false;
            scene.background = null;
            
            // Save original materials
            const originalMaterials = new Map();
            surfaceMeshes.forEach(({ mesh }) => {
                originalMaterials.set(mesh, mesh.material);
            });
            
            // Render all passes to accumulation buffer
            for (let pass = 0; pass < numPasses; pass++) {
                const startIdx = pass * 8;
                const endIdx = Math.min(startIdx + 8, slotDataArray.length);
                const passSlots = slotDataArray.slice(startIdx, endIdx);
                
                surfaceMeshes.forEach(({ mesh, surface }) => {
                    // Get or create accumulation material
                    let accumMat = accumulationMaterials.get(mesh.userData.surfaceId);
                    if (!accumMat) {
                        accumMat = createAccumulationMaterial(mesh.material);
                        accumulationMaterials.set(mesh.userData.surfaceId, accumMat);
                    }
                    
                    // Update uniforms for this pass
                    updateMaterialForPass(mesh.material, passSlots, pass === 0, surface);
                    syncAccumulationMaterial(mesh.material, accumMat);
                    
                    mesh.material = accumMat;
                    
                    // Set blending for additive accumulation
                    if (pass > 0) {
                        accumMat.transparent = true;
                        accumMat.blending = THREE.AdditiveBlending;
                        accumMat.depthWrite = false;
                    } else {
                        accumMat.transparent = false;
                        accumMat.blending = THREE.NormalBlending;
                        accumMat.depthWrite = true;
                    }
                });
                
                if (pass > 0) {
                    renderer.autoClear = false;
                }
                renderer.render(scene, camera);
            }
            
            // ========================================
            // PHASE 2: Render color (surfaces + background only, without visualization)
            // ========================================
            renderer.setRenderTarget(colorTarget);
            renderer.autoClear = true;
            renderer.setClearColor(0x0a0a0c, 1);
            renderer.clear();
            
            // Restore materials and disable visualization flags
            surfaceMeshes.forEach(({ mesh, surface }) => {
                mesh.material = originalMaterials.get(mesh);
                mesh.material.uniforms.showCoverage.value = false;
                mesh.material.uniforms.showOverlap.value = false;
                mesh.material.uniforms.showHeatmap.value = false;
            });
            
            // Include background but NOT grid, gizmos, or projectors
            // Grid renders in Phase 4 to avoid being affected by visualization
            scene.background = savedBackground;
            if (gridHelper) gridHelper.visible = false;
            if (gizmoGroup) gizmoGroup.visible = false;
            projectorGroup.visible = false;
            if (distanceHelperGroup) distanceHelperGroup.visible = false;
            
            const pass0Slots = slotDataArray.slice(0, 8);
            surfaceMeshes.forEach(({ mesh, surface }) => {
                updateMaterialForPass(mesh.material, pass0Slots, true, surface);
                // Keep visualization flags off
                mesh.material.uniforms.showCoverage.value = false;
                mesh.material.uniforms.showOverlap.value = false;
                mesh.material.uniforms.showHeatmap.value = false;
            });
            renderer.render(scene, camera);
            
            // Additional color passes (surfaces only)
            if (numPasses > 1) {
                scene.background = null;
                renderer.autoClear = false;
                
                for (let pass = 1; pass < numPasses; pass++) {
                    const startIdx = pass * 8;
                    const endIdx = Math.min(startIdx + 8, slotDataArray.length);
                    const passSlots = slotDataArray.slice(startIdx, endIdx);
                    
                    surfaceMeshes.forEach(({ mesh, surface }) => {
                        updateMaterialForPass(mesh.material, passSlots, false, surface);
                        mesh.material.uniforms.showCoverage.value = false;
                        mesh.material.uniforms.showOverlap.value = false;
                        mesh.material.uniforms.showHeatmap.value = false;
                    });
                    
                    renderer.render(scene, camera);
                }
            }
            
            // ========================================
            // PHASE 3: Composite with visualization
            // ========================================
            renderer.setRenderTarget(null);
            renderer.autoClear = true;
            
            compositeMaterial.uniforms.colorTexture.value = colorTarget.texture;
            compositeMaterial.uniforms.accumTexture.value = accumulationTarget.texture;
            compositeMaterial.uniforms.showCoverage.value = state.displayOptions.coverage;
            compositeMaterial.uniforms.showOverlap.value = state.displayOptions.overlap;
            compositeMaterial.uniforms.showHeatmap.value = state.displayOptions.heatmap;
            compositeMaterial.uniforms.heatmapMax.value = state.displayOptions.heatmapMax || 1000;
            
            renderer.render(compositeScene, compositeCamera);
            
            // ========================================
            // PHASE 4: Render overlays with proper depth occlusion
            // ========================================
            // Render grid, gizmos, projectors, and distance helpers AFTER composite
            // but still respecting surface occlusion
            renderer.autoClear = false;  // Don't clear the composite result
            
            // Clear only the depth buffer
            renderer.clearDepth();
            
            // First, render surfaces to DEPTH BUFFER ONLY (no color output)
            // This restores depth information so overlays are properly occluded by surfaces
            surfaceMeshes.forEach(({ mesh }) => {
                mesh.visible = true;
                mesh.material.colorWrite = false;  // Write depth only, not color
                mesh.material.depthWrite = true;   // Ensure depth writing is enabled
                mesh.material.side = THREE.DoubleSide;  // Render both sides for proper occlusion
            });
            
            scene.background = null;
            if (gridHelper) gridHelper.visible = false;
            if (gizmoGroup) gizmoGroup.visible = false;
            projectorGroup.visible = false;
            if (distanceHelperGroup) distanceHelperGroup.visible = false;
            
            renderer.render(scene, camera);
            
            // Restore color write and hide surfaces for overlay render
            surfaceMeshes.forEach(({ mesh }) => {
                mesh.material.colorWrite = true;
                mesh.visible = false;
            });
            
            // Now render overlays - they will be depth-tested against surfaces
            // Grid renders first (on the floor), then other overlays
            if (gridHelper) gridHelper.visible = gridVisible;
            if (gizmoGroup) gizmoGroup.visible = gizmoVisible;
            projectorGroup.visible = projectorVisible;
            if (distanceHelperGroup) distanceHelperGroup.visible = distanceVisible;
            
            // Render overlays to screen
            renderer.render(scene, camera);
            
            // ========================================
            // Restore state
            // ========================================
            renderer.autoClear = true;
            scene.background = savedBackground;
            
            // Restore surface visibility
            surfaceMeshes.forEach(({ mesh }) => {
                mesh.visible = true;
            });
            
            // Restore grid visibility
            if (gridHelper) gridHelper.visible = gridVisible;
            
            // Restore visualization flags for UI consistency
            surfaceMeshes.forEach(({ mesh }) => {
                mesh.material.uniforms.showCoverage.value = state.displayOptions.coverage;
                mesh.material.uniforms.showOverlap.value = state.displayOptions.overlap;
                mesh.material.uniforms.showHeatmap.value = state.displayOptions.heatmap;
                mesh.material.transparent = false;
                mesh.material.blending = THREE.NormalBlending;
                mesh.material.depthWrite = true;
                mesh.material.depthFunc = THREE.LessEqualDepth;
            });
        }
        
        init();
    </script>
</body>
</html>
